<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>汇编语言总结</title>
      <link href="/2019/09/01/hui-bian-yu-yan-zong-jie/"/>
      <url>/2019/09/01/hui-bian-yu-yan-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>汇编基础知识总结</p><a id="more"></a><h2 id="分段的本质"><a href="#分段的本质" class="headerlink" title="分段的本质"></a>分段的本质</h2><p>X86 体系架构在早期寄存器是 16 位，而地址却又 20 位，为了让 16 位寄存器能够访问 20 位地址，设计出将内存分段的方法，即地址由 <code>段地址x16+偏移地址=物理地址</code> ，这样内存就可以通过一个个的段来访问了，包括 CS、DS、SS、ES 都采用该方式来访问内存。请注意一个内存地址可以采用不同的 <code>段地址：偏移地址</code> 来访问。</p><h2 id="寄存器（内存访问）"><a href="#寄存器（内存访问）" class="headerlink" title="寄存器（内存访问）"></a>寄存器（内存访问）</h2><p>数据在内存中存放分为大端和小端，小端即寄存器数据的低位存放在内存的低位，大端正好相反。小端与日常计数习惯不符，需要注意。</p><p>段寄存器需要通过通用寄存器赋值。</p><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内单元。这完全是自己的安排。数据段、代码段、栈段都是可以自行指定。当将段地址放入 DS 后，CPU 就将段中数据当成数据来访问；定义代码段后，CPU 就把其中内容当成指令执行；栈段的解释类似。</p><p>访问内存单元时有时可以显示指定段地址的 ds cs ss es ，在汇编中称为 段前缀。</p><p>为了程序更加模块化和清晰，往往需要将程序划分为不同的段。划分段后，需要初始化相应的段寄存器。</p><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><table><thead><tr><th>寻址方式</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>[idata]</td><td>直接寻址</td><td></td></tr><tr><td>[bx]</td><td>寄存器间接寻址</td><td></td></tr><tr><td>[si]</td><td>寄存器间接寻址</td><td></td></tr><tr><td>[di]</td><td>寄存器间接寻址</td><td></td></tr><tr><td>[bp]</td><td>寄存器间接寻址</td><td></td></tr><tr><td>[bx+idata]</td><td>寄存器相对寻址</td><td>[bx].idata:结构体；idata[si]:数组；[bx] [idata]：二维数组</td></tr><tr><td>[si+idata]</td><td>寄存器相对寻址</td><td></td></tr><tr><td>[di+idata]</td><td>寄存器相对寻址</td><td></td></tr><tr><td>[bx+si]</td><td>基址变址寻址</td><td>二维数组：[bi] [si]</td></tr><tr><td>[bx+di+idata]</td><td>相对基址变址寻址</td><td>二维数组：idata[bx] [si]</td></tr></tbody></table><h3 id="指令处理数据长度"><a href="#指令处理数据长度" class="headerlink" title="指令处理数据长度"></a>指令处理数据长度</h3><p>在指令中需要明确告诉 CPU 数据的长度，可以通过两种方式：</p><ol><li>寄存器明确指定</li><li>操作符 X ptr 指定内存单元的长度， X 可以为 word byte（A&amp;T 汇编通过操作符指定待处理数据的长度）</li></ol><h2 id="伪指令-dd"><a href="#伪指令-dd" class="headerlink" title="伪指令 dd"></a>伪指令 dd</h2><p>dd 定义双字， DB 定义字节，DW 定义字</p><h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><p>对数据重复定义：</p><p>db 重复次数 dup （重复的字节数据）</p><p>dw 重复次数 dup （重复的字数据）</p><p>dd 重复次数 dup （重复的双字数据）</p><hr><h2 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h2><p>8086 CPU 转移分为：</p><ol><li>只修改 IP 的段内转移，如 jmp ax</li><li>同时修改 CS 和 IP ，段间转移 ，如 jmp 1000:0</li></ol><p>对 IP 的修改范围不同，段内转移又分为短转移和近转移：</p><ol><li>短转移 IP 修改范围 -128- 127</li><li>近转移 IP 修改范围 -32768-32767</li></ol><p>转移指令分为以下几类：</p><ul><li>无条件转移</li><li>条件转移</li><li>循环指令</li><li>过程</li><li>中断</li></ul><p>段内转移指令记录的是偏移量，使用偏移量拥有更好的灵活性。</p><p>jmp short 标号功能为：(IP)=(IP)+8位位移。</p><ol><li>8 位位移 = 标号处的地址 - jmp 指令后的第一个字节的地址。</li><li>short 指明此处的位移为 8 位</li><li>8位位移用补码表示</li><li>8位位移有编译器计算</li></ol><p>jmp near ptr 标号 功能类似。</p><p>jmp far ptr 标号会同时修改 CS 和 IP。</p><p>编译器维护了一个指令地址变量，如果 jmp 标号 中的标号在前面出现，那么可以直接计算偏移量；如果标号在后面才出现，编译器会用 nop 指令填充标号，当遇到标号时再计算其偏移量。</p><p>jmp 后面除了接标号还可以有如下形式：</p><ul><li>jmp 寄存器</li><li>jmp word ptr 内存单元地址（段内转移）</li><li>jmp dword ptr 内存单元地址（段间转移）</li></ul><h2 id="CALL-和-RET"><a href="#CALL-和-RET" class="headerlink" title="CALL 和 RET"></a>CALL 和 RET</h2><p>CALL 指令完成以下两步操作：</p><ul><li>将当前 IP 或 CS 和 IP 入栈  (push ip 或者 push CS push IP)</li><li>转移（jmp）</li></ul><p>CALL 除了不能段内短转移，转移方式同 jmp。</p><p>RET 指令相当于 pop IP；retf 相当于 pop IP pop CS</p><p>设计子程序时注意寄存器冲突，可以采用栈来保存寄存器，子程序返回后再恢复。</p><h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>标志寄存器有三个作用：</p><ol><li>存储相关指令执行结果</li><li>为 CPU 执行指令提供依据</li><li>控制 CPU 相关工作方式</li></ol><p>影响标志寄存器的一般是算术和逻辑运算如（add sub mul div inc or and ) </p><h2 id="ZF-标志"><a href="#ZF-标志" class="headerlink" title="ZF 标志"></a>ZF 标志</h2><p>执行结果是否为 0 </p><h2 id="PF-标志"><a href="#PF-标志" class="headerlink" title="PF 标志"></a>PF 标志</h2><p>执行结果是否有偶数个 1</p><h3 id="SF-标志"><a href="#SF-标志" class="headerlink" title="SF 标志"></a>SF 标志</h3><p>SF 标志是 CPU 对有符号数运算结果的一种记录，记录数据的正负，对无符号数无意义。</p><h3 id="CF-标志"><a href="#CF-标志" class="headerlink" title="CF 标志"></a>CF 标志</h3><p>进行无符号数运算时，记录最高位是否有进位或借位。注意是针对无符号运算。</p><h3 id="OF-标志"><a href="#OF-标志" class="headerlink" title="OF 标志"></a>OF 标志</h3><p>在进行有符号数据运算时，结果超过了机器表示的范围则溢出。</p><p>机器表示的范围是指补码形式的范围，如 8 位寄存器范围为 -128~127 。发生溢出后计算结果将不正确，需要记录下来。</p><p>特别注意：CF 和 OF 的区别，CF 是对无符号运算有意义，OF 是对有符号数运算有意义。比如：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">mov al,98add al,99<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于无符号数据 99 + 98 没有进位，CF =0 ；对于有符号数运算，发生溢出 OF=1 .</p><p>在 cmp 指令比较有符号数据大小时，cmp a b 指令执行后 sf =1 ，就说明操作对象a &lt; b 吗？从逻辑上，a-b &lt;0 则  a 小于 b，但是注意下面的情况：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov ah,22hmov bh,0a0hcmp ah,bh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ah - bh = 82H ,在逻辑上结果应该是 34-（-96）=130 但是 130 溢出了，而 sf 只会根据最高位决定正负，所以 sf 并不能代表逻辑上的正负，而 cmp 关系的恰恰是逻辑上的正负，之所以 sf 不能表示逻辑上的正负，是因为溢出的原因，所以必须综合考虑 sf 和 of 标志来决定逻辑上的正负。</p><p>从上面可以体会 CPU 设计的思路，CPU 只是按照二进制计算规则进行计算，并设置相应标志位，那么到底是有符号运算还是无符号运算，需要使用者按照自己的意图来看待， CPU 只是提供了各种可能性的组合。</p><h3 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h3><p>df =0 每次操作后 si、dis 递增 ，配合 movsb 和 movsw 可以将 ds:si 指向的内存单元字节（字）传入到 es: di 中，并根据 df 标志递增（减）。</p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>CPU 通过中断机制响应外部和内部发送的特殊信息。内部中断包括除法错误、单步执行、 into 指令、int 指令等，外部中断包括外设。</p><p>中断就像函数或信号，涉及到怎么通知 CPU ，以及 CPU 怎么找到中断处理程序两个问题。</p><p>就像 unix 信号一样，通过中断号通知 CPU ，CPU 到约定的地方查找中断处理程序（中断向量表）。</p><p>中断向量表包含了中断程序的入口地址，通过新增入口地址就可以安装新的中断处理程序，中断处理过程如下：</p><ol><li>从中断信息中获取中断类型码 N</li><li>标志寄存器入栈（pushf）</li><li>设置标志寄存器的 TF IF=0</li><li>CS 内容入栈（push CS)</li><li>IP 内容入栈（push IP）</li><li>从内存地址为中断码x4和中断类型码x4+2 的地址处读取中断程序入口地址，赋值给 IP CS （(IP)=(N<em>4),(CS)=(N</em>4+2)</li></ol><p>中断处理程序过程如下：</p><ol><li>保存用到的寄存器</li><li>处理中断</li><li>恢复寄存器</li><li>iret 返回</li></ol><p>CPU 在执行完一条指令后，如果检测到标志寄存器的 TF 为 1，则产生单步中断，类型码为 1 ，故执行 1 号中断处理程序。通过该机制就可以实现单步调试了。</p><h3 id="int-iret-和-栈的深入理解"><a href="#int-iret-和-栈的深入理解" class="headerlink" title="int iret 和 栈的深入理解"></a>int iret 和 栈的深入理解</h3><p>使用 7ch 中断完成 loop 指令功能。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codecode segmentstart:  move ax,0b800h        move ex,ax        mov di,160*2        move bx,offset s - offset se  ;设置从标号 se 到 标号 s 的转移位移        move cx,80    s   :move byte ptr es:[di],'!'        add di,2        int 7ch                            ;如果 cx!=0,转到标号 s 处    se: nop        mov ax,4c00h        int 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>中断处理程序需要能够根据 cx 的值，决定跳转到标号 s 处，那么怎么在中断处理程序中获得其地址呢？其实根据上面的中断过程，CPU 调用中断时会将 IP 入栈，此时 IP 指向 se ，se + bx 便能得到标号 s 的地址：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lp: push bp    mov bp,sp    dec cx    jcxz lpret    add [bp+2],bxlpret: pop bp    iret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该例子阐述了如何灵活运用栈以及中断的工作原理。</p><h3 id="中断和屏蔽"><a href="#中断和屏蔽" class="headerlink" title="中断和屏蔽"></a>中断和屏蔽</h3><p>中断分为可屏蔽中断和不可屏蔽中断。可屏蔽中断是指 CPU 可以不响应的外中断。CPU 是否可以响应中断，要看标志寄存器 IF 的设置。当 CPU 检测到可屏蔽中断时，如果 IF=1 ，则 CPU 执行完当前指令后响应中断，引发中断过程；如果 IF=0，则不响应可屏蔽中断。</p><p>我们可以在中断执行过程中将 IF 设置为0 ，禁止其他可屏蔽中断。sti 可以设置 IF=1 cli 可以设置中断 IF=0 。</p><p>不可屏蔽中断是指，CPU 检查到中断后，执行完当前指令，立即响应，引发中断过程。</p><p>注意上面说的 <code>当前指令</code> ，由于中断处理过程的发起需要用到 ss 和 sp ，试想刚刚执行完 ss 的操作，即将执行 sp 的操作是，中断来了，此时直接进入中断有可能会导致栈的错乱，所以一般将 ss 和 sp 的指令紧邻，从而保证其 <code>原子性</code>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解</title>
      <link href="/2018/12/20/tcp-ip-xiang-jie-1/"/>
      <url>/2018/12/20/tcp-ip-xiang-jie-1/</url>
      
        <content type="html"><![CDATA[<p>本章主要介绍 TCP/IP 协议整体内容。</p><a id="more"></a><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>TCP/IP 协议族分为四个层次：</p><ol><li>链路层</li><li>网络层，包含 IP 协议、ICMP 协议、IGMP 协议</li><li>运输层，由 TCP 和 UDP 组成， TCP 提供可靠传输，将应用层数据分层合适的块交给网络层，确认接收的分组，设置超时时间，总之，TCP 提供可靠的传输；UDP 刚好相反，为应用层提供简单的服务，不保证数据报能到达另一端。</li><li>应用层，包含 <code>Telnet</code>、<code>FTP</code>、<code>SMTP</code>、<code>SNMP</code></li></ol><p><img src="D:\Blog\BlogOnGithub\cquliaoli.github.io\source_posts\TCP-IP详解-1\tcp.png" alt="1545317401054"></p><p>TCP/IP 协议最精华的地方就在于分层和抽象，每一层可以看成是独立的，不用关心下一层的实现细节，每一层只需要完成该层的工作，每一层可以有不同的实现方式，是不是和面向接口不谋而合？</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>由于整个协议分层设计，那么当有数据发送时，必然要<code>穿越</code>各个层次，并加上首部，以标识上一层信息。</p><p><img src="D:\Blog\BlogOnGithub\cquliaoli.github.io\source_posts\TCP-IP详解-1\tcp1.png" alt="1545319475650"></p><h3 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h3><p>当主机收到一个以太网帧时，数据重协议栈由底向上升，同时去掉首部，并根据首部检查协议标识，以确定接收数据的上层协议，这个过程叫分用（Demultiplexing）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> TCP </category>
          
          <category> IP </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> IP </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存架构</title>
      <link href="/2018/12/18/huan-cun-jia-gou/"/>
      <url>/2018/12/18/huan-cun-jia-gou/</url>
      
        <content type="html"><![CDATA[<p>本笔记主要记录高并发和高可用性场景下缓存架构问题。</p><a id="more"></a><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>##<br>##</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
          <category> redis </category>
          
          <category> memcache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> redis </tag>
            
            <tag> memcache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统设计与实现-保护模式进阶（续）</title>
      <link href="/2018/11/13/cao-zuo-xi-tong-she-ji-yu-shi-xian-bao-hu-mo-shi-jin-jie-xu/"/>
      <url>/2018/11/13/cao-zuo-xi-tong-she-ji-yu-shi-xian-bao-hu-mo-shi-jin-jie-xu/</url>
      
        <content type="html"><![CDATA[<p>本节介绍内核加载和特权级相关内容。</p><a id="more"></a><h2 id="内核加载"><a href="#内核加载" class="headerlink" title="内核加载"></a>内核加载</h2><p>前面我们直接使用汇编语言编写代码，不过越是底层的语言，开发效率越低，后续开发内核大部分功能肯定还是要使用 C 语言，汇编语言编写代码编译后直接就是可执行二进制文件了，C 语言编写的代码却要经过编译、汇编到目标代码，然后由连接器链接后才变成可执行文件。如下代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int main(void){  while (1) ;  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>只对其编译和汇编成目标代码：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">gcc -c -o main.o main.cfile main.o#结果main.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到目标文件是<code>可重定位文件</code>，即其中的符号和函数的地址尚未确定。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">nm main.o#输出0000000000000000 T main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果用 <code>ld</code> 命令链接后：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">ld main.o -Ttext 0xc0001500 -e main -o kernel.binfile kernel.binkernel.bin: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not strippednm kernel.bin00000000c0004000 R __bss_start00000000c0004000 R _edata00000000c0004000 R _end00000000c0001500 T main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现链接后 <code>kernel.bin</code>变成了可执行文件，且 <code>main</code> 有了相应地址。</p><h3 id="二级制程序运行方法"><a href="#二级制程序运行方法" class="headerlink" title="二级制程序运行方法"></a>二级制程序运行方法</h3><p>前面的 <code>mbr</code> 和 <code>loader</code> 的地址都是硬编码在 <code>0x7c00</code> 和 <code>0x900</code> 处，那有没有一种灵活指定程序加载地址的方式呢？很容易想到，我们需要相应的数据结构描述要加载程序的元信息，比如入口地址、大小等。其实各种协议已经为我们指明了方向，如 <code>http</code> 协议，就是由消息头和消息体组成，消息头是元信息描述了请求方法、消息内容格式、消息大小等等，比如各种消息中间件的消息格式等都是按照这种方式实现。<br>所以我们也可以用同样的方式描述可执行文件，如下图所示：</p><p><img src="ph.png" alt="ph.png"></p><h3 id="elf格式"><a href="#elf格式" class="headerlink" title="elf格式"></a>elf格式</h3><p>上面介绍的描述二进制文件的格式在<code>linux</code>下就是 <code>elf</code>。</p><p><img src="elf.png" alt="elf.png"></p><p><img src="elf1.png" alt="elf1.png"></p><p><code>elf header</code> 数据类型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">/* Type for a 16-bit quantity.  */typedef uint16_t Elf32_Half;typedef uint16_t Elf64_Half;/* Types for signed and unsigned 32-bit quantities.  */typedef uint32_t Elf32_Word;typedef    int32_t  Elf32_Sword;typedef uint32_t Elf64_Word;typedef    int32_t  Elf64_Sword;/* Types for signed and unsigned 64-bit quantities.  */typedef uint64_t Elf32_Xword;typedef    int64_t  Elf32_Sxword;typedef uint64_t Elf64_Xword;typedef    int64_t  Elf64_Sxword;/* Type of addresses.  */typedef uint32_t Elf32_Addr;typedef uint64_t Elf64_Addr;/* Type of file offsets.  */typedef uint32_t Elf32_Off;typedef uint64_t Elf64_Off;/* Type for section indices, which are 16-bit quantities.  */typedef uint16_t Elf32_Section;typedef uint16_t Elf64_Section;/* Type for version symbol information.  */typedef Elf32_Half Elf32_Versym;typedef Elf64_Half Elf64_Versym;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>elf header</code> 结构如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct{  unsigned char    e_ident[EI_NIDENT];    /* Magic number and other info */  Elf32_Half    e_type;            /* Object file type */  Elf32_Half    e_machine;        /* Architecture */  Elf32_Word    e_version;        /* Object file version */  Elf32_Addr    e_entry;        /* Entry point virtual address */  Elf32_Off    e_phoff;        /* Program header table file offset */  Elf32_Off    e_shoff;        /* Section header table file offset */  Elf32_Word    e_flags;        /* Processor-specific flags */  Elf32_Half    e_ehsize;        /* ELF header size in bytes */  Elf32_Half    e_phentsize;        /* Program header table entry size */  Elf32_Half    e_phnum;        /* Program header table entry count */  Elf32_Half    e_shentsize;        /* Section header table entry size */  Elf32_Half    e_shnum;        /* Section header table entry count */  Elf32_Half    e_shstrndx;        /* Section header string table index */} Elf32_Ehdr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中以下几个字节比较重要：</p><ul><li>Elf32_Addr    e_entry;        /* Entry point virtual address */ 程序入口虚拟地址</li><li>Elf32_Off    e_phoff;        /* Program header table file offset */ 程序头表在文件内的字节偏移量</li><li>Elf32_Half    e_ehsize;        /* ELF header size in bytes */</li><li>Elf32_Half    e_phentsize;        /* Program header table entry size */每个条目的代谢即后面介绍的 struct Elf32_Phdr</li><li>Elf32_Half    e_phnum;        /* Program header table entry count */</li></ul><p><code>struct Elf32_Phdr</code> 用来描述各个段的信息，其功能类似与 GDT 中段描述符。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">/* Program segment header.  */typedef struct{  Elf32_Word    p_type;            /* Segment type */  Elf32_Off    p_offset;        /* Segment file offset */  Elf32_Addr    p_vaddr;        /* Segment virtual address */  Elf32_Addr    p_paddr;        /* Segment physical address */  Elf32_Word    p_filesz;        /* Segment size in file */  Elf32_Word    p_memsz;        /* Segment size in memory */  Elf32_Word    p_flags;        /* Segment flags */  Elf32_Word    p_align;        /* Segment alignment */} Elf32_Phdr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="elf实例分析"><a href="#elf实例分析" class="headerlink" title="elf实例分析"></a>elf实例分析</h3><p>为了查看 <code>elf</code> 的内部，可以使用 <code>xxd</code> 命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">xxd -u -a -g l -s $2 -l $3 $1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中第一个参数为待查看文件名，第二个为文件的起始字节，第三个参数代表查看的长度。</p><p><img src="elf2.png" alt="elf2.png"></p><p>有兴趣可以逐一分析，不过注意这里结果是 <code>64</code> 环境，所以应该对照 64 位系统的 <code>elf</code>。</p><h2 id="将内核载入内存"><a href="#将内核载入内存" class="headerlink" title="将内核载入内存"></a>将内核载入内存</h2><p>磁盘规划如下图所示：</p><p> <img src="disk.png" alt="disk.png"></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo gcc -c -o main.o main.c &amp;&amp;ld main.o -Ttext 0xc0001500 -e main -o kernel.bin &amp;&amp; sudo  dd if=kernel.bin of=/usr/local/bin/hd60M.img bs=512 count=200 seek=9 conv=notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来 <code>loader.S</code> 需要修改两个地方：</p><ul><li>加载内核：将内核文件加载到内核缓冲区</li><li>初始化内核：分页后，将加载进来的 elf 内核文件放置到相应虚拟内存地址，然后跳过去执行</li></ul><p>0x500~0x9fbff 可用内存分布图如下：</p><p> <img src="mem.png" alt="mem.png"></p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">%include "boot.inc"section loader vstart=LOADER_BASE_ADDR;构建gdt及其内部的描述符GDT_BASE:   dd    0x00000000      dd    0x00000000CODE_DESC:  dd    0x0000FFFF      dd    DESC_CODE_HIGH4DATA_STACK_DESC:  dd    0x0000FFFF      dd    DESC_DATA_HIGH4VIDEO_DESC: dd    0x80000007           ; limit=(0xbffff-0xb8000)/4k=0x7      dd    DESC_VIDEO_HIGH4  ; 此时dpl为0GDT_SIZE   equ   $ - GDT_BASEGDT_LIMIT   equ   GDT_SIZE -    1times 60 dq 0                     ; 此处预留60个描述符的空位(slot)SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0     ; 同上SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0     ; 同上; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址total_mem_bytes dd 0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址gdt_ptr  dw  GDT_LIMIT   dd  GDT_BASE;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节ards_buf times 244 db 0ards_nr dw 0              ;用于记录ards结构体数量loader_start:;-------  int 15h eax = 0000E820h ,edx = 534D4150h ('SMAP') 获取内存布局  -------xor ebx, ebx              ;第一次调用时，ebx值要为0mov edx, 0x534d4150          ;edx只赋值一次，循环体中不会改变mov di, ards_buf          ;ards结构缓冲区.e820_mem_get_loop:          ;循环获取每个ARDS内存范围描述结构mov eax, 0x0000e820          ;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。mov ecx, 20              ;ARDS地址范围描述符结构大小是20字节int 0x15jc .e820_failed_so_try_e801   ;若cf位为1则有错误发生，尝试0xe801子功能add di, cx              ;使di增加20字节指向缓冲区中新的ARDS结构位置inc word [ards_nr]          ;记录ARDS数量cmp ebx, 0              ;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个jnz .e820_mem_get_loop;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。mov cx, [ards_nr]          ;遍历每一个ARDS结构体,循环次数是ARDS的数量mov ebx, ards_bufxor edx, edx              ;edx为最大的内存容量,在此先清0.find_max_mem_area:          ;无须判断type是否为1,最大的内存块一定是可被使用mov eax, [ebx]          ;base_add_lowadd eax, [ebx+8]          ;length_lowadd ebx, 20              ;指向缓冲区中下一个ARDS结构cmp edx, eax              ;冒泡排序，找出最大,edx寄存器始终是最大的内存容量jge .next_ardsmov edx, eax              ;edx为总内存大小.next_ards:loop .find_max_mem_areajmp .mem_get_ok;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。.e820_failed_so_try_e801:mov ax,0xe801int 0x15jc .e801_failed_so_try88   ;若当前e801方法失败,就尝试0x88方法;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位mov cx,0x400         ;cx和ax值一样,cx用做乘数mul cxshl edx,16and eax,0x0000FFFFor edx,eaxadd edx, 0x100000 ;ax只是15MB,故要加1MBmov esi,edx         ;先把低15MB的内存容量存入esi寄存器备份;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量xor eax,eaxmov ax,bxmov ecx, 0x10000    ;0x10000十进制为64KBmul ecx        ;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.add esi,eax        ;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可mov edx,esi        ;edx为总内存大小jmp .mem_get_ok;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------.e801_failed_so_try88:;int 15后，ax存入的是以kb为单位的内存容量mov  ah, 0x88int  0x15jc .error_hltand eax,0x0000FFFF;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位mul cxshl edx, 16         ;把dx移到高16位or edx, eax         ;把积的低16位组合到edx,为32位的积add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB.mem_get_ok:mov [total_mem_bytes], edx     ;将内存换为byte单位后存入total_mem_bytes处。;-----------------   准备进入保护模式   -------------------;1 打开A20;2 加载gdt;3 将cr0的pe位置1;-----------------  打开A20  ----------------in al,0x92or al,0000_0010Bout 0x92,al;-----------------  加载GDT  ----------------lgdt [gdt_ptr];-----------------  cr0第0位置1  ----------------mov eax, cr0or eax, 0x00000001mov cr0, eaxjmp dword SELECTOR_CODE:p_mode_start         ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，            ; 这将导致之前做的预测失效，从而起到了刷新的作用。.error_hlt:              ;出错则挂起hlt[bits 32]p_mode_start:mov ax, SELECTOR_DATAmov ds, axmov es, axmov ss, axmov esp,LOADER_STACK_TOPmov ax, SELECTOR_VIDEOmov gs, ax; -------------------------   加载kernel  ----------------------mov eax, KERNEL_START_SECTOR        ; kernel.bin所在的扇区号mov ebx, KERNEL_BIN_BASE_ADDR       ; 从磁盘读出后，写入到ebx指定的地址mov ecx, 200                   ; 读入的扇区数call rd_disk_m_32; 创建页目录及页表并初始化页内存位图call setup_page;要将描述符表地址及偏移量写入内存gdt_ptr,一会用新地址重新加载sgdt [gdt_ptr]          ; 存储到原来gdt所有的位置;将gdt描述符中视频段描述符中的段基址+0xc0000000mov ebx, [gdt_ptr + 2]or dword [ebx + 0x18 + 4], 0xc0000000      ;视频段是第3个段描述符,每个描述符是8字节,故0x18。             ;段描述符的高4字节的最高位是段基址的31~24位;将gdt的基址加上0xc0000000使其成为内核所在的高地址add dword [gdt_ptr + 2], 0xc0000000add esp, 0xc0000000        ; 将栈指针同样映射到内核地址; 把页目录地址赋给cr3mov eax, PAGE_DIR_TABLE_POSmov cr3, eax; 打开cr0的pg位(第31位)mov eax, cr0or eax, 0x80000000mov cr0, eax;在开启分页后,用gdt新的地址重新加载lgdt [gdt_ptr]             ; 重新加载;;;;;;;;;;;;;;;;;;;;;;;;;;;;  此时不刷新流水线也没问题  ;;;;;;;;;;;;;;;;;;;;;;;;;由于一直处在32位下,原则上不需要强制刷新,经过实际测试没有以下这两句也没问题.;但以防万一，还是加上啦，免得将来出来莫句奇妙的问题.jmp SELECTOR_CODE:enter_kernel      ;强制刷新流水线,更新gdtenter_kernel:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;call kernel_initmov esp, 0xc009f000jmp KERNEL_ENTRY_POINT                 ; 用地址0x1500访问测试，结果ok;-----------------   将kernel.bin中的segment拷贝到编译的地址   -----------kernel_init:xor eax, eaxxor ebx, ebx        ;ebx记录程序头表地址xor ecx, ecx        ;cx记录程序头表中的program header数量xor edx, edx        ;dx 记录program header尺寸,即e_phentsizemov dx, [KERNEL_BIN_BASE_ADDR + 42]      ; 偏移文件42字节处的属性是e_phentsize,表示program header大小mov ebx, [KERNEL_BIN_BASE_ADDR + 28]   ; 偏移文件开始部分28字节的地方是e_phoff,表示第1 个program header在文件中的偏移量         ; 其实该值是0x34,不过还是谨慎一点，这里来读取实际值add ebx, KERNEL_BIN_BASE_ADDRmov cx, [KERNEL_BIN_BASE_ADDR + 44]    ; 偏移文件开始部分44字节的地方是e_phnum,表示有几个program header.each_segment:cmp byte [ebx + 0], PT_NULL          ; 若p_type等于 PT_NULL,说明此program header未使用。je .PTNULL;为函数memcpy压入参数,参数是从右往左依然压入.函数原型类似于 memcpy(dst,src,size)push dword [ebx + 16]          ; program header中偏移16字节的地方是p_filesz,压入函数memcpy的第三个参数:sizemov eax, [ebx + 4]              ; 距程序头偏移量为4字节的位置是p_offsetadd eax, KERNEL_BIN_BASE_ADDR      ; 加上kernel.bin被加载到的物理地址,eax为该段的物理地址push eax                  ; 压入函数memcpy的第二个参数:源地址push dword [ebx + 8]              ; 压入函数memcpy的第一个参数:目的地址,偏移程序头8字节的位置是p_vaddr，这就是目的地址call mem_cpy                  ; 调用mem_cpy完成段复制add esp,12                  ; 清理栈中压入的三个参数.PTNULL:add ebx, edx                  ; edx为program header大小,即e_phentsize,在此ebx指向下一个program headerloop .each_segmentret;----------  逐字节拷贝 mem_cpy(dst,src,size) ------------;输入:栈中三个参数(dst,src,size);输出:无;---------------------------------------------------------mem_cpy:cldpush ebpmov ebp, esppush ecx           ; rep指令用到了ecx，但ecx对于外层段的循环还有用，故先入栈备份mov edi, [ebp + 8]       ; dstmov esi, [ebp + 12]       ; srcmov ecx, [ebp + 16]       ; sizerep movsb           ; 逐字节拷贝;恢复环境pop ecxpop ebpret;-------------   创建页目录及页表   ---------------setup_page:;先把页目录占用的空间逐字节清0mov ecx, 4096mov esi, 0.clear_page_dir:mov byte [PAGE_DIR_TABLE_POS + esi], 0inc esiloop .clear_page_dir;开始创建页目录项(PDE).create_pde:                     ; 创建Page Directory Entrymov eax, PAGE_DIR_TABLE_POSadd eax, 0x1000                  ; 此时eax为第一个页表的位置及属性mov ebx, eax                     ; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。;   下面将页目录项0和0xc00都存为第一个页表的地址，;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，;   这是为将地址映射为内核地址做准备or eax, PG_US_U | PG_RW_W | PG_P         ; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.mov [PAGE_DIR_TABLE_POS + 0x0], eax       ; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(3)mov [PAGE_DIR_TABLE_POS + 0xc00], eax     ; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,            ; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.sub eax, 0x1000mov [PAGE_DIR_TABLE_POS + 4092], eax         ; 使最后一个目录项指向页目录表自己的地址;下面创建页表项(PTE)mov ecx, 256                     ; 1M低端内存 / 每页大小4k = 256mov esi, 0mov edx, PG_US_U | PG_RW_W | PG_P         ; 属性为7,US=1,RW=1,P=1.create_pte:                     ; 创建Page Table Entrymov [ebx+esi*4],edx                 ; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址add edx,4096inc esiloop .create_pte;创建内核其它页表的PDEmov eax, PAGE_DIR_TABLE_POSadd eax, 0x2000              ; 此时eax为第二个页表的位置or eax, PG_US_U | PG_RW_W | PG_P  ; 页目录项的属性RW和P位为1,US为0mov ebx, PAGE_DIR_TABLE_POSmov ecx, 254                 ; 范围为第769~1022的所有目录项数量mov esi, 769.create_kernel_pde:mov [ebx+esi*4], eaxinc esiadd eax, 0x1000loop .create_kernel_pderet;-------------------------------------------------------------------------------      ;功能:读取硬盘n个扇区rd_disk_m_32:;-------------------------------------------------------------------------------            ; eax=LBA扇区号            ; ebx=将数据写入的内存地址            ; ecx=读入的扇区数   mov esi,eax       ; 备份eax   mov di,cx           ; 备份扇区数到di;读写硬盘:;第1步：设置要读取的扇区数   mov dx,0x1f2   mov al,cl   out dx,al            ;读取的扇区数   mov eax,esi       ;恢复ax;第2步：将LBA地址存入0x1f3 ~ 0x1f6   ;LBA地址7~0位写入端口0x1f3   mov dx,0x1f3   out dx,al   ;LBA地址15~8位写入端口0x1f4   mov cl,8   shr eax,cl   mov dx,0x1f4   out dx,al   ;LBA地址23~16位写入端口0x1f5   shr eax,cl   mov dx,0x1f5   out dx,al   shr eax,cl   and al,0x0f       ;lba第24~27位   or al,0xe0       ; 设置7～4位为1110,表示lba模式   mov dx,0x1f6   out dx,al;第3步：向0x1f7端口写入读命令，0x20   mov dx,0x1f7   mov al,0x20   out dx,al;;;;;;; 至此,硬盘控制器便从指定的lba地址(eax)处,读出连续的cx个扇区,下面检查硬盘状态,不忙就能把这cx个扇区的数据读出来;第4步：检测硬盘状态.not_ready:           ;测试0x1f7端口(status寄存器)的的BSY位   ;同一端口,写时表示写入命令字,读时表示读入硬盘状态   nop   in al,dx   and al,0x88       ;第4位为1表示硬盘控制器已准备好数据传输,第7位为1表示硬盘忙   cmp al,0x08   jnz .not_ready       ;若未准备好,继续等。;第5步：从0x1f0端口读数据   mov ax, di       ;以下从硬盘端口读数据用insw指令更快捷,不过尽可能多的演示命令使用,      ;在此先用这种方法,在后面内容会用到insw和outsw等   mov dx, 256       ;di为要读取的扇区数,一个扇区有512字节,每次读入一个字,共需di*512/2次,所以di*256   mul dx   mov cx, ax   mov dx, 0x1f0.go_on_read:   in ax,dx   mov [ebx], ax   add ebx, 2     ; 由于在实模式下偏移地址为16位,所以用bx只会访问到0~FFFFh的偏移。     ; loader的栈指针为0x900,bx为指向的数据输出缓冲区,且为16位，     ; 超过0xffff后,bx部分会从0开始,所以当要读取的扇区数过大,待写入的地址超过bx的范围时，     ; 从硬盘上读出的数据会把0x0000~0xffff的覆盖，     ; 造成栈被破坏,所以ret返回时,返回地址被破坏了,已经不是之前正确的地址,     ; 故程序出会错,不知道会跑到哪里去。     ; 所以改为ebx代替bx指向缓冲区,这样生成的机器码前面会有0x66和0x67来反转。     ; 0X66用于反转默认的操作数大小! 0X67用于反转默认的寻址方式.     ; cpu处于16位模式时,会理所当然的认为操作数和寻址都是16位,处于32位模式时,     ; 也会认为要执行的指令是32位.     ; 当我们在其中任意模式下用了另外模式的寻址方式或操作数大小(姑且认为16位模式用16位字节操作数，     ; 32位模式下用32字节的操作数)时,编译器会在指令前帮我们加上0x66或0x67，     ; 临时改变当前cpu模式到另外的模式下.     ; 假设当前运行在16位模式,遇到0X66时,操作数大小变为32位.     ; 假设当前运行在32位模式,遇到0X66时,操作数大小变为16位.     ; 假设当前运行在16位模式,遇到0X67时,寻址方式变为32位寻址     ; 假设当前运行在32位模式,遇到0X67时,寻址方式变为16位寻址.   loop .go_on_read   ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面内存拷贝函数模拟了 <code>memcpy</code> 函数，对应的栈如下图所示：</p><p> <img src="stack.png" alt="stack.png"></p><h2 id="特权级深入浅出"><a href="#特权级深入浅出" class="headerlink" title="特权级深入浅出"></a>特权级深入浅出</h2><p>保护模式的保护主要提现在特权级上，操作系统作为各种计算机资源的管理者，各种各样的第三方程序都会运行在它提供的环境中，为了保证系统的可持续、安全的运行，就要防止恶意程序破坏系统资源。CPU 在这方面为我们从硬件上提供了支持，程序拥有的权限被分成0、1、2、3级，0级最大，3级最小类似一个特权级环：</p><p> <img src="ring.png" alt="ring.png"></p><h3 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h3><p><code>TSS</code> 是为了在 CPU 内部为了支持多任务的实现方式，如下图示：</p><p> <img src="tss.png" alt="tss.png"></p><p> 可以看到 <code>TSS</code> 有 3 个栈 ss0、esp0、ss1、esp1、ss2、esp2 ，这些栈就是为了任务切换时使用，可以想象，在发送任务切换时，CPU 有可能从低特权级跑到高特权级执行，总不能使用同一个栈吧？所以，不同特权级使用的栈是不一样的。<br> 特权级转移分为两类，一类是由中断门、调用门等使低特权级转向高特权级，另一类则由调用返回指令从高特权级转向低特权级。</p><h3 id="CPL-和-DPL"><a href="#CPL-和-DPL" class="headerlink" title="CPL 和 DPL"></a>CPL 和 DPL</h3><p>对于 CPU 来说任何访问无外乎<code>数据</code>和<code>指令</code>，而在 <code>x86</code> 架构中内存访问是基于<code>段</code>的，所以位于选择子中的<code>RPL</code> 以及描述符中的<code>DPL</code>就至关重要了。<code>CPL</code>即转移后的<code>DPL</code>，<code>CPL</code>代表当前的特权级，而<code>DPL</code>代表受访者的特权级。</p><ul><li>对于受访者为数据段（代码段描述符type字段未有X执行属性），则只有访问者权限大于受访者 DPL，才能访问。</li><li>对于受访者为代码段，则只有访问者权限等于受访者DPL才能访问，即平级访问。你可能想为什么不能降级访问？试想如果能降级访问，CPU在高权限级别时，可能被低权限级别代码引导执行恶意代码。</li><li>低权限级别难道不能提升权限吗？通过一致性代码，可以从低权限级别暂时提升至高权限，即满足数值上，CPL&gt;=一致性代码段的DPL，不过转移后特权级保持不变，所以这种权限提升本质上只是跑到特权级更高的代码段执行指令。常用与数学库的调用。</li></ul><h3 id="门、调用门和RPL"><a href="#门、调用门和RPL" class="headerlink" title="门、调用门和RPL"></a>门、调用门和RPL</h3><p>由于常用的系统调用如磁盘读写、网络服务等都在高特权级，用户代码要使用这些功能该怎么办？答案是通过门结构：</p><p> <img src="call.png" alt="call.png"></p><p>从上面可以看出，门描述符有三个东西值得注意：</p><ul><li>选择子，这里选择子选择的是GDT、LDT和IDT里面内容。</li><li>偏移量，通过选择子确定了段描述符后，还要偏移量才能确定最终的程序地址</li><li>DPL，门描述符里面也有DPL，而选择子对应的 GDT 段描述符也有 DPL。</li></ul><p>门的作用就是让低权限能够转移到高权限，不过访问者权限至少得大于门的DPL，所以满足的条件是：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">DPL_GATE&gt;=CPL&gt;=DPL_CODE （即访问者 CPL权限至少大于等于门DPL，CPL权限小于目标代码段DPL）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过门实现了“蹦床”的功能：</p><p><img src="bance.png" alt="bance.png"></p><p>门的调用过程如下：</p><p><img src="call1.png" alt="call1.png"></p><h3 id="调用门的过程保护"><a href="#调用门的过程保护" class="headerlink" title="调用门的过程保护"></a>调用门的过程保护</h3><p>门调用涉及两个特权级，所以CPU 可能需要不同的栈，刚刚讲了混用同一个栈，会带来混乱。<br>在门调用过程中，除了特权级的检测外，如果涉及到低特权级向高特权级转移，除了将<code>CS</code>和<code>EIP</code>入栈，还需要将 <code>SS</code>和<code>ESP</code>入栈。如下图示：</p><p><img src="stacksw.png" alt="stacksw.png"></p><p>当处理器执行<code>retf</code>指令返回时，需要回复<code>CS</code>和<code>EIP</code>，以及<code>SS</code>和<code>ESP</code>，同样也要进行特权级检测。</p><p><strong>注意：如果返回时需要改变特权级，将检测<code>DS</code>、<code>ES</code>、<code>FS</code>、<code>GS</code>内容，如果某个寄存器选择子指向的数据段描述符的DPL权限比返回后的CPL（CS.RPL）高，则处理器将 0 填充到相应的段寄存器。</strong></p><p>因为段寄存器填充 0 会触发异常，这样就可以避免恶意操作。</p><h3 id="RPL"><a href="#RPL" class="headerlink" title="RPL"></a>RPL</h3><p>其实特权级最容易混淆的地方就在于 <code>RPL</code>，网上很多文章都没有解释清楚，通过例子就很容易说明白。假设系统调用 <code>syswrite</code>，其定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">syswrite(LBA,selector,offset);将LBA地址的内容写入到选择子位selector，偏移量为offset的内存位置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果仅仅靠刚刚说的公式：<code>DPL_GATE&gt;=CPL&gt;=DPL_CODE</code> ，显然是满足的，当CPU从用户空间陷入内核后，其CPL变成 0 ，现在任意代码和内存位置CPU都是可以执行和访问的，假设恶意用户把<code>selector</code> 和<code>offset</code> 设置到内核区，那么该系统调用将会破坏系统内核！！这种现象叫做<a href="https://stackoverflow.com/questions/36617718/difference-between-dpl-and-rpl-in-x86" title="权限扩大">privilege escalation vulnerability</a>过程如下：</p><p><img src="rpl.png" alt="rpl.png"></p><p>问题出在哪儿呢？其实很简单，我们需要标识谁才是真正的请求者，即<code>RPL</code>。<code>RPL</code> 可能是真正运行的程序，也可能不是，比如上面的系统调用，<code>RPL</code> 是用户程序。这样一来，在作特权级检测时就需要考虑 <code>RPL</code>了。</p><h4 id="对数据段的访问"><a href="#对数据段的访问" class="headerlink" title="对数据段的访问"></a>对数据段的访问</h4><p>对数据段（DS, ES, FS, GS, SS）的访问要作如下检测：</p><ul><li>The CPL (current privilege level).</li><li>The RPL (requestor’s privilege level) of the selector used to specify the target segment.</li><li>The DPL of the descriptor of the target segment.</li></ul><p>数值上，CPL&lt;=DPL&amp;&amp;RPL&lt;=DPL</p><p><img src="data.png" alt="data.png"></p><h4 id="对代码段的访问"><a href="#对代码段的访问" class="headerlink" title="对代码段的访问"></a>对代码段的访问</h4><ul><li>Load a data-segment register with a selector of a nonconforming, readable, executable segment.</li><li>Load a data-segment register with a selector of a conforming, readable, executable segment.</li><li>Use a CS override prefix to read a readable, executable segment whose selector is already loaded in the CS register.</li></ul><p>The same rules as for access to data segments apply to case 1. Case 2 is always valid because the privilege level of a segment whose conforming bit is set is effectively the same as CPL regardless of its DPL. Case 3 always valid because the DPL of the code segment in CS is, by definition, equal to CPL.</p><p>涉及到代码段转移的只有 JMP, CALL, RET, INT, and IRET指令，针对没有使用门结构的情况会检测如下项：</p><ul><li>The CPL (current privilege level).</li><li>The DPL of the descriptor of the target segment.</li></ul><p>JMP 或 CALL 必须满足如下条件，注意（在非一致性代码下，JMP只能平级转移）：<br>DPL of the target is equal to CPL.<br>The conforming bit of the target code-segment descriptor is set, and the DPL of the target is less than or equal to CPL.</p><p><img src="data.png" alt="data.png"></p><p>如果涉及到门调用情况下，权限验证会涉及一下项目：</p><ul><li>The CPL (current privilege level).</li><li>The RPL (requestor’s privilege level) of the selector used to specify the call gate.</li><li>The DPL of the gate descriptor.</li><li>The DPL of the descriptor of the target executable segment.</li></ul><p>For a JMP instruction to a nonconforming segment, both of the following privilege rules must be satisfied; otherwise, a general protection exception results.</p><ul><li>MAX (CPL,RPL) &lt;= gate DPL</li><li>target segment DPL = CPL</li></ul><p>For a CALL instruction (or for a JMP instruction to a conforming segment), both of the following privilege rules must be satisfied; otherwise, a general protection exception results.</p><ul><li>MAX (CPL,RPL) &lt;= gate DPL</li><li>target segment DPL &lt;= CPL</li></ul><p><img src="gate.png" alt="gate.png"></p><p><img src="gate1.png" alt="gate1.png"></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>RPL 是历史遗留产物，以前内存访问需要通过多个段切换，而现在都是平坦模型，操作系统会定义一个代码段和内存段给所有程序共享使用。</li><li>RPL 不是必须的，其实当我们系统调用时，操作系统能够通过入栈的 CS 找到对应的特权级，进而进行特权级检测，不过通过RPL更加优雅，对应系统调用中的 RPL 会被强制设置为CPL对应的权限，CPU 提供了专门的指令修改 RPL，用户即使设置高权限的 RPL 也不能欺骗系统。</li><li>现在操作系统都是通过页表访问，所以特权级检查也会在页上进行。</li><li>CPU 的某些指令也是分特权级的，比如停机指令只能在最高特权级执行。</li></ul><h3 id="IO特权级"><a href="#IO特权级" class="headerlink" title="IO特权级"></a>IO特权级</h3><p>保护模式下，处理器的特权级不仅体现在数据和代码访问，还体现在指令以及IO访问中。寄存器的 IOPL 位就是IO特权级，每个任务都有 eflags ，只要数值上CPL&lt;=IOPL ，就可以访问所有 IO 端口，注意是所有端口。那么如果想控制部分端口开放情况咋办呢？毕竟不能所有检查都通过 CPU ，这就有了 IO 图。</p><p><img src="io.png" alt="io.png"></p><p>Intel处理器最大支持 65536 个端口，通过 <code>TSS</code>的 <code>IO图</code>可以控制部分端口打开情况，为什么图中左上角为 <code>oxFF</code>呢？原因有二：</p><ul><li>第一，处理器允许IO图不映射所有端口，即 IO图长度不足 8KB，最后一个字节为 <code>0xFF</code> 刚好可以充当边界的作用。</li><li>第二，由于从一个端口读多个字节，实际上是同时读了连续的多个端口，所以 <code>0xFF</code> 可以避免越界访问。<hr></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统设计与实现-保护模式进阶</title>
      <link href="/2018/11/12/cao-zuo-xi-tong-she-ji-yu-shi-xian-bao-hu-mo-shi-jin-jie/"/>
      <url>/2018/11/12/cao-zuo-xi-tong-she-ji-yu-shi-xian-bao-hu-mo-shi-jin-jie/</url>
      
        <content type="html"><![CDATA[<p>本节将接受保护模式下的内存管理和处理器特权级内容。</p><a id="more"></a><h2 id="获取物理内存容量"><a href="#获取物理内存容量" class="headerlink" title="获取物理内存容量"></a>获取物理内存容量</h2><p>为了获取物理内存容量，可以使用 <code>BIOS</code> 提供的 0x15 号3个子功能：</p><ul><li>EAX=0xE820：遍历主机上全部内存</li><li>AX=0xE801：分别检测低 15MB和 16MB~4GB的内存，最大支持 4GB</li><li>AH=0x88：最多检测 64MB 内存</li></ul><p>具体的读取方法只要按照相应的规则即可，这里不再赘述，其实这种死知识不用记忆，需要时查手册便可。</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">;主引导程序;------------------------------------------------------------%include "boot.inc"SECTION MBR vstart=0x7c00   mov ax,cs   mov ds,ax   mov es,ax   mov ss,ax   mov fs,ax   mov sp,0x7c00   mov ax,0xb800   mov gs,ax; 清屏;利用0x06号功能，上卷全部行，则可清屏。; -----------------------------------------------------------;INT 0x10   功能号:0x06       功能描述:上卷窗口;------------------------------------------------------;输入：;AH 功能号= 0x06;AL = 上卷的行数(如果为0,表示全部);BH = 上卷行属性;(CL,CH) = 窗口左上角的(X,Y)位置;(DL,DH) = 窗口右下角的(X,Y)位置;无返回值：   mov     ax, 0600h   mov     bx, 0700h   mov     cx, 0                   ; 左上角: (0, 0)   mov     dx, 184fh           ; 右下角: (80,25),                   ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。                   ; 下标从0开始，所以0x18=24,0x4f=79   int     10h                     ; int 10h   ; 输出字符串:MBR   mov byte [gs:0x00],'1'   mov byte [gs:0x01],0xA4   mov byte [gs:0x02],' '   mov byte [gs:0x03],0xA4   mov byte [gs:0x04],'M'   mov byte [gs:0x05],0xA4       ;A表示绿色背景闪烁，4表示前景色为红色   mov byte [gs:0x06],'B'   mov byte [gs:0x07],0xA4   mov byte [gs:0x08],'R'   mov byte [gs:0x09],0xA4   mov eax,LOADER_START_SECTOR     ; 起始扇区lba地址   mov bx,LOADER_BASE_ADDR       ; 写入的地址   mov cx,4             ; 待读入的扇区数   call rd_disk_m_16         ; 以下读取程序的起始部分（一个扇区）   jmp LOADER_BASE_ADDR + 0x300;-------------------------------------------------------------------------------;功能:读取硬盘n个扇区rd_disk_m_16:;-------------------------------------------------------------------------------                       ; eax=LBA扇区号                       ; ebx=将数据写入的内存地址                       ; ecx=读入的扇区数      mov esi,eax      ;备份eax      mov di,cx          ;备份cx;读写硬盘:;第1步：设置要读取的扇区数      mov dx,0x1f2      mov al,cl      out dx,al            ;读取的扇区数      mov eax,esi       ;恢复ax;第2步：将LBA地址存入0x1f3 ~ 0x1f6      ;LBA地址7~0位写入端口0x1f3      mov dx,0x1f3      out dx,al      ;LBA地址15~8位写入端口0x1f4      mov cl,8      shr eax,cl      mov dx,0x1f4      out dx,al      ;LBA地址23~16位写入端口0x1f5      shr eax,cl      mov dx,0x1f5      out dx,al      shr eax,cl      and al,0x0f       ;lba第24~27位      or al,0xe0       ; 设置7～4位为1110,表示lba模式      mov dx,0x1f6      out dx,al;第3步：向0x1f7端口写入读命令，0x20      mov dx,0x1f7      mov al,0x20      out dx,al;第4步：检测硬盘状态  .not_ready:      ;同一端口，写时表示写入命令字，读时表示读入硬盘状态      nop      in al,dx      and al,0x88       ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙      cmp al,0x08      jnz .not_ready       ;若未准备好，继续等。;第5步：从0x1f0端口读数据      mov ax, di      mov dx, 256      mul dx      mov cx, ax       ; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，               ; 共需di*512/2次，所以di*256      mov dx, 0x1f0  .go_on_read:      in ax,dx      mov [bx],ax      add bx,2      loop .go_on_read      ret   times 510-($-$$) db 0   db 0x55,0xaa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">%include "boot.inc"section loader vstart=LOADER_BASE_ADDRLOADER_STACK_TOP equ LOADER_BASE_ADDR;构建gdt及其内部的描述符GDT_BASE:   dd    0x00000000      dd    0x00000000CODE_DESC:  dd    0x0000FFFF      dd    DESC_CODE_HIGH4DATA_STACK_DESC:  dd    0x0000FFFF      dd    DESC_DATA_HIGH4VIDEO_DESC: dd    0x80000007           ; limit=(0xbffff-0xb8000)/4k=0x7      dd    DESC_VIDEO_HIGH4  ; 此时dpl为0GDT_SIZE   equ   $ - GDT_BASEGDT_LIMIT   equ   GDT_SIZE -    1times 60 dq 0                     ; 此处预留60个描述符的空位(slot)SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0     ; 同上SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0     ; 同上; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址total_mem_bytes dd 0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址gdt_ptr  dw  GDT_LIMIT   dd  GDT_BASE;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节ards_buf times 244 db 0ards_nr dw 0              ;用于记录ards结构体数量loader_start:;-------  int 15h eax = 0000E820h ,edx = 534D4150h ('SMAP') 获取内存布局  -------xor ebx, ebx              ;第一次调用时，ebx值要为0mov edx, 0x534d4150          ;edx只赋值一次，循环体中不会改变mov di, ards_buf          ;ards结构缓冲区.e820_mem_get_loop:          ;循环获取每个ARDS内存范围描述结构mov eax, 0x0000e820          ;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。mov ecx, 20              ;ARDS地址范围描述符结构大小是20字节int 0x15jc .e820_failed_so_try_e801   ;若cf位为1则有错误发生，尝试0xe801子功能add di, cx              ;使di增加20字节指向缓冲区中新的ARDS结构位置inc word [ards_nr]          ;记录ARDS数量cmp ebx, 0              ;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个jnz .e820_mem_get_loop;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。mov cx, [ards_nr]          ;遍历每一个ARDS结构体,循环次数是ARDS的数量mov ebx, ards_bufxor edx, edx              ;edx为最大的内存容量,在此先清0.find_max_mem_area:          ;无须判断type是否为1,最大的内存块一定是可被使用mov eax, [ebx]          ;base_add_lowadd eax, [ebx+8]          ;length_lowadd ebx, 20              ;指向缓冲区中下一个ARDS结构cmp edx, eax              ;冒泡排序，找出最大,edx寄存器始终是最大的内存容量jge .next_ardsmov edx, eax              ;edx为总内存大小.next_ards:loop .find_max_mem_areajmp .mem_get_ok;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。.e820_failed_so_try_e801:mov ax,0xe801int 0x15jc .e801_failed_so_try88   ;若当前e801方法失败,就尝试0x88方法;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位mov cx,0x400         ;cx和ax值一样,cx用做乘数mul cxshl edx,16and eax,0x0000FFFFor edx,eaxadd edx, 0x100000 ;ax只是15MB,故要加1MBmov esi,edx         ;先把低15MB的内存容量存入esi寄存器备份;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量xor eax,eaxmov ax,bxmov ecx, 0x10000    ;0x10000十进制为64KBmul ecx        ;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.add esi,eax        ;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可mov edx,esi        ;edx为总内存大小jmp .mem_get_ok;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------.e801_failed_so_try88:;int 15后，ax存入的是以kb为单位的内存容量mov  ah, 0x88int  0x15jc .error_hltand eax,0x0000FFFF;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位mul cxshl edx, 16         ;把dx移到高16位or edx, eax         ;把积的低16位组合到edx,为32位的积add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB.mem_get_ok:mov [total_mem_bytes], edx     ;将内存换为byte单位后存入total_mem_bytes处。;-----------------   准备进入保护模式   -------------------;1 打开A20;2 加载gdt;3 将cr0的pe位置1;-----------------  打开A20  ----------------in al,0x92or al,0000_0010Bout 0x92,al;-----------------  加载GDT  ----------------lgdt [gdt_ptr];-----------------  cr0第0位置1  ----------------mov eax, cr0or eax, 0x00000001mov cr0, eaxjmp dword SELECTOR_CODE:p_mode_start         ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，            ; 这将导致之前做的预测失效，从而起到了刷新的作用。.error_hlt:              ;出错则挂起hlt[bits 32]p_mode_start:mov ax, SELECTOR_DATAmov ds, axmov es, axmov ss, axmov esp,LOADER_STACK_TOPmov ax, SELECTOR_VIDEOmov gs, axmov byte [gs:160], 'P'jmp $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译并加载 <code>mbr</code> 和 <code>loader</code>：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">nasm -I include/ -o mbr.bin mbr.Ssudo dd if=mbr.bin of=/usr/local/bin/hd60M.img bs=512 count=1 conv=notruncnasm -I include/ -o loader.bin loader.Ssudo dd if=loader.bin of=/usr/local/bin/hd60M.img bs=512 count=4 seek=2 conv=notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>查看 <code>0xb00</code> 处内存为：</p><p><img src="mem.png" alt="mem.png"></p><h2 id="启用内存分页"><a href="#启用内存分页" class="headerlink" title="启用内存分页"></a>启用内存分页</h2><h3 id="内存为什么要分页"><a href="#内存为什么要分页" class="headerlink" title="内存为什么要分页"></a>内存为什么要分页</h3><p>现假设有如下进程使用情况，当进程 D 需要运行时，虽然总内存足够，但是并不连续：</p><p><img src="process.png" alt="process.png"></p><p>容易想到两种简单的办法，一是等待 C 进程执行完，不过明明有足够内存，却不能执行进程，显然此办法不够好，另一种是将进程 C 换出，写入磁盘，不过换出过程十分消耗 CPU ，效率太低。<br>其实上述问题的根本是进程的地址是连续的，而多次运行后，剩余的内存并不连续，所以解决办法是<strong>将内存划分成更小的部分，同时增加中间层，让程序的地址不再直接映射为物理地址，从而提高灵活性</strong>。<br>上面我们再次体会到了增加中间层的威力。</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决<br>Any problem  in computer science can be solved by anther layer of indirection.</p></blockquote><h3 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h3><p><img src="process.png" alt="process.png"></p><p><img src="page.png" alt="page.png"></p><p>分页后有以下两个作用：</p><ul><li>线性地址转换成物理地址</li><li>用大小相等的页代替大小不等的段</li></ul><p>那我们该怎么讲虚拟地址和物理地址映射呢？最简单的方式是一一映射，不过光存映射项就要大量的内存，此方案肯定行不通；32 位地址可以将其拆分成高地址和低地址，高地址代表内存块数量，低地址代表每个内存块大小，为了寻找合适的映射尺寸，就是将下图所示的游标左右滑动到合适的位置：</p><p><img src="map.png" alt="map.png"></p><h3 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h3><p>一级页表中页表的大小为 1MB，但是每个进程都有自己的页表，如果有大量进程，势必会耗费大量内存，所以再加一层中间层，即二级页表便可解决内存消耗问题。不过合适的尺寸是多少呢？其实就是将高 20 位地址再次拆分，尝试后发现对半分比较好，因为 1K 个项乘以 4字节刚好是一个页表的大小，所以页目录和页表都刚好可以放在一个页表中，太棒了。</p><p><img src="twolvlpage.png" alt="twolvlpage.png"></p><p>当然层级越多，转换过程越复杂，不过只要一层层的翻译还是很容易的，比如 <code>mov ax,[0x1234567]</code> ：</p><p><img src="transform.png" alt="transform.png"></p><p>由于页目录项和页表项低 12位并没有用，因为页表以 4K为单位，所以其低 12位可以存其他的控制信息：</p><p><img src="pte.png" alt="pte.png"></p><p>启用分页的步骤：</p><ul><li>准备好页目录和页表</li><li>将页表地址写入控制寄存器 cr3</li><li>寄存器 cr0 的PG位置 1</li></ul><p>分页后页目录表和页表的关系：</p><p><img src="p.png" alt="p.png"></p><p>以下为我们设计的内存布局图：</p><p><img src="mem1.png" alt="mem1.png"></p><p>代码如下：</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">%include "boot.inc"section loader vstart=LOADER_BASE_ADDRLOADER_STACK_TOP equ LOADER_BASE_ADDR;构建gdt及其内部的描述符GDT_BASE:   dd    0x00000000      dd    0x00000000CODE_DESC:  dd    0x0000FFFF      dd    DESC_CODE_HIGH4DATA_STACK_DESC:  dd    0x0000FFFF      dd    DESC_DATA_HIGH4VIDEO_DESC: dd    0x80000007           ; limit=(0xbffff-0xb8000)/4k=0x7      dd    DESC_VIDEO_HIGH4  ; 此时dpl为0GDT_SIZE   equ   $ - GDT_BASEGDT_LIMIT   equ   GDT_SIZE -    1times 60 dq 0                     ; 此处预留60个描述符的空位(slot)SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0     ; 同上SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0     ; 同上; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址total_mem_bytes dd 0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址gdt_ptr  dw  GDT_LIMIT   dd  GDT_BASE;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节ards_buf times 244 db 0ards_nr dw 0              ;用于记录ards结构体数量loader_start:;-------  int 15h eax = 0000E820h ,edx = 534D4150h ('SMAP') 获取内存布局  -------xor ebx, ebx              ;第一次调用时，ebx值要为0mov edx, 0x534d4150          ;edx只赋值一次，循环体中不会改变mov di, ards_buf          ;ards结构缓冲区.e820_mem_get_loop:          ;循环获取每个ARDS内存范围描述结构mov eax, 0x0000e820          ;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。mov ecx, 20              ;ARDS地址范围描述符结构大小是20字节int 0x15jc .e820_failed_so_try_e801   ;若cf位为1则有错误发生，尝试0xe801子功能add di, cx              ;使di增加20字节指向缓冲区中新的ARDS结构位置inc word [ards_nr]          ;记录ARDS数量cmp ebx, 0              ;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个jnz .e820_mem_get_loop;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。mov cx, [ards_nr]          ;遍历每一个ARDS结构体,循环次数是ARDS的数量mov ebx, ards_bufxor edx, edx              ;edx为最大的内存容量,在此先清0.find_max_mem_area:          ;无须判断type是否为1,最大的内存块一定是可被使用mov eax, [ebx]          ;base_add_lowadd eax, [ebx+8]          ;length_lowadd ebx, 20              ;指向缓冲区中下一个ARDS结构cmp edx, eax              ;冒泡排序，找出最大,edx寄存器始终是最大的内存容量jge .next_ardsmov edx, eax              ;edx为总内存大小.next_ards:loop .find_max_mem_areajmp .mem_get_ok;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。.e820_failed_so_try_e801:mov ax,0xe801int 0x15jc .e801_failed_so_try88   ;若当前e801方法失败,就尝试0x88方法;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位mov cx,0x400         ;cx和ax值一样,cx用做乘数mul cxshl edx,16and eax,0x0000FFFFor edx,eaxadd edx, 0x100000 ;ax只是15MB,故要加1MBmov esi,edx         ;先把低15MB的内存容量存入esi寄存器备份;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量xor eax,eaxmov ax,bxmov ecx, 0x10000    ;0x10000十进制为64KBmul ecx        ;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.add esi,eax        ;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可mov edx,esi        ;edx为总内存大小jmp .mem_get_ok;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------.e801_failed_so_try88:;int 15后，ax存入的是以kb为单位的内存容量mov  ah, 0x88int  0x15jc .error_hltand eax,0x0000FFFF;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位mul cxshl edx, 16         ;把dx移到高16位or edx, eax         ;把积的低16位组合到edx,为32位的积add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB.mem_get_ok:mov [total_mem_bytes], edx     ;将内存换为byte单位后存入total_mem_bytes处。;-----------------   准备进入保护模式   -------------------;1 打开A20;2 加载gdt;3 将cr0的pe位置1;-----------------  打开A20  ----------------in al,0x92or al,0000_0010Bout 0x92,al;-----------------  加载GDT  ----------------lgdt [gdt_ptr];-----------------  cr0第0位置1  ----------------mov eax, cr0or eax, 0x00000001mov cr0, eaxjmp dword SELECTOR_CODE:p_mode_start         ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，            ; 这将导致之前做的预测失效，从而起到了刷新的作用。.error_hlt:              ;出错则挂起hlt[bits 32]p_mode_start:mov ax, SELECTOR_DATAmov ds, axmov es, axmov ss, axmov esp,LOADER_STACK_TOPmov ax, SELECTOR_VIDEOmov gs, ax; 创建页目录及页表并初始化页内存位图call setup_page;要将描述符表地址及偏移量写入内存gdt_ptr,一会用新地址重新加载sgdt [gdt_ptr]          ; 存储到原来gdt所有的位置;将gdt描述符中视频段描述符中的段基址+0xc0000000mov ebx, [gdt_ptr + 2]or dword [ebx + 0x18 + 4], 0xc0000000      ;视频段是第3个段描述符,每个描述符是8字节,故0x18。             ;段描述符的高4字节的最高位是段基址的31~24位;将gdt的基址加上0xc0000000使其成为内核所在的高地址add dword [gdt_ptr + 2], 0xc0000000add esp, 0xc0000000        ; 将栈指针同样映射到内核地址; 把页目录地址赋给cr3mov eax, PAGE_DIR_TABLE_POSmov cr3, eax; 打开cr0的pg位(第31位)mov eax, cr0or eax, 0x80000000mov cr0, eax;在开启分页后,用gdt新的地址重新加载lgdt [gdt_ptr]             ; 重新加载mov byte [gs:160], 'V'     ;视频段段基址已经被更新,用字符v表示virtual addrjmp $;-------------   创建页目录及页表   ---------------setup_page:;先把页目录占用的空间逐字节清0mov ecx, 4096mov esi, 0.clear_page_dir:mov byte [PAGE_DIR_TABLE_POS + esi], 0inc esiloop .clear_page_dir;开始创建页目录项(PDE).create_pde:                     ; 创建Page Directory Entrymov eax, PAGE_DIR_TABLE_POSadd eax, 0x1000                  ; 此时eax为第一个页表的位置及属性mov ebx, eax                     ; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。;   下面将页目录项0和0xc00都存为第一个页表的地址，;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，;   这是为将地址映射为内核地址做准备or eax, PG_US_U | PG_RW_W | PG_P         ; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.mov [PAGE_DIR_TABLE_POS + 0x0], eax       ; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(7)mov [PAGE_DIR_TABLE_POS + 0xc00], eax     ; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,            ; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.sub eax, 0x1000mov [PAGE_DIR_TABLE_POS + 4092], eax         ; 使最后一个目录项指向页目录表自己的地址;下面创建页表项(PTE)mov ecx, 256                     ; 1M低端内存 / 每页大小4k = 256mov esi, 0mov edx, PG_US_U | PG_RW_W | PG_P         ; 属性为7,US=1,RW=1,P=1.create_pte:                     ; 创建Page Table Entrymov [ebx+esi*4],edx                 ; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址add edx,4096inc esiloop .create_pte;创建内核其它页表的PDEmov eax, PAGE_DIR_TABLE_POSadd eax, 0x2000              ; 此时eax为第二个页表的位置or eax, PG_US_U | PG_RW_W | PG_P  ; 页目录项的属性US,RW和P位都为1mov ebx, PAGE_DIR_TABLE_POSmov ecx, 254                 ; 范围为第769~1022的所有目录项数量mov esi, 769.create_kernel_pde:mov [ebx+esi*4], eaxinc esiadd eax, 0x1000loop .create_kernel_pderet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译运行后查看虚拟地址映射情况：</p><p><img src="tab.png" alt="tab.png"></p><p>注意最后三个映射，由于第 1023 个页目录项地址为 0x100000 即第一个页目录项，所以页目录会被当成页表访问，如下图所示：</p><p><img src="tabmap.png" alt="tabmap.png"></p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统设计与实现-保护模式</title>
      <link href="/2018/11/11/cao-zuo-xi-tong-she-ji-yu-shi-xian-bao-hu-mo-shi/"/>
      <url>/2018/11/11/cao-zuo-xi-tong-she-ji-yu-shi-xian-bao-hu-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>前面介绍的实模式最大的问题便是安全性，以及内存太小，任何程序都可以操作任意内存是十分危险的，本节介绍保护模式相关内容。</p><a id="more"></a><h2 id="保护模式概述"><a href="#保护模式概述" class="headerlink" title="保护模式概述"></a>保护模式概述</h2><p>实模式缺点：</p><ul><li>操作系统与用户程序属于同一级别，安全性差</li><li>程序引用的都是物理地址，灵活性差</li><li>访问超过 64KB 需要切换段基址</li><li>内存只有 1MB 太小</li></ul><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><p>CPU 在32位下，寄存器也会相应的扩展，如下图所示：</p><p><img src="reg.png" alt="reg.png"></p><p>CPU 为了兼容历史产品，分段也会被延续，不过为了“保护”内存访问，必然会对内存段设置访问权限，描述内存访问限制的信息有一个专门的数据结构存储，即全局描述符GDT，可以简单理解为一个数组，每个数组元素就是一个内存段的描述信息。</p><h3 id="保护模式下寻址扩展"><a href="#保护模式下寻址扩展" class="headerlink" title="保护模式下寻址扩展"></a>保护模式下寻址扩展</h3><p>实模式下寻址方式：</p><ul><li>mov ax,[si]</li><li>mov ax,[di]</li><li>mov ax,[bx]</li><li>mov ax,[bx+si]</li><li>mov ax,[bx+si+0x1234]</li><li>mov ax,[bx+di]</li><li>mov ax,[bx+di+0x1234]</li></ul><p>实模式下哪些寄存器可以作为源寄存器和目标寄存器，以及与段寄存器之间的搭配都是有严格的规定的，然而在32位模式下就更加宽松了，如下图所示：</p><p><img src="location.png" alt="location.png"></p><h3 id="保护模式之运行模式反转"><a href="#保护模式之运行模式反转" class="headerlink" title="保护模式之运行模式反转"></a>保护模式之运行模式反转</h3><p>由于CPU 现在支持 16 位模式和 32 位模式，而两种模式下机器码、操作数、寻址方式都是都是不同的，所以需要明确给编译器指明。</p><h4 id="bits"><a href="#bits" class="headerlink" title="bits"></a>bits</h4><p>[bits 16] 告诉编译器下面的代码编译成16位机器码。<br>[bits 32] 告诉编译器下面的代码编译成32位机器码</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">[bits 16]mov ax,0x1234mov dx,0x1234[bits 32]mov eax,0x1234mov edx,0x1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="bits.png" alt="bits.png"></p><h4 id="操作数反转前缀-0x66"><a href="#操作数反转前缀-0x66" class="headerlink" title="操作数反转前缀 0x66"></a>操作数反转前缀 0x66</h4><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">[bits 16]mov ax,0x1234mov eax,0x1234[bits 32]mov ax,0x1234mov eax,0x1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="opt.png" alt="opt.png"></p><h4 id="寻址方式反转前缀-0x67"><a href="#寻址方式反转前缀-0x67" class="headerlink" title="寻址方式反转前缀 0x67"></a>寻址方式反转前缀 0x67</h4><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">[bits 16]mov word [bx],0x1234mov word [eax],0x1234mov dword [eax],0x1234[bits 32]mov dword [eax],0x1234mov word [eax],0x1234mov dword [bx],0x1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="opt1.png" alt="opt1.png"></p><h3 id="保护模式指令扩展"><a href="#保护模式指令扩展" class="headerlink" title="保护模式指令扩展"></a>保护模式指令扩展</h3><p>在32 位保护模式下，对应的指令也会进行相应的扩展，比如 <code>mul</code> 、<code>push</code> 等指令。</p><h2 id="全局描述符"><a href="#全局描述符" class="headerlink" title="全局描述符"></a>全局描述符</h2><h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p>从刚刚提到的，段描述符无外乎描述了内存段的开始地址、大小（界限）、访问限制等，具体都有哪些字段呢，如下图所示：</p><p><img src="sdt.png" alt="sdt.png"></p><ul><li>段基址：该段起始地址</li><li>段界限：该段的大小，单位有G决定</li><li>G：单位，G=0 byte ，G=1 4kb</li><li>D/B：对代码段 D=0 代表指令中的有效地址和操作数为16位，D=1 为32位；对栈段，B=0 sp 为16位，B=1 sp 为32位</li><li>L：L=1 代表64位代码段</li><li>AVL:未明确使用</li><li>P：段是否在内存中，P=0 会调用异常处理程序加载相应页</li><li>DPL：特权级别，0 为系统级，3为用户级别</li><li>S：S=0 表示系统段，S=1 表示数据段，配合 type字段</li><li>TYPE：描述系统段和非系统段信息，非系统段的代码段和数据段的可执行、可读写、一致性代码等特性</li></ul><h3 id="GDT、LDT-和选择子"><a href="#GDT、LDT-和选择子" class="headerlink" title="GDT、LDT 和选择子"></a>GDT、LDT 和选择子</h3><p>上面的段描述符已经设置好了，总得让 <code>CPU</code> 识别才行，<code>GDTR</code> 寄存器负责索引<code>GDT</code>描述符，GDTR 寄存器内容如下：</p><p><img src="gdtr.png" alt="gdtr.png"></p><p>其中低16位为选择子，段寄存器在保护模式下存入的是选择子，选择子包含 13 位的索引，2 位 <code>RPL</code> ，即请求特权级，1 位 <code>TI(Table Indicator)``， </code>TI<code>=0 代表</code>GDT<code> 中的索引描述符，</code>TI=1<code>代表</code>LDT` 的索引描述符。其功能如下图所示：</p><p><img src="selector.png" alt="selector.png"></p><h3 id="打开-A20-地址线"><a href="#打开-A20-地址线" class="headerlink" title="打开 A20 地址线"></a>打开 A20 地址线</h3><p>在实模式下最大内存为 1MB ，当地址超过 1MB 时高位被舍弃，相当于绕回，为了能够控制CPU 能否访问超过 1MB 内存，IBM 通过键盘控制器的输出线来控制第21根地址（A20）线的有效性，当 A20Gate 被打开时，CPU 就能够访问超过 1MB 的内存地址。</p><h3 id="保护模式的开关，CR0-寄存器的-PE位"><a href="#保护模式的开关，CR0-寄存器的-PE位" class="headerlink" title="保护模式的开关，CR0 寄存器的 PE位"></a>保护模式的开关，CR0 寄存器的 PE位</h3><p>进入保护模式的最后一步是通过控制寄存器<code>CR0</code>，其结构如下：</p><p><img src="cr0.png" alt="cr0.png"></p><p>只要将  <code>PE</code> 位置 1 即可。</p><h3 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h3><p>由于 <code>loader.bin</code> 将超过 512 字节，所以将多加载几个扇区到磁盘，以下是段描述符和选择子低3位的重要配置信息，主要是一些宏定义：</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">;-------------     loader和kernel   ----------LOADER_BASE_ADDR equ 0x900LOADER_START_SECTOR equ 0x2;--------------   gdt描述符属性  -------------DESC_G_4K   equ      1_00000000000000000000000bDESC_D_32   equ       1_0000000000000000000000bDESC_L        equ        0_000000000000000000000b    ;  64位代码标记，此处标记为0便可。DESC_AVL    equ         0_00000000000000000000b    ;  cpu不用此位，暂置为0DESC_LIMIT_CODE2  equ 1111_0000000000000000bDESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2DESC_LIMIT_VIDEO2  equ 0000_000000000000000bDESC_P        equ          1_000000000000000bDESC_DPL_0  equ           00_0000000000000bDESC_DPL_1  equ           01_0000000000000bDESC_DPL_2  equ           10_0000000000000bDESC_DPL_3  equ           11_0000000000000bDESC_S_CODE equ             1_000000000000bDESC_S_DATA equ      DESC_S_CODEDESC_S_sys  equ             0_000000000000bDESC_TYPE_CODE  equ          1000_00000000b    ;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.DESC_TYPE_DATA  equ          0010_00000000b    ;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.DESC_CODE_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00DESC_DATA_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00DESC_VIDEO_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b;--------------   选择子属性  ---------------RPL0  equ   00bRPL1  equ   01bRPL2  equ   10bRPL3  equ   11bTI_GDT     equ   000bTI_LDT     equ   100b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>loader.S</code> 内容如下：</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">%include "boot.inc"section loader vstart=LOADER_BASE_ADDRLOADER_STACK_TOP equ LOADER_BASE_ADDRjmp loader_start                    ; 此处的物理地址是:;构建gdt及其内部的描述符GDT_BASE:   dd    0x00000000      dd    0x00000000CODE_DESC:  dd    0x0000FFFF      dd    DESC_CODE_HIGH4DATA_STACK_DESC:  dd    0x0000FFFF      dd    DESC_DATA_HIGH4VIDEO_DESC: dd    0x80000007           ;limit=(0xbffff-0xb8000)/4k=0x7      dd    DESC_VIDEO_HIGH4  ; 此时dpl已改为0GDT_SIZE   equ   $ - GDT_BASEGDT_LIMIT   equ   GDT_SIZE -    1times 60 dq 0                     ; 此处预留60个描述符的slotSELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0     ; 同上SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0     ; 同上;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址gdt_ptr  dw  GDT_LIMIT   dd  GDT_BASEloadermsg db '2 loader in real.'loader_start:;------------------------------------------------------------;INT 0x10    功能号:0x13    功能描述:打印字符串;------------------------------------------------------------;输入:;AH 子功能号=13H;BH = 页码;BL = 属性(若AL=00H或01H);CX＝字符串长度;(DH、DL)＝坐标(行、列);ES:BP＝字符串地址;AL＝显示输出方式;   0——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置不变;   1——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置改变;   2——字符串中含显示字符和显示属性。显示后，光标位置不变;   3——字符串中含显示字符和显示属性。显示后，光标位置改变;无返回值mov     sp, LOADER_BASE_ADDRmov     bp, loadermsg           ; ES:BP = 字符串地址mov     cx, 17             ; CX = 字符串长度mov     ax, 0x1301         ; AH = 13,  AL = 01hmov     bx, 0x001f         ; 页号为0(BH = 0) 蓝底粉红字(BL = 1fh)mov     dx, 0x1800         ;int     0x10                    ; 10h 号中断;----------------------------------------   准备进入保护模式   ------------------------------------------               ;1 打开A20               ;2 加载gdt               ;3 将cr0的pe位置1;-----------------  打开A20  ----------------in al,0x92or al,0000_0010Bout 0x92,al;-----------------  加载GDT  ----------------lgdt [gdt_ptr];-----------------  cr0第0位置1  ----------------mov eax, cr0or eax, 0x00000001mov cr0, eax;jmp dword SELECTOR_CODE:p_mode_start         ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，jmp  SELECTOR_CODE:p_mode_start         ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，            ; 这将导致之前做的预测失效，从而起到了刷新的作用。[bits 32]p_mode_start:mov ax, SELECTOR_DATAmov ds, axmov es, axmov ss, axmov esp,LOADER_STACK_TOPmov ax, SELECTOR_VIDEOmov gs, axmov byte [gs:160], 'P'jmp $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译并加载  <code>mbr</code> 和 <code>loader</code>：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">nasm -I include/ -o mbr.bin mbr.Ssudo dd if=mbr.bin of=/usr/local/bin/hd60M.img bs=512 count=1 conv=notruncnasm -I include/ -o loader.bin loader.Ssudo dd if=loader.bin of=/usr/local/bin/hd60M.img bs=512 count=4 seek=2 conv=notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="处理器架构间接"><a href="#处理器架构间接" class="headerlink" title="处理器架构间接"></a>处理器架构间接</h2><p>本节简要介绍处理器的几个特点。</p><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p>福特因为采用流水线生产，大大提高了生产效率。在CPU执行指令上，也可以采用类似的技术，通过将指令划分为不同的阶段，不同的指令可能在同一周期同时执行。如下图所示三级流水线：</p><p><img src="cpu1.png" alt="cpu1.png"></p><h3 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h3><p>处理器的指令集分为 CISC 和 RISC 两类，随着双方取长补短，即使像 x86 的复杂指令集也渐渐包含了精简指令集的实现，比如</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">push eax;等价于sub esp ,4mov [esp],eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>那么在执行以下语句：</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">mov eax,[0x1234]push eaxcall function<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等价于：</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">mov eax,[0x1234]sub esp ,4                ;b1mov [esp],eax             ;b2call function             ;c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>b1</code> 执行完时，CPU 就可以执行<code>c</code>指令，将函数返回地址入栈，有可能<code>c</code> 执行完后，<code>b2</code>还没有执行完，这就是所谓的乱序执行。<br>乱序执行的好处就是后面的操作可以放到前面执行，有利于装载到流水线，提高执行效率，不过要注意指令之间是否存在约束和相关性。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>在计算机世界缓存无处不在，CPU也不例外，由程序的局部性原理可知，如果能将当前指令和附近的数据加载到缓存，将大大提高CPU 效率。</p><h3 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h3><p>从上面提到的流水线可知，它能提高指令执行效率，不过遇到分支情况就不妙了。试想当我们已经将后面几条指令加载到流水线，而接着CPU 又跳转到其他位置执行，那么浪费流水线不说，还要保证流水线中其他指令没有执行，否则可能导致 CPU 指令执行结果和程序语义不一致。<br>为了解决分支问题，CPU 有专门的分支预测部件，如果预测失败，CPU 会保证没有错误的指令被执行并清空流水线。</p><h2 id="使用远跳转指令清空流水线，更新段描述符缓存寄存器"><a href="#使用远跳转指令清空流水线，更新段描述符缓存寄存器" class="headerlink" title="使用远跳转指令清空流水线，更新段描述符缓存寄存器"></a>使用远跳转指令清空流水线，更新段描述符缓存寄存器</h2><p>在 <code>loader</code> 中有这么一行代码：</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">jmp dword SELECTOR_CODE:p_mode_start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>段描述符缓冲寄存器在 80286 后一直存在，不管是运行在 16位模式还是 32 位模式，为了能够让 CPU 从 16 位正确的切换到 32 位，必须要重设其值。另一方面，由于流水线的存在，在16 位模式下，CPU 可能已经装载了 32 位模式的指令到流水线中，显然需要清空流水线，否则会造成指令执行错误。综上两个原因，我们需要既能改变段描述符缓冲寄存器，又能清空流水线的指令。<br>通过远调用指令 call、远转移指令 jmp、远返回指令 retf 可以改变代码段寄存器，jmp 指令也可以清空流水线。所以上述代码能够完成这两个目标。</p><h2 id="保护模式之内存段的保护"><a href="#保护模式之内存段的保护" class="headerlink" title="保护模式之内存段的保护"></a>保护模式之内存段的保护</h2><p>接下来介绍保护模式下访问内存段时具体的保护措施。</p><h3 id="加载选择子时的保护"><a href="#加载选择子时的保护" class="headerlink" title="加载选择子时的保护"></a>加载选择子时的保护</h3><p>加载选择子时必须保证索引是在GDT或LDT描述符表有效范围内，如下图示：</p><p><img src="s.png" alt="s.png"></p><p>同时要检查 type 字段，保证只有具有可执行属性的段才能加载到CS，加载到 SS 的段必须具备可写属性，其他段至少具备可读属性。<br>接着还要通过 P 位检查内存段是否存在，不存在调用相应的异常处理程序。</p><h3 id="代码段和数据段保护"><a href="#代码段和数据段保护" class="headerlink" title="代码段和数据段保护"></a>代码段和数据段保护</h3><p>当选择子顺利通过后，还要看指令和数据是否在GDT描述符的有效范围内，即由段基址和段界限确定的有效范围。对于向上扩展的段与向下扩展的段，其实际的界限是不同的。</p><p><img src="extend.png" alt="extend.png"></p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统设计与实现-完善 MBR</title>
      <link href="/2018/11/09/cao-zuo-xi-tong-she-ji-yu-shi-xian-wan-shan-mbr/"/>
      <url>/2018/11/09/cao-zuo-xi-tong-she-ji-yu-shi-xian-wan-shan-mbr/</url>
      
        <content type="html"><![CDATA[<p>本节将讨论地址、vstart以及实模式CPU的相关基本概念。</p><a id="more"></a><h2 id="地址、vstart和section"><a href="#地址、vstart和section" class="headerlink" title="地址、vstart和section"></a>地址、vstart和section</h2><p>让我们对比下有和没有 vstart的区别：</p><p><img src="vstart.png" alt="vstart.png"></p><p>可以看出没加 <code>vstart</code> ，section的默认地址是从 0 开始递增，如果加上了 <code>vstart</code> 后续的地址就会以 <code>vstart</code> 为起始地址递增。</p><p><img src="vstart2.png" alt="vstart2.png"></p><p>由于 BIOS 默认会将 MBR 第一个扇区数据加载到 <code>0x7c00</code> ，那么mbr.bin 后续的地址定位就不能以 0 为起始地址了，必须以 <code>0x7c00</code> 才能保证正确的地址访问，如下图所示：</p><p><img src="vstart1.png" alt="vstart1.png"></p><p>所以 <code>vstart</code> 指令告诉编译器“我知道这段代码会被加载到 vstart 地址，后续地址偏移量都已它为基准”。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>我们知道 CPU 的工作模式是，以 CS:IP 处数据作为指令，将其加载到指令寄存器IR，让后通过指令译码器ID，根据对应指令的操作，通过控制操作系统OC执行相应指令，其中指令格式如下：</p><p><img src="op.png" alt="op.png"></p><p>根据指令的不同，CPU 可能会去内存取操作数，操作数有可能就在寄存器中，经过 ALU 算术逻辑单元处理后，再将结果返回寄存器或者内存中，接着指令指针寄存器IP，继续取下一条指令执行，如果存在跳转指令，那么 IP 回去相应内存位置读取、解析并执行指令，周而复始，直到停机。</p><p><img src="cpu.png" alt="cpu.png"></p><h3 id="实模式下寄存器"><a href="#实模式下寄存器" class="headerlink" title="实模式下寄存器"></a>实模式下寄存器</h3><p><img src="register1.png" alt="register1.png"></p><p><img src="register.png" alt="register.png"></p><h3 id="实模式-CPU-内存寻址方式"><a href="#实模式-CPU-内存寻址方式" class="headerlink" title="实模式 CPU 内存寻址方式"></a>实模式 CPU 内存寻址方式</h3><p><img src="location.png" alt="location.png"></p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>我们知道栈是一种重要的数据结构， CPU中有栈段 SS 寄存器和栈指针 SP 寄存器，在内存中从高地址往地地址扩展：</p><p><img src="stack.png" alt="stack.png"></p><p>其次 CPU 中有两个指令可以操作栈 <code>push</code> 和 <code>pop</code> ：</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">push ax;等价于mov bp,spsub bp,2mov [bp],axpop ax;等价于mov bp,spmov ax,[bp]add bp,2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>栈在函数调用中至关重要：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a=0;function(int b,int c){  int d;}a++;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的汇编指令：</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">push cpush bpush ebpmov ebp,esp ;以上两句等价于 enterpush d;调用结束返回mov esp,ebppop ebp; 以上两句等价于 leave;主函数调用 add esp,8 回收变量b、c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="stack1.png" alt="stack1.png"></p><h3 id="实模式下跳转"><a href="#实模式下跳转" class="headerlink" title="实模式下跳转"></a>实模式下跳转</h3><p><img src="jmp&amp;call.png" alt="jmp&amp;call.png"></p><p>我们知道高级语言中有各种数据类型，如 int、short int、unsigned int 等，不同的数据类型代表了不同的数据范围，那么在汇编语言中同样需要表示不同的数据类型，数据类型伪指令byte、word、dword、qword可以满足此需求，修饰立即数、寄存器或内存，达到类似 C 语言类型转换的功能，在<code>call</code> 指令中也有 near、short、far 修饰符进行类型转换。</p><p><img src="callnear1.png" alt="callnear1.png"></p><h3 id="标志寄存器-flags"><a href="#标志寄存器-flags" class="headerlink" title="标志寄存器 flags"></a>标志寄存器 flags</h3><p><img src="Flags.png" alt="Flags.png"></p><h3 id="有条件转移"><a href="#有条件转移" class="headerlink" title="有条件转移"></a>有条件转移</h3><p>每条指令的执行都会影响标志寄存器，而 jxx 指令会根据标志寄存器的标志位进行跳转。</p><p><img src="jmp.png" alt="jmp.png"></p><h2 id="CPU-与IO接口"><a href="#CPU-与IO接口" class="headerlink" title="CPU 与IO接口"></a>CPU 与IO接口</h2><p><code>任何计算机问题，都可以增加额外的层来解决</code></p><p>CPU 与 IO 外设速度差异太大，不能让 CPU 等待缓慢的IO 外设而浪费宝贵的时间，所以增加了 IO 接口层来匹配其速度差异。IO 接口层具有如下功能：</p><ul><li>设置数据缓冲，解决 CPU 与外设的速度不匹配</li><li>设置信号电平转换电路</li><li>设置数据格式转换</li><li>提供地址译码</li></ul><p><img src="IO.png" alt="IO.png"></p><p>IO 接口是连接 CPU 和硬件的桥梁，端口是 IO 接口开放给 CPU 的接口，一般 IO 接口都有一组端口，端口就是寄存器，有8位、16位和32位宽度的。 Intel 汇编语言采用 <code>目标操作数=源操作数</code> 的格式，和平时用的等式相似。<br>in 指令拥有从端口中读数据：</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">in al,dxin ax,dx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>out</code> 指令拥有往端口中写数据：</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">out dx,al;out dx,ax;out 立即数,al;out 立即数,ax;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><p>计算机为了显示文本和图像需要通过 IO 接口-显卡，显卡分为 A 卡 和 N 卡，传输数据方式分为并行和串行，并行方式虽然一次传输数据量大，不过要保证同时接收多位难度较大，所以现在一般采用串行传输。</p><p>为了控制显示我们可以通过 IO 端口和显存。这里我们使用显存来控制显示输出，显存地址分布如下：</p><p><img src="display.png" alt="display.png"></p><p>显示器上每个字符占两个字节，低位字节是字符的 ASCII 码，高位字节是控制信息，如下图所示：</p><p><img src="ascii.png" alt="ascii.png"></p><p>修改后的代码如下所示：</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">;主引导程序;;LOADER_BASE_ADDR equ 0xA000;LOADER_START_SECTOR equ 0x2;------------------------------------------------------------SECTION MBR vstart=0x7c00   mov ax,cs   mov ds,ax   mov es,ax   mov ss,ax   mov fs,ax   mov sp,0x7c00   mov ax,0xb800   mov gs,ax; 清屏;利用0x06号功能，上卷全部行，则可清屏。; -----------------------------------------------------------;INT 0x10   功能号:0x06       功能描述:上卷窗口;------------------------------------------------------;输入：;AH 功能号= 0x06;AL = 上卷的行数(如果为0,表示全部);BH = 上卷行属性;(CL,CH) = 窗口左上角的(X,Y)位置;(DL,DH) = 窗口右下角的(X,Y)位置;无返回值：   mov     ax, 0600h   mov     bx, 0700h   mov     cx, 0               ; 左上角: (0, 0)   mov     dx, 184fh           ; 右下角: (80,25),                   ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。                   ; 下标从0开始，所以0x18=24,0x4f=79   int     10h                 ; int 10h   ; 输出背景色绿色，前景色红色，并且跳动的字符串"1 MBR"   mov byte [gs:0x00],'1'   mov byte [gs:0x01],0xA4     ; A表示绿色背景闪烁，4表示前景色为红色   mov byte [gs:0x02],' '   mov byte [gs:0x03],0xA4   mov byte [gs:0x04],'M'   mov byte [gs:0x05],0xA4   mov byte [gs:0x06],'B'   mov byte [gs:0x07],0xA4   mov byte [gs:0x08],'R'   mov byte [gs:0x09],0xA4   jmp $               ; 通过死循环使程序悬停在此   times 510-($-$$) db 0   db 0x55,0xaa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">nasm -o mbr.bin mbr.S<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>写入磁盘：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">dd if=mbr.bin of=/usr/local/bin/hd60M.img bs=512 count=1 conv=notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="bochs-调试方法"><a href="#bochs-调试方法" class="headerlink" title="bochs 调试方法"></a>bochs 调试方法</h2><h3 id="bochs-一般用法"><a href="#bochs-一般用法" class="headerlink" title="bochs 一般用法"></a>bochs 一般用法</h3><p>bochs硬件调试方面：</p><ul><li>调试时可以查看页表、gdt、idt等数据结构</li><li>可以查看栈中数据</li><li>可以反汇编任意内存</li><li>实模式、保护模式相互变换是提醒</li><li>中断发生时提醒</li></ul><p><img src="Bochs.png" alt="Bochs.png"></p><h2 id="硬盘介绍"><a href="#硬盘介绍" class="headerlink" title="硬盘介绍"></a>硬盘介绍</h2><p>机械硬盘示意图如下：</p><p><img src="hd.png" alt="hd.png"></p><p>硬盘的扇区在物理上是用“柱面-磁头-扇区”定位的，一般情况，主板提供了两个IDE插槽，IDE0 叫做 Primary通道，IDE1 叫做 Secondary 通过，每个通道分别有主盘和从盘。<br>硬盘手册内容相当多，这里介绍要用到的几个端口：</p><p><img src="diskio.png" alt="diskio.png"></p><p>其中 data 寄存器用于数据读写，在读硬盘时，硬盘控制器会将内容放入内部的缓冲区中，不断读取data 寄存器就是不断读取内部缓冲区；写硬盘时，将数据输入此端口，数据便会被写入缓冲区中，继而被写入扇区。<br>error 和 features 共用一个寄存器，在读写时代表不同的含义，sector count 代表剩余的扇区数，device 寄存器低4位作为 LBA 的23~27位，另外4位可以设置寻址模式和主从盘，status寄存器表征硬盘的状态信息。</p><p><img src="diskr.png" alt="diskr.png"></p><h3 id="硬盘读取步骤"><a href="#硬盘读取步骤" class="headerlink" title="硬盘读取步骤"></a>硬盘读取步骤</h3><ul><li>选择通道，往该通道的sector count寄存器写入待操作的扇区数</li><li>往该通道的三个 LBA 寄存器写入扇区起始地址的低24位</li><li>往device寄存器写入 LBA 地址的24~27位，置第6位为1，设置第4位</li><li>往该通道command寄存器写入命令</li><li>读取status寄存器</li><li>读取硬盘数据</li></ul><p>硬盘获取数据方式如下：</p><ul><li>无条件传送方式–适合内存、寄存器</li><li>查询传送方式–轮询占用 CPU 资源</li><li>中断传送方式–CPU压栈，保存现场</li><li>DMA 数据源与内存直接传送，需要硬件支持</li><li>I/O处理机–需要硬件支持</li></ul><h3 id="改造-MBR"><a href="#改造-MBR" class="headerlink" title="改造 MBR"></a>改造 MBR</h3><p>前面我们构建了 <code>MBR</code> ，下一棒要交给 <code>loader</code> 来完成，所以需要 <code>MBR</code> 将 <code>loader</code> 程序从硬盘加载到内存，<code>loader</code> 程序放置在硬盘的第 <code>2</code> 扇区，其在内存的位置是哪儿呢？由 <code>BIOS</code> 内存布局图可知，可用区域包括 <code>0x500~0x7BFF</code> 和 <code>0x7E00~9FBFF</code> ，在这里选择 <code>0x900</code> ，代码如下：</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">;主引导程序;------------------------------------------------------------%include "boot.inc"SECTION MBR vstart=0x7c00   mov ax,cs   mov ds,ax   mov es,ax   mov ss,ax   mov fs,ax   mov sp,0x7c00   mov ax,0xb800   mov gs,ax; 清屏;利用0x06号功能，上卷全部行，则可清屏。; -----------------------------------------------------------;INT 0x10   功能号:0x06       功能描述:上卷窗口;------------------------------------------------------;输入：;AH 功能号= 0x06;AL = 上卷的行数(如果为0,表示全部);BH = 上卷行属性;(CL,CH) = 窗口左上角的(X,Y)位置;(DL,DH) = 窗口右下角的(X,Y)位置;无返回值：   mov     ax, 0600h   mov     bx, 0700h   mov     cx, 0                   ; 左上角: (0, 0)   mov     dx, 184fh           ; 右下角: (80,25),                   ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。                   ; 下标从0开始，所以0x18=24,0x4f=79   int     10h                     ; int 10h   ; 输出字符串:MBR   mov byte [gs:0x00],'1'   mov byte [gs:0x01],0xA4   mov byte [gs:0x02],' '   mov byte [gs:0x03],0xA4   mov byte [gs:0x04],'M'   mov byte [gs:0x05],0xA4       ;A表示绿色背景闪烁，4表示前景色为红色   mov byte [gs:0x06],'B'   mov byte [gs:0x07],0xA4   mov byte [gs:0x08],'R'   mov byte [gs:0x09],0xA4   mov eax,LOADER_START_SECTOR     ; 起始扇区lba地址   mov bx,LOADER_BASE_ADDR       ; 写入的地址   mov cx,1             ; 待读入的扇区数   call rd_disk_m_16         ; 以下读取程序的起始部分（一个扇区）   jmp LOADER_BASE_ADDR;-------------------------------------------------------------------------------;功能:读取硬盘n个扇区rd_disk_m_16:;-------------------------------------------------------------------------------                       ; eax=LBA扇区号                       ; ebx=将数据写入的内存地址                       ; ecx=读入的扇区数      mov esi,eax      ;备份eax      mov di,cx          ;备份cx;读写硬盘:;第1步：设置要读取的扇区数      mov dx,0x1f2      mov al,cl      out dx,al            ;读取的扇区数      mov eax,esi       ;恢复ax;第2步：将LBA地址存入0x1f3 ~ 0x1f6      ;LBA地址7~0位写入端口0x1f3      mov dx,0x1f3      out dx,al      ;LBA地址15~8位写入端口0x1f4      mov cl,8      shr eax,cl      mov dx,0x1f4      out dx,al      ;LBA地址23~16位写入端口0x1f5      shr eax,cl      mov dx,0x1f5      out dx,al      shr eax,cl      and al,0x0f       ;lba第24~27位      or al,0xe0       ; 设置7～4位为1110,表示lba模式      mov dx,0x1f6      out dx,al;第3步：向0x1f7端口写入读命令，0x20      mov dx,0x1f7      mov al,0x20      out dx,al;第4步：检测硬盘状态  .not_ready:      ;同一端口，写时表示写入命令字，读时表示读入硬盘状态      nop      in al,dx      and al,0x88       ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙      cmp al,0x08      jnz .not_ready       ;若未准备好，继续等。;第5步：从0x1f0端口读数据      mov ax, di      mov dx, 256      mul dx      mov cx, ax       ; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，               ; 共需di*512/2次，所以di*256      mov dx, 0x1f0  .go_on_read:      in ax,dx      mov [bx],ax      add bx,2      loop .go_on_read      ret   times 510-($-$$) db 0   db 0x55,0xaa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">;-------------     loader和kernel   ----------LOADER_BASE_ADDR equ 0x900LOADER_START_SECTOR equ 0x2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>loader 目前的内容：</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">%include "boot.inc"section loader vstart=LOADER_BASE_ADDR; 输出背景色绿色，前景色红色，并且跳动的字符串"1 MBR"mov byte [gs:0x00],'2'mov byte [gs:0x01],0xA4     ; A表示绿色背景闪烁，4表示前景色为红色mov byte [gs:0x02],' 'mov byte [gs:0x03],0xA4mov byte [gs:0x04],'L'mov byte [gs:0x05],0xA4mov byte [gs:0x06],'O'mov byte [gs:0x07],0xA4mov byte [gs:0x08],'A'mov byte [gs:0x09],0xA4mov byte [gs:0x0a],'D'mov byte [gs:0x0b],0xA4mov byte [gs:0x0c],'E'mov byte [gs:0x0d],0xA4mov byte [gs:0x0e],'R'mov byte [gs:0x0f],0xA4jmp $               ; 通过死循环使程序悬停在此<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有几点值得注意：</p><ul><li>如果寄存器可能被修改，要做好备份</li><li>mul 操作数，另一乘数默认在 al 或者 ax</li></ul><p>编译<code>mbr</code>指令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">cqliaoli@cqliaoli-ubuntu:~/os/elephant/code/c3/b/boot$ nasm -I include/ -o mbr.bin mbr.S<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>mbr</code>写入磁盘：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo dd if=mbr.bin of=/usr/local/bin/hd60M.img bs=512 count=1 conv=notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译 <code>loader</code>：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">nasm -I include/ -o loader.bin loader.S<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>loader</code> 写入硬盘：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo dd if=loader.bin of=/usr/local/bin/hd60M.img bs=512 count=1 seek=2 conv=notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统设计与实现-汇编基础、MBR</title>
      <link href="/2018/11/05/cao-zuo-xi-tong-she-ji-yu-shi-xian-hui-bian-ji-chu-mbr/"/>
      <url>/2018/11/05/cao-zuo-xi-tong-she-ji-yu-shi-xian-hui-bian-ji-chu-mbr/</url>
      
        <content type="html"><![CDATA[<p>本节介绍计算机启动过程和汇编语言的基础。</p><a id="more"></a><h2 id="实模式内存布局"><a href="#实模式内存布局" class="headerlink" title="实模式内存布局"></a>实模式内存布局</h2><p>实模式下内存布局如下图所示：</p><p><img src="bios.png" alt="bios.png"></p><h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p>计算机前期启动过程如下图所示：</p><p><img src="mbr.png" alt="mbr.png"></p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">;主引导程序;------------------------------------------------------------;根据流程 BIOS 会跳转到 0x7c00 所以将代码载入到该地址SECTION MBR vstart=0x7c00   mov ax,cs   mov ds,ax   mov es,ax   mov ss,ax   mov fs,ax   mov sp,0x7c00; 清屏 利用0x06号功能，上卷全部行，则可清屏。; -----------------------------------------------------------;INT 0x10   功能号:0x06       功能描述:上卷窗口;------------------------------------------------------;输入：;AH 功能号= 0x06;AL = 上卷的行数(如果为0,表示全部);BH = 上卷行属性;(CL,CH) = 窗口左上角的(X,Y)位置;(DL,DH) = 窗口右下角的(X,Y)位置;无返回值：   mov     ax, 0x600   mov     bx, 0x700   mov     cx, 0           ; 左上角: (0, 0)   mov     dx, 0x184f       ; 右下角: (80,25),               ; VGA文本模式中,一行只能容纳80个字符,共25行。               ; 下标从0开始,所以0x18=24,0x4f=79   int     0x10            ; int 0x10;;;;;;;;;    下面这三行代码是获取光标位置    ;;;;;;;;;;.get_cursor获取当前光标位置,在光标位置处打印字符.   mov ah, 3        ; 输入: 3号子功能是获取光标位置,需要存入ah寄存器   mov bh, 0        ; bh寄存器存储的是待获取光标的页号   int 0x10        ; 输出: ch=光标开始行,cl=光标结束行            ; dh=光标所在行号,dl=光标所在列号;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;;;;;;;;;;     打印字符串    ;;;;;;;;;;;   ;还是用10h中断,不过这次是调用13号子功能打印字符串   mov ax, message   mov bp, ax        ; es:bp 为串首地址, es此时同cs一致，            ; 开头时已经为sreg初始化   ; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略   mov cx, 5        ; cx 为串长度,不包括结束符0的字符个数   mov ax, 0x1301    ; 子功能号13是显示字符及属性,要存入ah寄存器,            ; al设置写字符方式 ah=01: 显示字符串,光标跟随移动   mov bx, 0x2        ; bh存储要显示的页号,此处是第0页,            ; bl中是字符属性, 属性黑底绿字(bl = 02h)   int 0x10        ; 执行BIOS 0x10 号中断;;;;;;;;;      打字字符串结束     ;;;;;;;;;;;;;;;   jmp $        ; 使程序悬停在此   message db "1 MBR"   times 510-($-$$) db 0   db 0x55,0xaa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="和-以及-section"><a href="#和-以及-section" class="headerlink" title="$和$$ 以及 section"></a>$和$$ 以及 section</h3><p>其中 $ 和 $$ 是编译器 NASM 预留的伪指令，$ 表示当前行的地址，起标号作用， $$ 代表本 section 的起始地址，默认情况下其值为本文件开头的偏移量。但是 section 用了 <code>vstart =xxxx</code> ，那么 $$ 值虚拟地址变成 xxxx 。section的作用是为了代码的可维护性，逻辑上的划分，比如讲数据定义、代码分开定义，使得代码组织更清晰。可以这样理解，为了满足程序重定位，代码的地址不能写死，而程序中又需要地址定位，那该如何解决呢？其实和文件夹路径定位一样，我们可以使用相对路径，而不是使用绝对路径，这样我们的定位方式就是可以移植的，只要确定了开始地址，加上偏移量就确定了其他地址。</p><h3 id="NASM"><a href="#NASM" class="headerlink" title="NASM"></a>NASM</h3><p>NASM 编译器能够将汇编代码编译成各种格式，如 bin、ith、elf32、win 等，我们关心的是 <code>bin</code> 和 <code>elf</code> 格式。<br>通过以下命令将 mbr.S 编译成 mbr.bin</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">nasm -o mbr.bin mbr.S<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还记得上面的流程，CPU 现在要加载 MBR ，并跳转到 <code>0x7c00</code> 执行，所以接下来我们将刚刚的二进制文件写入 <code>hd60M.img</code> 第 0 块的前 512 字节。<br>这里使用 dd 命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo dd if=mbr.bin of=/usr/local/bin/hd60M.img  bs=512 count=1 conv=notrunccqliaoli@cqliaoli-ubuntu:/usr/local/bin$ bochs -f bochsrc.disk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="mbr1.png" alt="mbr1.png"></p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统设计与实现-环境搭建</title>
      <link href="/2018/11/04/cao-zuo-xi-tong-she-ji-yu-shi-xian-huan-jing-da-jian/"/>
      <url>/2018/11/04/cao-zuo-xi-tong-she-ji-yu-shi-xian-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<p>研发操作系统主要用到汇编语言和 C 语言，以及开源虚拟机Bochs，bochs可以帮助我们调试操作系统。</p><a id="more"></a><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p> Ubuntu 18</p><h3 id="编译器和编译工具"><a href="#编译器和编译工具" class="headerlink" title="编译器和编译工具"></a>编译器和编译工具</h3><ul><li>gcc c语言编译器</li><li>as 汇编语言编译器</li><li>ld 连接器</li><li>nasm 汇编语言编译器，用于编译Intel格式汇编语言</li><li>make 编译构建工具</li></ul><h2 id="Bochs虚拟机"><a href="#Bochs虚拟机" class="headerlink" title="Bochs虚拟机"></a>Bochs虚拟机</h2><h3 id="bochs环境安装"><a href="#bochs环境安装" class="headerlink" title="bochs环境安装"></a>bochs环境安装</h3><p>bochs最新版本为 <a href="http://bochs.sourceforge.net/">bochs-2.6.9</a> ，配置信息如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">//先安装 g++ libx11 等软件包./configure --with-x11 --with-wx --enable-debugger --enable-disasm --enable-all-optimizations --enable-readline --enable-long-phy-address --enable-ltdl-install --enable-idle-hack  --enable-a20-pin --enable-x86-64 --enable-smp --enable-cpu-level=6 --enable-large-ramfile --enable-repeat-speedups --enable-fast-function-calls  --enable-handlers-chaining  --enable-trace-linking --enable-configurable-msrs --enable-show-ips --enable-cpp --enable-debugger-gui --enable-iodebug --enable-logging --enable-assert-checks --enable-fpu --enable-vmx=2 --enable-svm --enable-3dnow --enable-alignment-check  --enable-monitor-mwait --enable-avx  --enable-evex --enable-x86-debugger --enable-pci --enable-usb --enable-voodoo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意 bochs <code>--enable-plugins</code> 选项有 <code>bug</code> ，所以取消了该配置项。在 <code>make</code> 过程中可能有错误，比如找不到以 <code>.cpp</code> 为后缀的文件，需要将其改为 <code>.cc</code> 后缀。在 <code>/usr/local/bin</code> 路径下执行 <code>bochs</code>：</p><p><img src="bochs.png" alt="bochs.png"></p><h3 id="Bochs-运行环境配置"><a href="#Bochs-运行环境配置" class="headerlink" title="Bochs 运行环境配置"></a>Bochs 运行环境配置</h3><p>安装好 Bochs 后，还需要一个硬件环境让Bochs去模拟，所以还需要配置虚拟平台环境：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"># 配置1  软盘模式# configuration file generated by Bochsplugin_ctrl: unmapped=1, biosdev=1, speaker=1, extfpuirq=1, parallel=1, serial=1, iodebug=1config_interface: textconfigdisplay_library: x#memory: host=2048, guest=2048romimage: file="/usr/local/share/bochs/BIOS-bochs-latest"vgaromimage: file="/usr/local/share/bochs/VGABIOS-lgpl-latest"# 启动方式可以是软盘或者硬盘boot: floppyfloppy_bootsig_check: disabled=0floppya: type=1_44, 1_44="boot.img", status=inserted, write_protected=0# no floppybata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14ata0-master: type=noneata0-slave: type=noneata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15ata1-master: type=noneata1-slave: type=noneata2: enabled=0ata3: enabled=0pci: enabled=1, chipset=i440fxvga: extension=vbe, update_freq=5# 模拟的cpucpu: count=1:1:1, ips=4000000, quantum=16, model=corei7_haswell_4770, reset_on_triple_fault=1, cpuid_limit_winnt=0, ignore_bad_msrs=1, mwait_is_nop=0, msrs="msrs.def"cpuid: x86_64=1,level=6, mmx=1, sep=1, simd=avx512, aes=1, movbe=1, xsave=1,apic=x2apic,sha=1,movbe=1,adx=1,xsaveopt=1,avx_f16c=1,avx_fma=1,bmi=bmi2,1g_pages=1,pcid=1,fsgsbase=1,smep=1,smap=1,mwait=1,vmx=1cpuid: family=6, model=0x1a, stepping=5, vendor_string="GenuineIntel", brand_string="Intel(R) Core(TM) i7-4770 CPU (Haswell)"print_timestamps: enabled=0debugger_log: -magic_break: enabled=0port_e9_hack: enabled=0private_colormap: enabled=0clock: sync=none, time0=local, rtc_sync=0# no cmosimage# no loaderlog: -logprefix: %t%e%ddebug: action=ignoreinfo: action=reporterror: action=reportpanic: action=askkeyboard: type=mf, serial_delay=250, paste_delay=100000, user_shortcut=nonemouse: type=ps2, enabled=0, toggle=ctrl+mbuttonspeaker: enabled=1, mode=systemparport1: enabled=1, file=noneparport2: enabled=0com1: enabled=1, mode=nullcom2: enabled=0com3: enabled=0com4: enabled=0//内存megs: 256<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上述配置保存到 <code>/usr/local/bin</code> 下的 <code>bochsrc</code> 下，然后输入 <code>bochs -f bochsrc</code> ：</p><p><img src="bochs2.png" alt="bochs2.png"></p><p><img src="bochs3.png" alt="bochs3.png"></p><p>输入 <code>c</code></p><p><img src="bochs4.png" alt="bochs4.png"></p><p>提示 <code>无启动设备</code>，那是因为在上面配置中 <code>floppya: type=1_44, 1_44="boot.img", status=inserted, write_protected=0</code> 我们指定了 <code>boot.img</code> 但是还没有生成，后续章节将制作启动盘。</p><p>除了上面提到的软盘模式，我们还可以以硬盘作为启动盘：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#配置2 硬盘启动# configuration file generated by Bochsplugin_ctrl: unmapped=1, biosdev=1, speaker=1, extfpuirq=1, parallel=1, serial=1, iodebug=1config_interface: textconfigdisplay_library: x#memory: host=2048, guest=2048romimage: file="/usr/local/share/bochs/BIOS-bochs-latest"vgaromimage: file="/usr/local/share/bochs/VGABIOS-lgpl-latest"# 硬盘启动boot: disk#floppy_bootsig_check: disabled=0#floppya: type=1_44, 1_44="boot.img", status=inserted, write_protected=0# no floppybata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14ata0-master: type=noneata0-slave: type=noneata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15ata1-master: type=noneata1-slave: type=noneata2: enabled=0ata3: enabled=0pci: enabled=1, chipset=i440fxvga: extension=vbe, update_freq=5cpu: count=1:1:1, ips=4000000, quantum=16, model=corei7_haswell_4770, reset_on_triple_fault=1, cpuid_limit_winnt=0, ignore_bad_msrs=1, mwait_is_nop=0, msrs="msrs.def"cpuid: x86_64=1,level=6, mmx=1, sep=1, simd=avx512, aes=1, movbe=1, xsave=1,apic=x2apic,sha=1,movbe=1,adx=1,xsaveopt=1,avx_f16c=1,avx_fma=1,bmi=bmi2,1g_pages=1,pcid=1,fsgsbase=1,smep=1,smap=1,mwait=1,vmx=1cpuid: family=6, model=0x1a, stepping=5, vendor_string="GenuineIntel", brand_string="Intel(R) Core(TM) i7-4770 CPU (Haswell)"print_timestamps: enabled=0debugger_log: -magic_break: enabled=0port_e9_hack: enabled=0private_colormap: enabled=0clock: sync=none, time0=local, rtc_sync=0# no cmosimage# no loaderlog: -logprefix: %t%e%ddebug: action=ignoreinfo: action=reporterror: action=reportpanic: action=askkeyboard: type=mf, serial_delay=250, paste_delay=100000, user_shortcut=nonemouse: type=ps2, enabled=0, toggle=ctrl+mbuttonspeaker: enabled=1, mode=systemparport1: enabled=1, file=noneparport2: enabled=0com1: enabled=1, mode=nullcom2: enabled=0com3: enabled=0com4: enabled=0megs: 256<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们使用 <code>sudo bximage</code> 命令制作硬盘，按照其提示选择 <code>hd  flat </code> 输入硬盘大小和名称，最后显示：</p><p><img src="bochs5.png" alt="bochs5.png"></p><p>将对应语句加上配置文件中：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">...ata0-master:type=disk,path="hd60M.img",mode=flat...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再次运行命令 <code>bochs -f bochsrc.disk</code></p><p><img src="bochs6.png" alt="bochs6.png"></p><p><code>bin</code> 目录下文件如图所示：</p><p><img src="bochs7.png" alt="bochs7.png"></p><p>虽然有了硬盘，但是还没有任何信息，所以提示无法读取硬盘。接下来我们将往硬盘写入信息。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统设计与实现-概述</title>
      <link href="/2018/11/04/cao-zuo-xi-tong-she-ji-yu-shi-xian-gai-shu/"/>
      <url>/2018/11/04/cao-zuo-xi-tong-she-ji-yu-shi-xian-gai-shu/</url>
      
        <content type="html"><![CDATA[<p>学习操作系统时，只看理论总觉得懂了但是不能沉下去，直接看linux源码又太庞大，市面上关于自制操作系统的不多，其中《操作系统系统真象还原》和《一个64位操作系统的设计与实现》算其中比较接地气的。本系列将参考这两本书构建简易的操作系统，通过自制操作系统再看理论效果更佳。</p><a id="more"></a><h2 id="操作系统点滴"><a href="#操作系统点滴" class="headerlink" title="操作系统点滴"></a>操作系统点滴</h2><h3 id="软件如何访问硬件"><a href="#软件如何访问硬件" class="headerlink" title="软件如何访问硬件"></a>软件如何访问硬件</h3><p>硬件在输入输出方式上分为串行接口和并行接口，访问外部硬件有两个方式：</p><ul><li>将外设的内存映射到一定范围的地址空间。CPU 访问该地址空间就会映射到对应的外存上，比如显存就是通过这种方式。</li><li>外设通过IO接口与CPU通信。<h3 id="内存访问为什么要分段"><a href="#内存访问为什么要分段" class="headerlink" title="内存访问为什么要分段"></a>内存访问为什么要分段</h3></li></ul><p>内存可以看出线性的地址组成，那为什么需要用分段的形式访问内存呢，直接用内存地址不是更加方便吗。采用<code>段基址+段内偏移地址</code>主要基于以下两个原因：<br>重定位，编译器在编译程序时，如果使用内存的绝对物理地址，试想两个不同的程序有相同的地址，岂不是不能同时运行！通过分段后，只要段地址不同，即使有相同的偏移地址，两个程序也可以同时运行了。<br>寄存器位数限制，早起的寄存器只有 16 位，能够访问的长度只有 64 KB，但是内存却又 1M ，所以将大内存分成可以访问的小段，哪怕16位寄存器也可以访问 1M 内存了。</p><h3 id="代码的分段"><a href="#代码的分段" class="headerlink" title="代码的分段"></a>代码的分段</h3><p>高级语言一般不用关心程序的分段，因为程序工作在平坦模型，而汇编语言一般会将程序分为数据段、代码段、栈段等，将代码分段有以下好处：</p><ul><li>赋予不同段不同属性，比如代码段一般为只读，数据段可写。</li><li>提高 CPU 内部缓存的命中率。</li><li>节省内存，代码段由于只读，所以可以共享。</li></ul><p>代码的分段更多是从逻辑上讲的，对于 CPU 只有指令，按照 IP 寄存器的指令解析、执行，周而复始。</p><h3 id="物理地址、逻辑地址、线性地址和虚拟地址"><a href="#物理地址、逻辑地址、线性地址和虚拟地址" class="headerlink" title="物理地址、逻辑地址、线性地址和虚拟地址"></a>物理地址、逻辑地址、线性地址和虚拟地址</h3><p><img src="protected.png" alt="protected.png"></p><h3 id="局部变量和函数参数"><a href="#局部变量和函数参数" class="headerlink" title="局部变量和函数参数"></a>局部变量和函数参数</h3><p>局部变量和函数参数为什么放在栈中？</p><ul><li>局部性导致</li><li>函数在程序执行过程中的调用，属于动态调用，编译器无法预测何时会被调用以及调用次数，比如递归调用。</li></ul><h3 id="大端和小端"><a href="#大端和小端" class="headerlink" title="大端和小端"></a>大端和小端</h3><p>小端字节序指数值的低字节在内存的低地址处，高字节在内存的高地址处，大端序正好相反。<br>大端字节序有：IBM、Sun、PowerPC<br>小端字节序：x86、DEC</p><h3 id="BIOS-中断"><a href="#BIOS-中断" class="headerlink" title="BIOS 中断"></a>BIOS 中断</h3><p>系统通过中断响应外设的事件，在实模式下，中断调用建立在中断向量表（Interrupt Vector Table,IVT）中，它们通过软中断指令 int 中断号来调用。</p><h3 id="Section和Segment-区别"><a href="#Section和Segment-区别" class="headerlink" title="Section和Segment 区别"></a>Section和Segment 区别</h3><p>汇编语言中，section 和 segment 只是逻辑上的划分，常见的节有：<br>节名  | 说明<br>——|——————-<br>.data | 用于存数据，可读写<br>.text | 存代码，可读可执行<br>.bss  | 全局为初始化区域</p><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>C 语言编译分为以下几步：</p><ul><li>预编译，将处理 #include 指令以及宏等。</li><li>编译阶段，将 C 代码编译成汇编代码。</li><li>汇编阶段，将汇编代码编译成目标代码。</li><li>链接阶段，将用到的标准库文件链接到目标文件。</li></ul><h3 id="MBR、EBR、DBR"><a href="#MBR、EBR、DBR" class="headerlink" title="MBR、EBR、DBR"></a>MBR、EBR、DBR</h3><p><img src="mbr.png" alt="mbr.png"></p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C和指针-字符串、字符和字节</title>
      <link href="/2018/11/04/c-he-zhi-zhen-zi-fu-chuan-zi-fu-he-zi-jie/"/>
      <url>/2018/11/04/c-he-zhi-zhen-zi-fu-chuan-zi-fu-he-zi-jie/</url>
      
        <content type="html"><![CDATA[<p>字符串是一种重要的数据结构，C 语言没有显示的字符串数据类型，字符串以字符串常量或者字符数组形式出现。字符串常量适用于不会对字符串修改的场景。</p><a id="more"></a><h2 id="字符串基础"><a href="#字符串基础" class="headerlink" title="字符串基础"></a>字符串基础</h2><p>字符串是一串零个或者多个字符，且以一位模式为 0 的 NUL字节结尾。字符串包含的内部不能出现 NUL 字节，计算长度时也不包括 NUL 字节。</p><h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><p>标准库提供了库函数 strlen 的原型：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">size_t strlen(char const *string);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是请注意其返回类型为 <code>size_t</code> 代表一个无符号整数类型。在表达式中使用无符号类型时要注意类型转换和提升。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">if(strlen(x)&gt;=strlen(y))... //    Aif(strlen(x)-strlen(y)&gt;=0)...//    B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在 B 中由于无符号类型永远大于0，所以其结果未必符合预期。</p><h2 id="不受限制的字符串函数"><a href="#不受限制的字符串函数" class="headerlink" title="不受限制的字符串函数"></a>不受限制的字符串函数</h2><p>不受限制指的是这些函数都是通过寻找字符串参数结尾的 NUL 字节判断其长度。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *strcpy(char *dst,char const *src);char *strcat(char *dst,char const *src);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>有两点值得注意：</p><ul><li>如果 dst 和 src 内存重叠，其结果是不可预知的。</li><li>程序员必须保证 dst 拥有足够的内存。</li></ul><h2 id="长度受限的字符串函数"><a href="#长度受限的字符串函数" class="headerlink" title="长度受限的字符串函数"></a>长度受限的字符串函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *strncpy(char *dst,char const *src,size_t len);char *strncat(char *dst,char const *src,size_t len);char *strncmp(char const *s1,char const *s2,size_t len);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意点：</p><ul><li>strncpy 不会再 dst 末尾添加 NUL 字节。</li><li>strncat 会在<code>dst</code>末尾自动添加 NUL 字节。</li></ul><h2 id="字符串查找基础"><a href="#字符串查找基础" class="headerlink" title="字符串查找基础"></a>字符串查找基础</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">//返回指向字符ch第一次出现的位置的指针char *strchr(char const *str,int ch);//返回指向字符ch最后一次出现的位置的指针char *strnchr(char const *str,int ch);//返回group字符串任意字符第一次出现的位置指针char *strpbrk(char const *str,char const *group);//返回s1 中s2 第一次出现的位置指针char *strstr(char const *s1,char const *s2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高级字符串查找"><a href="#高级字符串查找" class="headerlink" title="高级字符串查找"></a>高级字符串查找</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">//返回str起始部分匹配group中任意字符的字符数size_t strspn(char const *str,char const *group);//返回str起始部分不与group中任意字符匹配的字符数size_t strcspn(char const *str,char const *group);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h2><p>由于字符串是一个以 NUL 字节结尾，所以如果要操作内部包含NUL的字符串数据，前面的字符串函数将无能为力。不过 C 语言提供了字节层面的操作函数 <code>memxxx</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void *memcpy(void *dst,void const *src,size_t length);void *memmove(void *dst,void const *src,size_t length);void *memcmp(void const *s,void const *b,size_t length);void *memchr(void const *s,int ch,size_t length);void *memset(void const *s,int ch,size_t length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="警告总结"><a href="#警告总结" class="headerlink" title="警告总结"></a>警告总结</h2><ul><li>避免在有符号的表达式中使用 <code>strlen</code> 函数。</li><li>避免在表达式中混用有符号和无符号数。</li><li>strcpy 和 strcat 函数要保证源数组内存足够。</li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C和指针-数组</title>
      <link href="/2018/11/04/c-he-zhi-zhen-shu-zu/"/>
      <url>/2018/11/04/c-he-zhi-zhen-shu-zu/</url>
      
        <content type="html"><![CDATA[<p>本节将讨论多维数组、数组和指针。</p><a id="more"></a><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><p>对应数组声明:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int b[10];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请问 <code>b</code> 的含义是什么呢？可能你觉得是代表整个数组，但事实并非如此。在 C 中，数组名只是一个指针常量，b 表示指向 int 的常量指针；如果是其他类型，那数组名就是指向其他类型的常量指针。那是不是意味着<strong>数组</strong>和<strong>指针</strong>是同一个东西呢？其实不是，数组具有指针完全不同的特征。数组具有确定数量的元素，而指针只是一个标量。只有当数组名出现在表达式中，编译器才会产生一个指针常量。</p><p>另外值得注意的是，数组名是一个<strong>指针常量</strong>，所以我们不能更改其指向的内存位置，毕竟数组一旦初始化完成，其内存位置便固定了。</p><h3 id="下标引用"><a href="#下标引用" class="headerlink" title="下标引用"></a>下标引用</h3><p>除了优先级以外，下标引用和间接访问完全相同。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">array[subscript] &lt;==&gt; *(array+(subscript))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int array[10];int *ap=array+2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面是涉及ap的表达式及其等价的array表达式：</p><ul><li>ap 其等价的array表达式为 <code>array+2</code> 或者 <code>&amp;array[2]</code> 。</li><li>*ap 表示间接访问ap所指向的位置，等价于 <code>array[2]</code> 或者 <code>\*(array+2)</code> 。</li><li>ap[0] C 的下标引用和间接访问表达式是一样的，等价于 <code>*(ap+(0))</code> 或 <code>array[2]</code></li><li>ap+6 ap指针向后移动6个单位，等价于 <code>array+8</code> 或者 <code>&amp;array[8]</code></li><li>*ap+6  由于间接访问优先级高，所以先执行间接访问，等价于 <code>array[2]+6</code></li><li>*(ap+6) 等价于  <code>array[8]</code></li><li>ap[6] 等价于  <code>array[8]</code></li><li>&amp;ap 取得ap指针的地址，由于不知道ap地址，故没有array等价的表达式</li><li>ap[-1] 下标引用就是间接表达式，等价于 <code>ap-1</code> 即 <code>array[1]</code></li><li>ap[9] 该表达式语法上完全正确，但是可能会带来严重的bug，因为其位置超出了 array的最后一个元素，其值是未知的。该例子也说明了为什么 <code>C</code> 语言下标检查十分困难，正是由于指针也能够进行下标引用。</li></ul><p>另一个有趣的例子是 <code>2[array]</code> ，该式子是合法的，按照前面讲的指针形式转换为<code>*(2+(array))</code> 等价于<code>array[2]</code>。</p><h3 id="下标与指针"><a href="#下标与指针" class="headerlink" title="下标与指针"></a>下标与指针</h3><p>下标与指针能够互换的情况下该使用哪一个呢？下标绝不会比指针更有效率，但指针有时会比下标更有效率。</p><h3 id="指针的效率"><a href="#指针的效率" class="headerlink" title="指针的效率"></a>指针的效率</h3><p>有时指针能比下标引用更加有效，但是我们应该在程序可读性和效率之间做好平衡。</p><h3 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h3><p>指针和数组并不相等，例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a[5];int *b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="array.png" alt="array.png"><br>虽然 <code>a</code> 和 <code>b</code> 都可以间接访问和下标引用，但是它们却有很大区别，声明一个数组时，编译器会根据数组长度为数组保留内存空间，然后再创建数组名，它的值是一个常量，指向这段内存的起始位置。声明一个指针变量时，编译器仅仅给指针变量本身分配内存而已，如果它是一个自动变量，甚至都不会被初始化。</p><h3 id="作为函数参数的数组名和声明数组参数"><a href="#作为函数参数的数组名和声明数组参数" class="headerlink" title="作为函数参数的数组名和声明数组参数"></a>作为函数参数的数组名和声明数组参数</h3><p>当数组名作为函数参数时，其实传递的是指向数组起始位置的指针的拷贝。正是由于传递的是指针，以下两种方式都是合法的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int strlen(char *string);int strlen(char string[]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>数组也可以像标量变量初始化一样：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int vector[5]={10,20,30,40,50};//未完整的初始化，其余元素自动初始化为0int vector[5]={3,3,4};//自动计算数组长度int vector[]={1,2,3,4,5,6};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组初始化的方式也取决于其存储类型，静态数组只初始化一次，自动变量类型数组每次进入代码块都会初始化。</p><h3 id="字符串数组的初始化"><a href="#字符串数组的初始化" class="headerlink" title="字符串数组的初始化"></a>字符串数组的初始化</h3><p>字符串数组初始化可以采用以下两种形式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char message[]={'H','e','l','l','o'};char message[]="Hello";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是注意字符串数组和字符串常量是不同的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char message[]={'H','e','l','l','o'};char *message2="Hello";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="char.png" alt="char.png"></p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组指某个数组的维度不只一个。我们该怎么理解多维数组呢？</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int d[3][6][10];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>d 可以看做包含 3 个元素的数组，其中每个元素是包含 6 个元素的数组，这 6 个元素每一个又是包含  10 个元素的数组。</p><h3 id="存储顺序"><a href="#存储顺序" class="headerlink" title="存储顺序"></a>存储顺序</h3><p>我们知道内存是线性排列的，那数组的不同维度该如何表示呢？我们可以按照上面的描述将每个元素依次排列即可，例如 <code>int array[3][6]</code> 在内存中按如下方式排列：</p><p><img src="arrays.png" alt="arrays.png"></p><h3 id="数组名-1"><a href="#数组名-1" class="headerlink" title="数组名"></a>数组名</h3><p>根据刚才的描述，数组名是一个指针常量，其类型是“指向元素类型的指针”，对于多维数组该如何理解呢？如 <code>int matrix[3][10]</code> matrix 可以看做一维数组，包含 3 个元素，每个元素是包含 10 个元素的数组，所以 matrix 可以看做一个指向包含 10 个元素数组的指针。</p><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><p>下标引用就是间接访问表达式的另一种形式，多维数组与一位数组不同的地方在于，一维数组中，指针每次移动增加的单位是数组类型的单位长度，多维数组指针运算时，要更加其类型增加相应的量。例如<code>int matrix[3][10]</code>，matrix的类型是<code>指向包含10个整型元素的数组的指针</code>:</p><p><img src="arrayp.png" alt="arrayp.png"></p><p><code>matrix+1</code> 也是<code>指向包含10个整型元素的数组的指针</code>，不过<code>matrix+1</code>指向matrix的下一行:<br><img src="arrayp2.png" alt="arrayp2.png"></p><p>matrix 移动时会根据其类型（指向包含10个整型元素的数组）为单位移动。</p><h3 id="指向数组的指针"><a href="#指向数组的指针" class="headerlink" title="指向数组的指针"></a>指向数组的指针</h3><p>对于如下声明：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int vector[10],*vp=vector;             (A)int matrix[3][10],mp=matrix;           (B)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于 A 中的指针变量其类型和数组是匹配的，但是 B 的<code>matrix</code> 指向的整型数组的指针，而 <code>mp</code> 是指向整型的指针，显然类型不匹配，所以 C 语言提供了指向整型数组的指针的声明：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int (*p)[10];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="arrayp3.png" alt="arrayp3.png"></p><p>上面这个声明看似复杂，只要我们按照优先级顺序正确解读，也是十分容易的。步骤如下：</p><ol><li>括号具有最高优先级，*p 说明 p是一个指针。</li><li>接下来执行下标引用，所以p执行某种类型的数组。</li><li>该数组类型为 int 。</li></ol><p>也可以这样推断p的类型，对 p 执行间接访问操作得到一个数组，所以p是一个指向整型数组的指针。</p><h3 id="作为函数参数的多维数组"><a href="#作为函数参数的多维数组" class="headerlink" title="作为函数参数的多维数组"></a>作为函数参数的多维数组</h3><p>多维数组作为参数传递和一维数组类似，都是传递的指针，不过多维数组的每个元素是另一个数组，所以除第一维以外的其他维度都要明确声明。</p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>多维数组也可以用初始化列表初始化，以及部分初始化和数组长度自动计算。</p><h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>指针变量和其他变量没有什么不同，可以创建整型数组，那么也可以创建指针数组：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int *api[10];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="arrayp4.png" alt="arrayp4.png"></p><p>按照上面的方法，根据优先级依次计算：</p><ol><li>下标引用优先级高于间接访问，api是一个包含10个元素的数组。</li><li>取得一个元素执行间接访问。</li><li>间接访问的结果是int类型。</li></ol><p>综上 api 是一个数组，元素类型为指向整型的指针。<br>我们在字符串数组相关操作中，就可能使用指针数组。如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char const keyword[][9]={  "do",  "for",  "if",  "register",  "return",  "switch",  "while"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="chararray.png" alt="chararray.png"></p><p>如果用一个指针数组声明，每个指针元素初始化为不同的字符串常量：</p><p><img src="chararray1.png" alt="chararray1.png"></p><h2 id="编程提示总结"><a href="#编程提示总结" class="headerlink" title="编程提示总结"></a>编程提示总结</h2><ol><li>源代码的可读性比程序运行效率更为重要</li><li>只要可能，函数指针形参应声明为 const</li><li>多维数组的初始化列表值使用完整多层花括号能提高可读性</li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C和指针-函数</title>
      <link href="/2018/11/04/c-he-zhi-zhen-han-shu/"/>
      <url>/2018/11/04/c-he-zhi-zhen-han-shu/</url>
      
        <content type="html"><![CDATA[<p>函数作为组成代码的基本模块，是每种语言必备的语法结构。</p><a id="more"></a><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>函数的定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">类型 函数名（形式参数）代码块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当执行流到达函数定义末尾，函数将返回（return），有些语言将没有返回语句的函数称为过程（procedure），有返回语句的才称为函数。</p><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>C 语言函数比较特别的一点是，函数需要声明，函数声明告诉了编译器关于函数期望的参数类型和数量，以及函数返回值类型的详细信息。如果没有这些信息，编译器假定该函数调用是正确的，并假定其返回整型值。</p><p>提供函数声明的方式是使用<strong>函数原型（function prototype）</strong>，提供函数原型最好将其放在单独的文件，需要的地方用<code>#include</code>引用，这样做的好处有：</p><ul><li>函数原型具有文件作用域，原型的一份拷贝可以作用于整个文件。</li><li>函数原型只需书写一次，便于修改和维护。</li></ul><p>注意，如果程序调用函数时，编译器找不到匹配的原型，编译器将使用缺省的整型值。<strong>记住，值的类型并不是指的内在本质，而是取决于它被使用的方式。</strong></p><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>函数传递参数包含按值传递和按引用传递，现在绝大部分语言都采用按值传递。C 语言的传值调用需要注意，如果传递的是数组名，那么函数体对数组的修改将最终反映到数组上，那这种行为是不是和按值传递相悖了呢？记住，虽然 C 语言按照值传递，不过数组名其实时一个指针，所以传递的是指针的拷贝，我们知道通过指针是可以修改指针指向的内存的。所以 C 语言通过值传递间接实现了地址传递。</p><h2 id="ADT-和黑盒"><a href="#ADT-和黑盒" class="headerlink" title="ADT 和黑盒"></a>ADT 和黑盒</h2><p>ADT 指抽象数据类型（abstract data type），它可以让程序更加模块化，提高程序的通用性。我们在使用数据结构时，只需要知道其接口即可，至于其中的实现方式可以看做一个黑盒，这样将数据的实现和使用分离，极大提高了程序通用性、独立性和抽象性。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>初学者往往容易被递归搞得晕头转向，原因是我们总是想去理解其执行过程，人脑的执行栈哪有计算机这么深，结果越陷越深，迷失在一层层递归调用中。其实，我们只需要<strong>假设递归函数能够正确返回</strong>，每个步骤和限制条件都是对的，每次调用递归后都能接近限制条件，那么递归函数总是能够正确完成，<strong>不要纠缠于它的执行过程</strong>，这是我们阅读和编写递归函数的精髓。如果实在不放心可以用数学归纳法证明。</p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>函数的参数个数往往是不能确定的，所以 C 语言提供了 stdarg 宏支持可变参数列表。下面以计算平均值为例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdarg.h&gt;float average (int n_values,...){  va_list var_arg;  int count;  float sum=0;  //准备访问可变参数,使用va_start宏，第一个参数是va_list类型，  //第二个参数是可变参数前的第一个参数  va_start(var_arg,n_values);  for(count=0;count&lt;n_values;count++){    //使用va_arg访问参数，第一个参数是va_list类型,第二个参数是可变参数类型    sum+va_arg(var_arg,int);  }  va_end(var_arg);  return sum/n_values;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可变参数宏有两个限制：</p><ul><li>这些宏无法判断实际存在的参数数量。</li><li>这些宏无法判断每个参数的类型。</li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C和指针-指针</title>
      <link href="/2018/10/27/c-he-zhi-zhen-zhi-zhen/"/>
      <url>/2018/10/27/c-he-zhi-zhen-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<p>指针是<code>c</code>语言的精髓，本节介绍指针相关内容。</p><a id="more"></a><h2 id="内存和地址"><a href="#内存和地址" class="headerlink" title="内存和地址"></a>内存和地址</h2><p>由于<code>C</code>语言是比较底层的语言，可以直接操作内存，而指针正是操作内存的利器。我们都知道 RAM 可以抽象为如下标有数字的单元格：<br><img src="mem.png" alt="mem"><br>其中每个位置为一个字节（byte），如果要表示更大的值，那么就会将多个字节合在一起。另一个需要注意的地方是<code>边界对齐</code>，在要求对齐的机器上，整型值存储的起始位置只能在特定的位置，通常是2或者4的倍数。关于内存我们需要注意以下两点：</p><ol><li>内存的每个位置由一个独一无二的地址标识。</li><li>内存的每个位置都包含一个值。</li></ol><p>比如下图所示：<br><img src="mem2.png" alt="mem2.png"><br>每个地址都有值，为了表示整数用了4个地址。如果都有地址引用肯定不方便，要是能用名字引用就好了，就行平时用人名标识某人一样，比用身份证号码方便多了。<br><img src="mem3.png" alt="mem3.png"><br>记住通过变量关联地址是编译器提供的支持，硬件仍然用地址访问内存。</p><h2 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h2><p>对于平时使用的各种变量在内存里面都是一串串 0 1 数字，那么我们怎么判断它的类型呢，其实关键是我们怎么解析和看待它，例如以下内存数据就存在不同的解释：<br><img src="mem4.png" alt="mem4.png"><br>可能的数据类型如下：<br><img src="mem5.png" alt="mem5.png"></p><h2 id="指针变量的内容"><a href="#指针变量的内容" class="headerlink" title="指针变量的内容"></a>指针变量的内容</h2><p>针对如下声明：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a=112,b=-1;float c=3.14;int *d=&amp;a;float *e=&amp;c;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其内存分布如图所示：<br><img src="pointer.png" alt="pointer"><br>其中 <code>d</code> 和 <code>e</code> 的值比较特殊，刚好是 a 和 c 的地址。</p><h2 id="间接访问操作符"><a href="#间接访问操作符" class="headerlink" title="间接访问操作符"></a>间接访问操作符</h2><p>从上面看出，由于指针变量的内容是其他变量的地址，那么我们是不是可以通过指针变量访问和操作其他变量了呢？答案是肯定的，这个访问过程叫做间接访问或者解引用指针，用单目操作符 <code>*</code> 表示。指针变量和其他变量的关系如下图所示：<br><img src="pointer2.png" alt="pointer2"><br>这里有两点需要注意：</p><ol><li>由于每个变量的存储位置事先并不清楚，所以 d e 的值未明确给出。</li><li>d 或 e 用的虚线，因为如果不对指针变量进行间接访问操作，<code>d或e</code> 中仅仅是地址值，要想访问地址对应的值，必须要间接访问操作符。</li></ol><h2 id="未初始化和非法的指针"><a href="#未初始化和非法的指针" class="headerlink" title="未初始化和非法的指针"></a>未初始化和非法的指针</h2><p>有如下代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int *a...*a=12;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上语句的含义是，创建一个名为a的指针变量，并将12 赋值给<strong>a所指向的内存位置</strong>。但是请注意指针变量和其他变量并无区别，如果该指针变量是今天的，则初始化为0，但是变量是自动的，那么根本不会初始化，其值为垃圾值，这种情况下往往会造成“内存错误”、“保护性异常”等，更为严重的是如果这个地址恰巧是合法地址，这可能会引入及其隐蔽的bug。</p><h2 id="NULL-指针"><a href="#NULL-指针" class="headerlink" title="NULL 指针"></a>NULL 指针</h2><p>正是由于上面提到的未初始化指针的危害，标准便定义了 NULL 指针，表明指针未初始化。NULL指针十分有用，比如某个方法正常运行便返回指向某个元素的指针，否则返回NULL指针。不过这儿NULL指针存在“一值多用”的风险，具有两层含义，一是有没有正常运行，二是返回结果。这在软件设计中是个风险，最好的做法是返回一个表明成功或失败的状态值，以及具体结果的值。</p><h2 id="指针、间接访问和左值"><a href="#指针、间接访问和左值" class="headerlink" title="指针、间接访问和左值"></a>指针、间接访问和左值</h2><p>涉及到指针的表达式能不能作为左值呢？其实可以简单判断，如果能够将右值的结果放到左值指定的位置，那么就可以为左值。</p><h2 id="指针、间接访问和变量"><a href="#指针、间接访问和变量" class="headerlink" title="指针、间接访问和变量"></a>指针、间接访问和变量</h2><p>请问如下语句的含义是什么？</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">*&amp;a=25;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>让我们分析下，&amp;a 是取变量a的地址，结果是一个指针常量，* 操作符代表访问操作数表示的地址，该地址就是变量a的地址，所以整个式子的意思就是将a赋值为25 与 <code>a=25</code> 等价。</p><h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p>假设变量a存储于地址100，那么下面的语句作用是什么呢？</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">*100=25<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初看就是将变量a的内容赋值为25，不过语法上间接操作符只能作用于指针类型表达式，那么确实想将25存储于100地址怎么办呢？必须使用强类型转换：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">*(int *)100=25;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>强制将正向转为指向整型的指针，这在语法上是合法的。不过平时极少这么使用，只有在需要通过内存地址访问某个特地位置时会出现。</p><h2 id="指针的指针"><a href="#指针的指针" class="headerlink" title="指针的指针"></a>指针的指针</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a=12;int *b=&amp;a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过前面的介绍，我们已经很熟悉 b 是指针变量，指向变量a：</p><p><img src="p3.png" alt="p3"></p><p>既然指针也是变量，那有没有可能另一个指针指向b呢？即 <code>c=&amp;b</code></p><p><img src="p4.png" alt="p4"></p><p>这似乎是合理的，不过c的类型是什么呢？显然它也是指针，指向的是什么呢？由于变量b是一个指向整型的指针，那么任何指向b的类型便是“指向整型的指针”的指针，即指针的指针。一般用 <code>int **c</code> 声明变量c，表达式 **c 的类型是int，下面列举了一些表达式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a=12;int *b=&amp;a;int **c=&amp;b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们来分析 <code>int **c</code> ，首先 * 具有右结合性，我们必须<strong>由里向外逐层求值</strong>，*c访问的是c指向的位置，即变量b，第二个间接访问符访问变量b指向的地址即a。对应多级指针，我们只需要逐层分析即可。</p><p><img src="p5.png" alt="p5"></p><h2 id="指针表达式"><a href="#指针表达式" class="headerlink" title="指针表达式"></a>指针表达式</h2><p>我们通过以下语句了解指针表达式的各种情况：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char ch='a';char *p=&amp;ch;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="p6.png" alt="p6"></p><p>后续使用表格区分其作为左值和右值的情况。</p><p><img src="p7.png" alt="p7"></p><p>这里注意 &amp;ch 不能作为左值，因为其结果为某个地址值，但是无法知道位于何处，不能表示内存特定位置，所以不合法。</p><p><img src="p8.png" alt="p8"></p><p><img src="p9.png" alt="p9"></p><p><img src="p10.png" alt="p10"></p><p><img src="p11.png" alt="p11"></p><p>这儿注意 * 的优先级高于 + 。</p><p><img src="p12.png" alt="p12"></p><p>!(p13)(p13.png)</p><p>!(p14)(p14.png)</p><p>由于++ 和–操作符使用频繁，有必要掌握其过程，首先++ 操作符是先对cp增加，再返回增加后的结果，而<code>--</code> 操作符是先返回cp的拷贝，再增加cp的值。</p><p><img src="p15.png" alt="p15"></p><p>这里，间接访问操作符作用于增值后的指针拷贝上。</p><p><img src="p16.png" alt="p16"></p><p>由于++操作符高于*，这里涉及到3个步骤：</p><ol><li>++操作符产生cp的拷贝。</li><li>++操作符增加cp的值。</li><li>在cp的拷贝上执行间接访问操作。</li></ol><p><img src="p17.png" alt="p17"></p><p>由于<code>++</code> 和 <code>*</code> 结合性都是从右往左，先执行间接访问操作，再增加cp指向的位置的值。</p><p><img src="p18.png" alt="p18"></p><p><img src="p19.png" alt="p19"><br>其执行步骤为：</p><ol><li>移动cp指针</li><li>取cp对应的值</li><li>增加cp的值</li></ol><p>由于a 后面的值未知，故用问号表示。</p><p><img src="p20.png" alt="p20"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>从字符串数组中查找字符：</p><p><img src="string.png" alt="string"></p><p>版本1：</p><p><img src="string1.png" alt="string1"></p><p>版本2：</p><p><img src="string2.png" alt="string2"></p><p>版本1和2的区别是，版本而由于有副作用，会修改当前字符串字符的指针值，所以只能使用一次。</p><h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><p>指针值可以执行有限的算术运算，指针会根据对应的类型调整。指针运算只有作用于数组才是可以预测的，如果指针指向同一数组元素，它们之间可以相加减。<br>任何指针可以比较，测试其相等或不相等。<br>如果两个指针指向同一数组元素，它们可以执行 <code>&lt; &lt;= &gt; &gt;=</code> 运算.</p><h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><ul><li>错误对未初始化指针变量解引用</li><li>错误对NULL指针解引用</li><li>向函数错误传递NULL指针</li><li>未检测到指针表达式的错误，导致不可预测结果</li><li>对一个指针加减运算，使它指向数组第一个元素以前的内存位置</li></ul><h2 id="编程提示总结"><a href="#编程提示总结" class="headerlink" title="编程提示总结"></a>编程提示总结</h2><ul><li>一个值只有一种意思</li><li>如果指针不指向任何有意义的东西，把它设置为NULL<hr></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C和指针-语句、操作符和表达式</title>
      <link href="/2018/10/27/c-he-zhi-zhen-yu-ju-cao-zuo-fu-he-biao-da-shi/"/>
      <url>/2018/10/27/c-he-zhi-zhen-yu-ju-cao-zuo-fu-he-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<p>本节简要介绍 c 语言的语句、操作符和表达式。</p><a id="more"></a><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>C 语言是词法作用域，包含常规的代码块、 if 语句、while 语句、for 语句、do while 语句，循环语句可以使用 break 提前终止以及使用 continue 进行下一次循环。过多的 if-else 可以用 switch 语句代替，注意每个 case 标签必须是常量表达式。 goto 语句会使程序难以理解和维护，所以很少使用。</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>C 语言操作符较多，以下挑几个重点介绍。</p><h3 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h3><p>左移右边补零，右移分为逻辑移位和算术移位，逻辑移位左边补零，算术移位左边补符号位。</p><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p>sizeof 是操作符，不是函数，它不会对操作数求值。</p><h3 id="下标引用、函数调用和结构成员"><a href="#下标引用、函数调用和结构成员" class="headerlink" title="下标引用、函数调用和结构成员"></a>下标引用、函数调用和结构成员</h3><p>除了优先级不同，下标引用和间接访问表达式等价。 *<em>array[下标]==</em>(array+(下标))**</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>C 语言并不具备布尔类型，使用整数代替，<strong>零是假，任何非零值皆为真</strong>，不好混用整数和布尔值。</p><h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>简单理解，左值是能够出现在赋值符号左边，标识一个可以存储值的位置。</p><h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><p>**一定注意隐式类型转换（有符号数和无符号数转换）带来的 bug **。</p><h2 id="优先级和求值顺序"><a href="#优先级和求值顺序" class="headerlink" title="优先级和求值顺序"></a>优先级和求值顺序</h2><p>为了避免记忆众多表达式优先级，建议使用括号明确区分。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C和指针-数据</title>
      <link href="/2018/10/26/c-he-zhi-zhen-shu-ju/"/>
      <url>/2018/10/26/c-he-zhi-zhen-shu-ju/</url>
      
        <content type="html"><![CDATA[<p>程序对数据进行操作，本节描述C 语言的各种数据类型、特点以及声明。接着介绍变量的三个属性–作用域、链接属性和存储类型，三个属性决定了变量的“可视性”（变量在什么地方使用）和“生命周期”（它的值能保持多久）。</p><a id="more"></a><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>C 语言仅有 4 中基本数据类型–整型、浮点型、指针和聚合型（数组和结构）。</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><h4 id="整型包括字符、短整型、整型和长整型，分为有符号和无符号。"><a href="#整型包括字符、短整型、整型和长整型，分为有符号和无符号。" class="headerlink" title="整型包括字符、短整型、整型和长整型，分为有符号和无符号。"></a>整型包括<strong>字符</strong>、短整型、整型和长整型，分为有符号和无符号。</h4><table><thead><tr><th>类型</th><th>最小范围</th></tr></thead><tbody><tr><td>char</td><td>0-127</td></tr><tr><td>signed char</td><td>-127-127</td></tr><tr><td>unsigned char</td><td>0-255</td></tr><tr><td>short int</td><td>-32767-32767</td></tr><tr><td>unsigned short int</td><td>0-65535</td></tr><tr><td>int</td><td>-32767-32767</td></tr><tr><td>unsigned int</td><td>-32767-32767</td></tr><tr><td>long int</td><td>-2147483647-  2147483647</td></tr><tr><td>unsigned  long int</td><td>0-4294967295</td></tr></tbody></table><p>注意字符本质是小整型值。</p><h4 id="整型字面量"><a href="#整型字面量" class="headerlink" title="整型字面量"></a>整型字面量</h4><p>如果我们用字面量初始化整型时，那么它具体属于那种数据类型呢？这取决于书写方式：</p><ul><li>以 l 或者 L 结尾，长整型。</li><li>字符 U 或者 u ，unsigned整型值。</li><li>0x 十六进制</li><li>单个字符 ‘M’ ‘\n’ 字符常量，int 类型。</li><li>L’x’ 宽字符常量。</li></ul><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>enum Jar_Type{ CUP,PINT,QUART}</p><p>enum Jar_Type milk_jug</p><p>默认从 0 开始，可以指定值。</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>浮点类型缺省为 double 类型，后跟 L 或 l 为 long double，跟 F 或者 f 为 float 类型。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>变量在内存中占据特定的位置，每个内存位置由一个确定的地址引用，指针便是地址的另一个名字。指针也是变量必然存在于内存中，也有一个地址，故存在指针的指针，正式由于指针的无线级联，使得 C 语言可以实现 tree 和 list 等复杂数据结构。<br>一定记住 <strong>指针=地址+类型</strong>，有了地址加上长度才有意义。</p><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><p>C 语言并没有字符串类型，它就是一串以 NULL 结尾的零或者多个字符。能否对字符串常量进行修改，不同的规范存在差异。<br>我们可以将字符串常量赋值给一个“指向字符的指针”，该指针指向字符串的起始地址，以什么结束呢？答案是 ‘\0’ ，不能将字符串常量赋值给字符数组，因为字符串常量的直接值是一个指针，而非字符本身。</p><h2 id="基本声明"><a href="#基本声明" class="headerlink" title="基本声明"></a>基本声明</h2><h4 id="指针声明"><a href="#指针声明" class="headerlink" title="指针声明"></a>指针声明</h4><p>平时声明指针变量时，我们是怎么写的呢？</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int *a 还是 int* a ？<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> int *a 表明 *a 产生的结果是 int ，但是 int* 也可以理解为 a 是 int* 的指针，不过这可能引起误解：<br>int* a,b,c 表明仅有a 是指针，b和c 是 int。</p><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>typedef 作用：</p><ul><li>使得声明更加简短</li><li>便于维护和易读<br>应该使用 typedef 而不是 #define 创建新的类型名，因为：<pre class="line-numbers language-c" data-language="c"><code class="language-c">#define d_ptr_to_char char *d_ptr_to_char a,b //b被声明为一个字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>当涉及到指针变量是，值得注意，有两样东西可能成为常量—-指针变量和它指向的实体。</p><ol><li>int *pi //pi是一个普通的指向整型的指针</li><li>int const  *pci; //指向整型常量的指针，可以修改指针的值，但是不能修改指向的值</li><li>int * const pci; //指向整型的常量指针，指针是常量，其值无法修改，它指向的值可以修改</li><li>int const * const pci;//指针和它指向的值都不能修改</li></ol><p><strong>const 修饰啥，啥就是常量。</strong></p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="代码块作用域"><a href="#代码块作用域" class="headerlink" title="代码块作用域"></a>代码块作用域</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a;//文件作用域int b(int c);//c 具有原型作用域int d(int e){  int f;  int g(int h);  ...  {    int f,g,i //函数作用域  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h2><p>一个程序的不同的源文件的同一个标识符是代表同一个实体还是不同的实体呢？标识符的链接属性正是处理不同文件中出现的标识符。标识符的作用域与它的链接属性有关。链接属性有以下3种：</p><ol><li>external–外部，标识符无论被声明多少次，都是同一个实体。</li><li>intern–内部，同一个文件中多次声明都指的同一个实体。</li><li>none–无，总是被当做独立的实体。</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef char *a;//externalint b;   //externalint c (int d){  int e;  int f (int g);//external  ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>statc 和 extern 可以修改标识符的链接属性。<br>static 可以将缺省为 external 改为 intern 效果，注意只针对缺省为 external的标识符。例如对上面的变量b static int b; 使得变量 b 为该源文件私有。<br>extern 为一个标识符指定 external链接属性，可以在访问其他任何位置定义的这个实体。注意extern只对标识符第一次声明有效，例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">static int i;//为本文件私有int func(){  int j;  extern int k;//k 为其他文件声明的external 变量  extern int i;//第二次无效}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h2><p>变量的存储类型（storage class）值存储变量的内存类型。便利的存储类型决定了变量何时创建、销毁和能保存多久。有三个地方可以存储变量：普通内存、栈和寄存器。</p><ol><li>变量默认类型取决于声明它的位置。</li><li>任何代码块之外的变量存储于静态内存中，称为 static 变量，程序执行期一直存在。</li><li>代码块内部默认是 auto类型，存于栈中。如果加上 static 修饰，则存储类型从自动类型变为静态类型，但是不改变变量的作用域。</li><li>register 存储于寄存器，编译器不一定理睬 register 关键字。</li></ol><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li>静态变量默认初始化为 0。</li><li>对于自动变量如果不显示初始化，默认为垃圾值。</li></ol><h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><p>从上面可以发现，链接属性和存储类型都有 static 关键字，在不同上下文环境，static 关键字具有不同的意思，一定要注意区别。</p><ul><li>函数定义或者代码块之外变量声明，static 用于修饰标识符的链接属性，从 external 改为 internal ，不影响存储类型和<strong>作用域</strong>，只能在声明的源文件访问该标识符。</li><li>代码块内部的变量声明，static 将自动变量修改为静态变量，其链接属性和<strong>作用域</strong>不受影响。变量在程序执行前创建，且执行期间一直存在，代码执行完后销毁。</li></ul><h2 id="作用域、存储类型示例"><a href="#作用域、存储类型示例" class="headerlink" title="作用域、存储类型示例"></a>作用域、存储类型示例</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">int  a=5; //默认全局变量 external   静态内存extern int b; //b 的定义在其他地方，extern非必须   静态内存static int c; //external-&gt;internal 仅在本文件能访问  静态内存int d(int e){  int f=15; //栈中  regiester int b;  static int g=20;//静态内存，一直存在  extern int a; //引用上面的 a  {    int e;    int a;    extern int h;//具有external 属性，静态内存中  }}static int i(){ //该函数只能在该文件被访问  ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>具有external 属性的实体等价于其他语言的全局（global）实体，所有源文件函数都可以访问它。</li><li>非代码块或者函数定义的变量，缺省为external 链接属性。</li><li>在代码块内的变量，extern 修饰后使其引用全局变量。</li><li>external 属性的变量具有静态存储类型。</li></ul><table><thead><tr><th>变量类型</th><th>声明位置</th><th>堆栈</th><th>作用域</th><th>如果声明为 static</th></tr></thead><tbody><tr><td>全局</td><td>所有代码块之外</td><td>否</td><td>声明处到文件尾</td><td>不允许其他文件访问</td></tr><tr><td>局部</td><td>代码块起始处</td><td>是</td><td>整个代码块</td><td>不存于堆栈，其值执行期一直有效</td></tr><tr><td>形参</td><td>函数头部</td><td>是</td><td>函数</td><td>不允许</td></tr></tbody></table><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程 C++ 和 Java 比较-类及其关键概念</title>
      <link href="/2018/10/23/mian-xiang-dui-xiang-bian-cheng-c-he-java-bi-jiao-lei-ji-qi-guan-jian-gai-nian/"/>
      <url>/2018/10/23/mian-xiang-dui-xiang-bian-cheng-c-he-java-bi-jiao-lei-ji-qi-guan-jian-gai-nian/</url>
      
        <content type="html"><![CDATA[<p>OO 编程最重要的概念是类、封装（Encapsulation）、继承（Inheritance）和多态（Polymorphism）。</p><a id="more"></a><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>在面向对象编程中，我们常常需要隐藏类的实现细节，并对类的一些数据成员和成员函数的访问进行控制，即封装。使用适当的数据封装，我们可以对每个对象向它的客户展示定义良好的公共接口。<br>另外两个概念—多态和继承则依赖于我们能够在程序中建立一个类层次体系。继承允许一个子类从它的超类继承部分或者全部数据成员和成员函数，便于扩展。<br>多态允许我们通过一个在根类中定义的公共接口操纵属于一个类层次体系中的不同类对象，这极大的提高了编程效率，增强程序扩展性，使得程序更加通用。</p><h2 id="在-c-中定义类"><a href="#在-c-中定义类" class="headerlink" title="在 c++ 中定义类"></a>在 c++ 中定义类</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;using namespace std;/*class User{    string name;    int age;public:    User(string str,int yy)    {        name = str;        age = yy;    }    void print()    {        cout &lt;&lt; "name:" &lt;&lt; name &lt;&lt; " age:" &lt;&lt; age &lt;&lt; endl;    }};*/class User{    string name;    int age;public:    User(string str, int yy);    void print();};User::User(string str,int yy):name(str),age(yy){    /*name = str;    age = yy;*/}void User::print(){    cout &lt;&lt; "name:" &lt;&lt; name &lt;&lt; " age:" &lt;&lt; age &lt;&lt; endl;}class StudentUser:public User{    string schoolEnrolled;public:    StudentUser(string nam,int y,string school):User(nam,y)    {        schoolEnrolled = school;    }    void print()    {        User::print();        cout &lt;&lt; "school enrolled:" &lt;&lt; schoolEnrolled &lt;&lt; endl;    }};int  main_class(int argc, char* argv[]){    //栈上初始化，离开作用域自动释放    User u("liao", 28);    u.print();    //堆上创建    User *p = new User("liao", 28);    p-&gt;print();    //调用析构函数，显示释放    delete p;    StudentUser *sp = new StudentUser("ll", 24, "cqu");    sp-&gt;print();    cin.get();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>User u("liao", 28); </code> 是在栈上为新对象分配内存，当变量离开它的作用域后，内存会自动释放。<br><code>User *p = new User("liao", 28);</code> 操纵符 new 在堆上为新对象分配内存并返回一个指向这块内存的指针。释放时需要调用 delete 操作符显示释放。<br>同时 c++ 允许将类的实现代码放在类定义的外部，不过需要用作用域分解符修饰。</p><h2 id="java-中定义类"><a href="#java-中定义类" class="headerlink" title="java 中定义类"></a>java 中定义类</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">package ll.chapter03;/** * Created by liaoli * date: 2018/10/23 * time: 11:50 */public class User {    private String name;    private int age;    public User(String name, int age) {        this.name = name;        this.age = age;    }    public void print(){        System.out.println("name: "+name+ " age:"+age);    }    public static void main(String[] args) {        User u=new User("ll",27);        u.print();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建对象：C-和-Java的异同"><a href="#创建对象：C-和-Java的异同" class="headerlink" title="创建对象：C++ 和 Java的异同"></a>创建对象：C++ 和 Java的异同</h2><p><img src="c++vsjava.png" alt="c++vsjava"></p><p>从上图可以看出 c++ 的方式2和 java 构造方式有些相似，那么java中的引用与 c++ 的指针是相同的吗？事实上他们相似但并不相同。 java 中由于内存管理可能将 User 对象移动到内存的不同位置，但是 q 仍然能够找到该对象。反之，如果 p 所指向的对象转移到内存中不同位置，那么 p 的值需要显示修改。</p><h2 id="c-中的子类"><a href="#c-中的子类" class="headerlink" title="c++ 中的子类"></a>c++ 中的子类</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;using namespace std;/*class User{    string name;    int age;public:    User(string str,int yy)    {        name = str;        age = yy;    }    void print()    {        cout &lt;&lt; "name:" &lt;&lt; name &lt;&lt; " age:" &lt;&lt; age &lt;&lt; endl;    }};*/class User{    string name;    int age;public:    User(string str, int yy);    void print();};User::User(string str,int yy):name(str),age(yy){    /*name = str;    age = yy;*/}void User::print(){    cout &lt;&lt; "name:" &lt;&lt; name &lt;&lt; " age:" &lt;&lt; age &lt;&lt; endl;}class StudentUser:public User{    string schoolEnrolled;public:    StudentUser(string nam,int y,string school):User(nam,y)    {        schoolEnrolled = school;    }    void print()    {        User::print();        cout &lt;&lt; "school enrolled:" &lt;&lt; schoolEnrolled &lt;&lt; endl;    }};int  main_class(int argc, char* argv[]){    //栈上初始化，离开作用域自动释放    User u("liao", 28);    u.print();    //堆上创建    User *p = new User("liao", 28);    p-&gt;print();    //调用析构函数，显示释放    delete p;    StudentUser *sp = new StudentUser("ll", 24, "cqu");    sp-&gt;print();    cin.get();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我们演示 C++ 程序的多态性，但需要满足以下两个条件：</p><ol><li>对象通过指针或者引用操纵。</li><li>期望产生多态的函数必须声明为虚函数。<br>如下所示：<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;using namespace std;/*class User{string name;int age;public:User(string str,int yy){ name = str; age = yy;}void print(){ cout &lt;&lt; "name:" &lt;&lt; name &lt;&lt; " age:" &lt;&lt; age &lt;&lt; endl;}};*/class User2{ string name; int age;public: User2(string str, int yy); virtual void print();};User2::User2(string str, int yy){ name = str; age = yy;}void User2::print(){ cout &lt;&lt; "name:" &lt;&lt; name &lt;&lt; " age:" &lt;&lt; age &lt;&lt; endl;}class StudentUser :public User2{ string schoolEnrolled;public: StudentUser(string nam, int y, string school) :User2(nam, y) {     schoolEnrolled = school; } void print() override {     User2::print();     cout &lt;&lt; "school enrolled:" &lt;&lt; schoolEnrolled &lt;&lt; endl; }};int  main(int argc, char* argv[]){ User2* users[3]; users[0] = new User2("a", 33); users[1] = new StudentUser("c", 33,"cqu"); users[2] = new User2("b", 33); for(int i=0;i&lt;3;i++) {     users[i]-&gt;print();     cout &lt;&lt; endl; } delete[]users; cin.get(); return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>由于3个 对象通过 new 操纵符分配内存，所以这个程序存在内存泄漏，我们可以调用 delete[] users 释放内存。</p><h2 id="在-Java-中定义子类"><a href="#在-Java-中定义子类" class="headerlink" title="在 Java 中定义子类"></a>在 Java 中定义子类</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">package ll.chapter03;/** * Created by liaoli * date: 2018/10/23 * time: 21:58 */public class InheritUser {    private String name;    private int age;    public InheritUser(String name, int age) {        this.name = name;        this.age = age;    }    public void print(){        System.out.println("name:"+name+" age:"+age);    }}package ll.chapter03;/** * Created by liaoli * date: 2018/10/23 * time: 21:59 */public class InheritStudentUser extends User {    private String schoolEnrolled;    public InheritStudentUser(String nam,int y,String sch){        super(nam,y);        schoolEnrolled=sch;    }    public void print(){        super.print();        System.out.println("  school:"+schoolEnrolled);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>java 与 c++ 继承差异如下：<br><img src="c++vsjavainheritclass.png" alt="c++vsjavainheritclass"></p><h2 id="阻断继承"><a href="#阻断继承" class="headerlink" title="阻断继承"></a>阻断继承</h2><p>java 程序可以通过在方法或者类前面加 final 阻止其被继承或覆盖，c++ 没有提供类似关键字，不过可以通过将构造函数声明为 private 实现同样效果。</p><h2 id="创建对象的打印表示形式"><a href="#创建对象的打印表示形式" class="headerlink" title="创建对象的打印表示形式"></a>创建对象的打印表示形式</h2><p>java 程序可以通过 toString 方法表示对象的字符串表示形式， c++ 可以重载类的输出操作符。</p><h2 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class DestX{};class DestY{    DestX* p;public:    DestY(DestX* q):p(new DestX(*q)){}    ~DestY() { delete p; }};int  main(int argc, char* argv[]){    DestX * px = new DestX();    DestY y(px);    delete px;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++ 中，当对象离开作用域后，它的析构函数会被调用，从而销毁该对象。如果没有显示提供析构函数，那么系统在销毁对象是会调用析构函数默认行为，即依次调用类的每个数据成员的析构函数，对基本类型就是释放所占的内存。<br>上述程序 DestY 缺省的析构函数只会释放p所占的4个字节内存，p所指向的内存并不会得到释放。</p><p>java 的对象销毁与 C++ 存在非常大的不同， java是通过垃圾收集回收内存。</p><h2 id="Java-的程序包"><a href="#Java-的程序包" class="headerlink" title="Java 的程序包"></a>Java 的程序包</h2><p>java 的程序是通过包进行命令空间隔离，并且每个类名必须与文件名一致，且一个文件对应一个公共类。</p><h2 id="C-的命名空间"><a href="#C-的命名空间" class="headerlink" title="C++ 的命名空间"></a>C++ 的命名空间</h2><p>命名空间的基本语法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">namespace ModuleName{  //代码  void foo(){};}void foo(){}int main(){  using namespace ModuleName;  foo();//错误，foo 出现冲突  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="using-声明和-using-指令"><a href="#using-声明和-using-指令" class="headerlink" title="using 声明和 using 指令"></a>using 声明和 using 指令</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">using namespace module;//using 声明using modele::X// using 指令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>使用 using 指令导致该名称空间的所有名字在当前作用域可见，而using 声明相当于在当前作用域声明一个名字空间中的一个特定名字。</strong></p><h3 id="名字空间的引入"><a href="#名字空间的引入" class="headerlink" title="名字空间的引入"></a>名字空间的引入</h3><p>如果一个名字空间被引入另一个名字空间，前者的成员可以认为是后者的成员名。</p><h3 id="using-声明和using指令的作用域"><a href="#using-声明和using指令的作用域" class="headerlink" title="using 声明和using指令的作用域"></a>using 声明和using指令的作用域</h3><p>using 声明和指令拥有块级作用域。</p><h3 id="嵌套名字空间和别名"><a href="#嵌套名字空间和别名" class="headerlink" title="嵌套名字空间和别名"></a>嵌套名字空间和别名</h3><p>名字空间可以嵌套和起别名。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;namespace N1{    typedef int Type;    namespace N2    {        typedef int* Type;        namespace N3        {            typedef string Type;            namespace N4            {                typedef string *Type;            }        }    }}int  main(int argc, char* argv[]){    using namespace N1;    Type x = 19;    cout &lt;&lt; x &lt;&lt; endl;    N1::N2::Type p = &amp;x;    cout &lt;&lt; *p &lt;&lt; endl;    N1::N2::N3::Type str("hello");    cout &lt;&lt; str &lt;&lt; endl;    N1::N2::N3::N4::Type q = &amp;str;    cout &lt;&lt; *q &lt;&lt; endl;    namespace N_Four = N1::N2::N3::N4;    N_Four::Type ptr = &amp;str;    cout &lt;&lt; *ptr &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="无名字空间"><a href="#无名字空间" class="headerlink" title="无名字空间"></a>无名字空间</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">namespace{  int buffer;  class X;}//等价于namespace ---UNIQUE_NAME---{  int buffer;  class X;}using namespace ---UNIQUE_NAME---;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h2><p>C++ 拥有 private,protect,public 访问级别，java 还有默认的package 访问级别，不过 c++ 中类的私有成员可以被类的友元（friend）访问。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class Y;class X{    int m;    int n;public:    X(int mm, int nn) { m = mm, n = nn; }    friend Y;    friend void print(X*);};class Y{    X *x;    int t;public:    Y(X*xobj)    {        x = xobj;        t = x-&gt;m + x-&gt;n;    }    int get_t()    {        return t;    }};void print(X *ptr){    cout &lt;&lt; ptr-&gt;m &lt;&lt; " " &lt;&lt; ptr-&gt;n &lt;&lt; endl;}int main(int argc, char* argv[]){    X *ptr = new X(110, 222);    Y y(ptr);    cout &lt;&lt; y.get_t() &lt;&lt; endl;    print(ptr);    cin.get();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><p>抽象类在 java 和 c++ 中是相同的，不过 java 还有一种抽象类的变型，接口。<br>我们无法根据抽象类创建对象，那么抽象类有什么意义呢？</p><ol><li>抽象类可以在类层次体系中组织其他类的作用。</li><li>抽象类可以让我们以增量的方式创建类的实现代码。</li></ol><p>C++ 中抽象类：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Shape{public:  virtual double area()=0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Java 中抽象类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">abstract class Shape{  abstract public  double area();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>java 引入接口的目的是避免 C++ 多继承的复杂性，而保留多继承的优点。如下图所示：<br><img src="javainherit.png" alt="javainherit"></p><p>java 接口语法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface Collection{  public boolean add(Object o);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h2><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> C++ </category>
          
          <category> OOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程 C++ 和 Java 比较-IO比较</title>
      <link href="/2018/10/23/mian-xiang-dui-xiang-bian-cheng-c-he-java-bi-jiao-io-bi-jiao/"/>
      <url>/2018/10/23/mian-xiang-dui-xiang-bian-cheng-c-he-java-bi-jiao-io-bi-jiao/</url>
      
        <content type="html"><![CDATA[<p>本章以 C 语言为背景以及 C++ 和 Java的基础结构建立联系。</p><a id="more"></a><h2 id="简单程序：对一个整型数组求和"><a href="#简单程序：对一个整型数组求和" class="headerlink" title="简单程序：对一个整型数组求和"></a>简单程序：对一个整型数组求和</h2><p>c 程序如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">/*AddArray1.c*/#include&lt;stdio.h&gt;int addArray(int[], int);int main(int argc, char* argv[]){    int data[] = { 4,3,2,1,0,5,6,7,8,9 };    //size 返回数组大小，在32位机器为4，为了可移植性    const int size = sizeof(data) / sizeof(data[0]);    //data 为数组名，传递的是地址    printf("sum of %d\n", addArray(data, size));    getchar();}/** * 对数组a求和 */int addArray(int a[], int n){    int sum = 0;    for(int i = 0;i&lt;n;i++)    {        sum += a[i];    }    return sum;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>addArray 函数采用指针方式和数组本质上是等价的，如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">/*AddArray2.c*/#include&lt;stdio.h&gt;int addArray2(int *a, int);int main(int argc, char* argv[]){    int data[] = { 4,3,2,1,0,5,6,7,8,9 };    //size 返回数组大小，在32位机器为4，为了可移植性    const int size = sizeof(data) / sizeof(data[0]);    //data 为指针，传递的是地址    printf("sum of %d\n", addArray2(data, size));    getchar();}/*** 对数组a求和*/int addArray2(int *a, int n){    int sum = 0;    for (int i = 0; i&lt;n; i++)    {        sum += *a++;    }    return sum;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相同版本的 C++ 程序如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">//AddArray.cc#include &lt;iostream&gt;//命名空间using namespace std;int addArray3(int *, int);int  main_AddArray(int argc, char* argv[]){    int data[] = { 4,3,2,1,0,5,6,7,8,9 };    //size 返回数组大小，在32位机器为4，为了可移植性    const int size = sizeof(data) / sizeof(data[0]);    cout &lt;&lt; "c++ version:sum is "        &lt;&lt; addArray3(data, size) &lt;&lt; endl;    cin.get();    return 0;}int addArray3(int* a, int n){    int sum = 0;    for (int i = 0; i &lt; n; i++)        sum += *a++;    return sum;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相同版本的 java 程序：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package ll.chapter02;/** * Created by liaoli * date: 2018/10/23 * time: 19:31 */public class AddArray {    public static void main(String[] args) {        int[]data={0,2,3,4,6,4,5,45,4,54,5};        System.out.println("The sum of data is "+addArray(data));    }    public static int addArray(int[]a){        int sum=0;        for(int i=0;i&lt;a.length;i++){            sum+=a[i];        }        return sum;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单程序：终端IO"><a href="#简单程序：终端IO" class="headerlink" title="简单程序：终端IO"></a>简单程序：终端IO</h2><p>用户输入数字序列，用程序求序列和，如下序列：</p><p>####4####45###44######6#45Enter</p><p>c 程序如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">//termio.c#include&lt;stdio.h&gt;int  main_TermIO(int argc, char* argv[]){    int i = 0;    char ch;    printf("Enter a sequence of integers: ");    int sum = 0;    while (scanf_s("%d", &amp;i) == 1)    {        sum += i;        while ((ch=getchar())==' ')            ;        if (ch == '\n')break;        ungetc(ch, stdin);    }    printf("The sum of the integers is:%d\n", sum);    getchar();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>c 语言输入格式化函数 <code>scanf</code> 使用比较繁琐，细节较多且易出错。一定要掌握其原理，scanf 工作过程是键盘输入首先进入键盘缓冲区，当输入enter时，再将键盘缓存区内容输入到stdin流的内部缓存区，scanf 从内部缓存区根据格式解析数据，输入队列中都是字符；%c 逐字符解析 %s 以空白为分割;可以用getchar或者fflush清空缓冲区。</p><p>对应的 c++ 程序如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;int main_TermIO2(){    int sum = 0;    cout &lt;&lt; "Enter a sequence of integers:";    int i;    while (cin&gt;&gt;i)    {        sum += i;        while (cin.peek()==' ')        {            cin.get();        }        if(cin.peek()=='\n')break;    }    cout &lt;&lt; "SUM IS " &lt;&lt; sum &lt;&lt; endl;    cin.get();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出 c++ 输入模块更加简单、易用。<br>相应的 java 版本：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package ll.chapter02;/** * Created by liaoli * date: 2018/10/23 * time: 19:40 */public class TermIO {    static boolean newline;    public static void main(String[] args) {        int sum=0;        System.out.println("Enter a sequence of integer:");        while (newline==false){            String str=readString();            if(str!=null){                int i=Integer.parseInt(str);                sum+=i;            }        }        System.out.println("Sum of the numbers is "+sum);    }    public static String readString(){        String word="";        try {            int ch;            while ((ch=System.in.read())==' ')                ;            if(ch=='\n'){                newline=true;                return null;            }            word+=(char)ch;            while ((ch=System.in.read())!=' '&amp;&amp;                ch!='\n'){                word+=(char)ch;            }            if(ch=='\n')newline=true;        }catch (Exception e){        }        return word;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单程序：IO文件"><a href="#简单程序：IO文件" class="headerlink" title="简单程序：IO文件"></a>简单程序：IO文件</h2><p>现在实现将一个文件拷贝到另一个文件，文件可以是文本文件也可以是二进制文件。<br>c 语言版本如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char* argv[]){    FILE *in, *out;    int ch;    if(argc!=3)    {        fprintf(stderr, "usage:copy in_file out_file\n");        exit(EXIT_FAILURE);    }    if((in=fopen(argv[1],"rb"))==NULL)    {        fprintf(stderr, "can't open %s\n", argv[1]);        exit(EXIT_FAILURE);    }    if((out=fopen(argv[2],"wb"))==NULL)    {        fprintf(stderr, "can't open %s\n", argv[2]);        fclose(in);        exit(EXIT_FAILURE);    }    while ((ch=getc(in))!=EOF)    {        if(putc(ch,out)==EOF)        {            break;        }    }    if(ferror(in))    {        printf("Error while reading source file.\n");    }    if(ferror(out))    {        printf("Error while writing into dest file.\n");    }    fclose(in);    fclose(out);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>c 语言实现文件拷贝需要警惕打开文件异常以及文件关闭，特别是异常情况下。<br>让我看下 c++ 实现方案：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;fstream&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;void print_error(const char*, const char* = "");int  main(int argc, char* argv[]){    if(3!=argc)    {        print_error("usage:copy source dest");    }    ifstream in(argv[1], ios::binary);    if(!in)    {        print_error("can't open ", argv[1]);    }    ofstream out(argv[2], ios::binary);    if(!out)    {        print_error("can't open ", argv[2]);    }    char ch;    while (in.get(ch))    {        out.put(ch);    }    if(!in.eof())    {        print_error("something wrong happend");    }    return 0;}void print_error(const char* p, const char* p2){    cerr &lt;&lt; p &lt;&lt; ' ' &lt;&lt; p2 &lt;&lt; '\n';    exit(1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>c++ 相对于 c 来说，免去了手动关闭文件流的操作，当流对象离开作用域后，将调用析构函数自动释放资源。<br>下面是相应的 java 程序：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package ll.chapter02;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;/** * Created by liaoli * date: 2018/10/23 * time: 20:39 */public class FileCopy {    public static void main(String[] args) {        int ch=0;        FileInputStream in=null;        FileOutputStream out=null;        if(args.length!=2){            System.err.println("usage: java FileCopy source dest");            System.exit(0);        }        try {            in=new FileInputStream(args[0]);            out=new FileOutputStream(args[1]);            while (true){                ch=in.read();                if(ch==-1)break;                out.write(ch);            }            out.close();            in.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>java 的异常处理能够将正常流程与异常流程清晰的区分开，使得程序逻辑更加清晰，低版本 java 程序任然需要手动关闭流对象，不过 java8 可以使用 try-with-resources 简化文件关闭。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> C++ </category>
          
          <category> OOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程 C++ 和 Java 比较-OO编程的共性</title>
      <link href="/2018/10/22/mian-xiang-dui-xiang-bian-cheng-c-he-java-bi-jiao-oo-bian-cheng-de-gong-xing/"/>
      <url>/2018/10/22/mian-xiang-dui-xiang-bian-cheng-c-he-java-bi-jiao-oo-bian-cheng-de-gong-xing/</url>
      
        <content type="html"><![CDATA[<p>在学习编程语言时，我们往往独立的某一门语言，如果能够将不同的语言对比学习，不仅能加深印象、理解其区别，也更容易理解其本质。在网络上对比 java 和 C++ 的资料大多很笼统，能够详细论述其差异的书籍并不多，本书虽然年代久远，其思想却值得我们学习。</p><a id="more"></a><h2 id="什么是面向对象编程"><a href="#什么是面向对象编程" class="headerlink" title="什么是面向对象编程"></a>什么是面向对象编程</h2><p>在面向对象编程出现以前，比较流行的是类似与 c 语言一样的过程性编程语言。随着软件复杂度的提升，过程性语言越来越力不从心，本着更加抽象和模块化的诉求，便产生了面向对象的语言。大型面向对象程序的基本思想是把大型软件看成是有众多对象组成的社会，对象拥有足够的只能，能够理解其他对象发来的消息，并作出反应，对象能够从高层对象继承属性和行为。</p><h2 id="OO-的优点和掌握"><a href="#OO-的优点和掌握" class="headerlink" title="OO 的优点和掌握"></a>OO 的优点和掌握</h2><p>OO 最重要的特征 便是 <strong>封装、继承和多态</strong>  。虽然核心思想一致，不过不同语言对其实现形式却不同，如 C++ 允许多继承，这往往会增加复杂度， java 通过接口间接实现了多继承，同时保证了简洁性。<br>那我们应该怎样学习 OO 呢？</p><ol><li>精通一种 <code>元</code> 语言，如 UML 它允许我们在概念层次可视化描述我们的设计方案。</li><li>学习设计模式，如 23 种设计模式。</li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> C++ </category>
          
          <category> OOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统概念与设计-分布式系统特征</title>
      <link href="/2018/10/22/fen-bu-shi-xi-tong-gai-nian-yu-she-ji-fen-bu-shi-xi-tong-te-zheng/"/>
      <url>/2018/10/22/fen-bu-shi-xi-tong-gai-nian-yu-she-ji-fen-bu-shi-xi-tong-te-zheng/</url>
      
        <content type="html"><![CDATA[<p>现代生活使用的绝大多数信息服务，背后都离不开分布式系统。那么分布式系统有什么特征呢？</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>分布式系统是其组件分布在连网的计算机上，组件之间通过传递消息进行通信和动作协调的系统。分布式系统具有以下特征：</p><ol><li>并发：在计算机网络中，并发行为是常见的行为。网络中各个节点都可以操作，对共享资源的并发执行程序的协调是分布式系统的重点。</li><li>缺乏全局时钟：在本地计算机我们可以通过时钟来区分操作序列的先后顺序，但分布式系统通过消息来传递信息，各个计算机的时钟同步是不精确的，即没有一个全局的正确时间。</li><li>故障独立性：我们在设计计算机系统时往往考虑了可能的故障。但是分布式系统往往会带来新的故障，如网络故障、程序崩溃等等，系统的每个组件都可能会出现故障，而其他组件仍然正常运行。</li></ol><h2 id="分布式系统的趋势"><a href="#分布式系统的趋势" class="headerlink" title="分布式系统的趋势"></a>分布式系统的趋势</h2><p>分布式系统正在经历巨大变化。</p><ol><li>泛在联网和现代互联网，互联网或许是我们最熟悉的分布式系统。</li><li>移动和无处不在计算，随着各种手持设备、穿戴设备和物联网的普及，移动计算也是一个热门的研究领域。</li><li>分布式多媒体，在线播放和直播。</li><li>分布式计算作为公共设施，云计算。<h2 id="关注资源共享"><a href="#关注资源共享" class="headerlink" title="关注资源共享"></a>关注资源共享</h2></li></ol><p>许多分布式系统都可以用客户和服务器交互的形式构造。</p><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>随着分布式系统的应用范围和规模的扩展，可能会遇到各种挑战。</p><h3 id="异构性"><a href="#异构性" class="headerlink" title="异构性"></a>异构性</h3><p>分布式系统在网络、计算机硬件、操作系统、编程语言以及软件都有可能存在差异，那么怎么才能屏蔽这些差异呢？答案是遵循相同的标准。</p><p>从软件层次来讲，中间件提供了一个抽象层，屏蔽了底层网络、硬件、操作系统和编程语言的异构性。比如 CORBA , RMI 等。除了解决异构性，中间件还为服务器和分布式应用程序提供了一致的计算模型。包括远程对象调用、远程事件通知、远程 SQL 访问和分布式事务处理等。</p><p>从代码层面来讲，移动代码也能在某种程度屏蔽异构性，如 java 字节码都能运行在任何支持的虚拟机上。</p><h3 id="开放性"><a href="#开放性" class="headerlink" title="开放性"></a>开放性</h3><p>计算机系统的开放性是决定系统能否以不同的方式被扩展和重新实现的特征。分布式系统的开放性取决于新的资源共享服务被增加和供多种客户使用的程度。开放的分布式系统具有以下特征：</p><ol><li>发布关键接口以及接口的标准化。</li><li>基于一致的通信机制和发布接口访问共享资源。</li><li>仔细验证和测试每个组件和发布的标准之间的一致性。</li></ol><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>信息资源的安全性包括机密性（防止泄露）、完整性（防止被篡改）和可用性（防止对资源访问的干扰）。</p><h3 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h3><p>分布式系统的关键就是良好的可伸缩性，但是也面临以下挑战：</p><ol><li>控制物理资源的开销：一台机器能够满足 20 个用户，两台机器未必能满足 40 个用户的请求。</li><li>控制性能损失：随着数据集越来越多，数据的管理势必带来性能损失，我们需要采用更好的算法和数据结构。</li><li>避免性能瓶颈：随着分布式系统节点越来越多，我们要防止短板的出现，避免某些节点成为性能瓶颈。</li></ol><h3 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h3><p>分布式系统节点众多，不可避免会出现很多故障，分布式系统的故障处理相当困难。一般有以下处理技术：</p><ol><li>检查故障：如果能提前检测到故障，便有助于减轻故障的扩散。</li><li>掩盖故障：有些被检测到的故障能隐藏或者降低它的严重程度。如消息不可达时重传，将消息写入两个磁盘。</li><li>容错：当某个节点不能工作时，将任务调度到其他节点。</li><li>故障恢复：恢复涉及软件设计，以便在服务器崩溃后，永久的数据能够恢复或者回滚。通常，出现错误时，程序完成的计算是不完整的，被更新的数据可能处于不一致的状态。</li><li>冗余：利用冗余组件，服务可以实现容错。</li></ol><h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><p>分布式系统中，服务和应用都可能被客户共享使用，怎么保证共享资源在并发环境操作正确十分重要。</p><h3 id="透明性"><a href="#透明性" class="headerlink" title="透明性"></a>透明性</h3><p>透明性指系统应该是一个整体，而不是独立的组件集合，对用户和应用程序员屏蔽分布式系统组件的分离性。</p><p>一般包含以下几种透明性：</p><ul><li>访问透明性：用相同的操作访问本地和网络资源。</li><li>位置透明性：不需要知道资源的物理或者网络位置。</li><li>并发透明性：多个进程并发访问共享资源而互不干扰。</li><li>复制透明性：使用资源的多个实例提升可靠性和性能，用户和程序员无需知道副本的相关信息。</li><li>故障透明性：屏蔽错误，无论是硬件或者软件故障，用户的任务都能完成。</li><li>移动透明性：资源和客户能够在系统内移动而不会影响操作。</li><li>性能透明性：当负载变化时，能重新配置提高性能。</li><li>伸缩透明性：系统和应用能够扩展而不改变系统结构和算法。</li></ul><p>其中最重要的是访问透明性和位置透明性，它们对分布式资源的利用有很大影响，统称为网络透明性。</p><h3 id="服务质量"><a href="#服务质量" class="headerlink" title="服务质量"></a>服务质量</h3><p>服务质量一般指系统的主要非功能特征，即影响客户和用户体验的服务质量的特性，如可靠性、安全性和性能。事实上，缩写 QoS 用于指系统满足一定的截止时间的能力。每个关键性资源必须达到一定的 QoS 要求。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法与数据结构之动态规划-1</title>
      <link href="/2018/10/08/suan-fa-yu-shu-ju-jie-gou-zhi-dong-tai-gui-hua-1/"/>
      <url>/2018/10/08/suan-fa-yu-shu-ju-jie-gou-zhi-dong-tai-gui-hua-1/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>##<br>##<br>##</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> DP </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>An Introduction to Scheme and its Implementation--Introduction</title>
      <link href="/2018/10/06/an-introduction-to-scheme-and-its-implementation-introduction/"/>
      <url>/2018/10/06/an-introduction-to-scheme-and-its-implementation-introduction/</url>
      
        <content type="html"><![CDATA[<pre><code>本章主要介绍 `scheme` 的基本特点与语法。</code></pre><a id="more"></a><h2 id="What-is-Scheme"><a href="#What-is-Scheme" class="headerlink" title="What is Scheme?"></a>What is Scheme?</h2><p><code>scheme</code> 作为 <code>Lisp</code> 的一个变种，具有以下特点：</p><ol><li>词法作用域、块结构和动态类型的函数式编程语言。</li><li><code>First-class procedures</code> 和  <code>First-class continuations</code> 的特点，其中 <code>First-class xx</code> 指 <code>xx</code> 可以同时作为参数传递和返回值。</li><li>参数是以值传递，所有的值都是引用。</li><li>具有强大的 <code>宏</code> ，能够实现语法变换。</li></ol><p><code>scheme</code> 语法定义十分简单，通过 <code>scheme</code> 的学习让我们更加清晰的了解程序语言的本质。</p><h2 id="Basic-Scheme-Features"><a href="#Basic-Scheme-Features" class="headerlink" title="Basic Scheme Features"></a>Basic Scheme Features</h2><h3 id="Code-Consists-of-Expressions"><a href="#Code-Consists-of-Expressions" class="headerlink" title="Code Consists of Expressions"></a>Code Consists of Expressions</h3><h4 id="Parenthesized-Prefix-Expressions"><a href="#Parenthesized-Prefix-Expressions" class="headerlink" title="Parenthesized Prefix Expressions"></a>Parenthesized Prefix Expressions</h4><p><code>scheme</code> 代码是由带括号的前缀表达式组成，前缀表达式初看与我们日常习惯相悖，比如其他语言的 <code>3+5</code> 在 <code>scheme</code> 中变成了 <code>(+ 3 5)</code> ，但是带括号的前缀表达式却让 <code>+ - / *</code> 等运算符与过程调用完美的统一了，并且避免了运算的优先级歧义，更能体现计算的本质。</p><h3 id="Expressions-Return-Values-But-May-Have-Side-Effects"><a href="#Expressions-Return-Values-But-May-Have-Side-Effects" class="headerlink" title="Expressions Return Values, But May Have Side-Effects"></a>Expressions Return Values, But May Have Side-Effects</h3><p><code>scheme</code> 表达式同时具有表达式和语句的特点，既能返回值也能产生副作用。 <code>(set! foo 3)</code> 等价于 <code>c</code> 语言的    <code>foo=3</code> 。函数式编程推崇无副作用操作，所以产生副作用的操作后都有感叹号。</p><h4 id="Defining-Variables-and-Procedures"><a href="#Defining-Variables-and-Procedures" class="headerlink" title="Defining Variables and Procedures"></a>Defining Variables and Procedures</h4><p>在 <code>scheme</code> 中定义变量的方式为 <code>(define foo 5)</code> ，其中 <code>define</code> 做了以下三件事：</p><ol><li>在作用域中声明了一个 <code>foo</code> 变量。</li><li><code>scheme</code> 给 <code>foo</code> 变量分配存储空间，该过程称为 <code>绑定</code> ，将变量绑定到某个内存地址，通过变量引用该内存区域。</li><li>将 <code>foo</code> 引用的内存初始化为 <code>5</code> 。</li></ol><p>** <code>scheme</code> 中一切值都是指向对象的指针**。</p><p><code>foo</code> 变量也可以指向过程：</p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">(define (foo)    15)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="var.png" alt="var"></p><h4 id="Most-Operators-are-Procedures-vs-Special-Forms"><a href="#Most-Operators-are-Procedures-vs-Special-Forms" class="headerlink" title="Most Operators are Procedures vs Special Forms"></a>Most Operators are Procedures vs Special Forms</h4><p>在传统语言中 <code>a+b</code> 是一个表达式，而 <code>scheme</code> 中却是过程调用，由于函数在 <code>scheme</code> 中是一等公民，所以 <code>Scheme</code> 中绝大多数的表达式都是过程组成的。但是有少部分语法是 <code>特殊形式</code> ，如 <code>define</code> <code>set!</code> 等，当解释器看到特殊形式的语法时，会特殊处理。特殊形式包含以下几个方面：</p><ol><li>结构控制如 <code>if</code> <code>cond</code> <code>and</code> 等。</li><li><code>define</code></li><li>本地变量定义如 <code>let</code> 及其变种 <code>letrec</code> <code>let*</code></li><li>循环构造， <code>do</code> <code>named let</code></li><li><code>quote</code> 和 <code>quasiquote</code> ，可以以文本字面量书写复杂数据结构</li><li><code>lambda</code></li><li><code>macros</code></li></ol><h4 id="Control-Structures-are-Expressions"><a href="#Control-Structures-are-Expressions" class="headerlink" title="Control Structures are Expressions"></a>Control Structures are Expressions</h4><p>由于 <code>scheme</code> 中控制结构也是表达式，所以 <code>scheme</code> 没有传统程序的 <code>return</code> 语句，表达式的值作为过程的返回值，如果返回值不需要可以忽略。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int min(int a, int b){   if (a &lt; b)      return a;   else      return b;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">(define (min a b)  (if (&lt; a b)      a      b))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="The-Boolean-Values-t-and-f"><a href="#The-Boolean-Values-t-and-f" class="headerlink" title="The Boolean Values #t and #f"></a>The Boolean Values #t and #f</h3><p>前面说了在 <code>scheme</code> 中一切值都是指向对象的指针，所以 <code>scheme</code> 提供了两个唯一的对象表示真值和假值。<code>false object</code> 和 <code>c</code> 语言中的 <code>0</code> 是不一样的，也不同于 <code>lisp</code> 中的空指针，它代表一个独一无二的对象。</p><h3 id="Some-Other-Control-Flow-Constructs-cond-and-and-or"><a href="#Some-Other-Control-Flow-Constructs-cond-and-and-or" class="headerlink" title="Some Other Control-Flow Constructs: cond, and, and or"></a>Some Other Control-Flow Constructs: cond, and, and or</h3><p>为了更加方便的写代码，<code>scheme</code> 为我们提供了类似与 <code>switch case</code> 的语法糖 <code>cond</code> ，<code>cond</code> 语法糖可以用 <code>if</code> 语句实现。</p><h3 id="All-Values-are-Pointers-to-Objects"><a href="#All-Values-are-Pointers-to-Objects" class="headerlink" title="All Values are Pointers to Objects"></a>All Values are Pointers to Objects</h3><h4 id="All-Values-are-Pointers"><a href="#All-Values-are-Pointers" class="headerlink" title="All Values are Pointers"></a>All Values are Pointers</h4><p>所有的 <code>scheme</code> 对象都分配在堆上，通过指针引用，且不用担心解引用的问题，因为在 <code>scheme</code> 中解引用是统一的。一旦计算过程需要值， <code>scheme</code> 会自动 <code>dereference a pointer to a value</code> 。</p><p>比如表达式 <code>(+ 2 4)</code> <code>scheme</code> 会有一个指向 <code>2</code> 的指针和一个指向 <code>4</code> 的指针，并作为参数传递给过程 <code>+</code> ，该过程返回一个指向 <code>6</code> 的指针，所有的参数和返回值都是指针，如果我们忽略指针操作，你会发现这和其他语言语义上是一致的。</p><p>我们知道在 <code>c</code> 语言中会有 <code>指针语义</code> 和 <code>原始值语义</code> ，比如 <code>2</code> 是原始值，<code>int * p</code> 中的 <code>p</code> 是一个指针，这就要求我们时刻注意区分，变量到底是原始值还是指针，其中涉及到强制类型转换。而 <code>scheme</code> 中所有值都是指针，把一切都统一了，你可以说 <code>scheme</code> 中没有指针变量或者 <code>scheme</code> 一切都是指针。</p><h4 id="Most-Implementations-Optimize-Away-Many-Pointers"><a href="#Most-Implementations-Optimize-Away-Many-Pointers" class="headerlink" title="Most Implementations Optimize Away Many Pointers"></a>Most Implementations Optimize Away Many Pointers</h4><p>根据上面所述，所有的值都是指针，你可能会有疑问，对应数字 <code>2</code> 难道 <code>scheme</code> 也是用指针实现的？这样的化效率必然很低。其实 <code>Everything's a pointer</code> 是从程序员的层面观察到的，是 <code>scheme</code> 语义上达到的一个效果。在真正实现的时候，会进行很多优化，比如一个变量是数字，那么该变量往往会直接存储该数字的值，但怎么区分一个变量是立即值还是指针呢？ <code>scheme</code> 会将变量值的某几位作为标记，以区分是立即值还是指针，这种解决方案叫做 <code>tagging</code> 。直接存储立即值在变量里，是否会打破刚刚提到的 <code>Everything's a pointer</code> 抽象呢？其实不会，因为程序员是无法看到这中间的区别的。</p><h4 id="Objects-on-the-Heap"><a href="#Objects-on-the-Heap" class="headerlink" title="Objects on the Heap"></a>Objects on the Heap</h4><p>从语义上来说，任何 <code>scheme</code> 对象都分配在堆上，由属性构成，属性的值可以是任何 <code>scheme value</code> ，比如 <code>tagged immediate value or a tagged pointer to another heap-allocated object</code> 。</p><p>比如 <code>pair</code> 就是一个拥有两个属性的对象，这两个属性可以是数字、字符串、布尔值或者指向另一个对象的指针等。 <code>pair</code> 由 <code>con</code> 创建，示例如下：</p><p><img src="pair.png" alt="pair"></p><p>在绝大多数 <code>scheme</code> 实现中，堆分配的对象都有一个头部，该头部记录的该对象的类型信息，对程序员来说的不可见的。其中数字 <code>22</code> <code>15</code> 可能是由 30 位 bit 其中两位 <code>tag</code> 信息的立即数。</p><h3 id="Scheme-Reclaims-Memory-Automatically"><a href="#Scheme-Reclaims-Memory-Automatically" class="headerlink" title="Scheme Reclaims Memory Automatically"></a>Scheme Reclaims Memory Automatically</h3><p> 在 <code>c</code> 语言中，数据对象会以以下三种方式分配存储空间：</p><ol><li>allocated statically (as in the case of global variables)</li><li>on an activation stack as part of a procedure activation record (as in the case of local variables)</li><li>dynamically allocated on the heap at run time using an allocation routine like malloc or new</li></ol><p>由于 <code>scheme</code> 所有对象都分配在堆上，通过指针引用。 <code>Lisp</code> 家族语言是最早实现垃圾回收机制的，也就是说内存对应程序员是无线的，我们只管使用，由 <code>GC</code> 负责内存的回收。 <code>GC</code> 通过引用计数、标记-清除等策略保证，没有被引用的对象能够及时清理，而需要的对象一直存在。</p><h3 id="Objects-Have-Types-Variables-Don’t"><a href="#Objects-Have-Types-Variables-Don’t" class="headerlink" title="Objects Have Types, Variables Don’t"></a>Objects Have Types, Variables Don’t</h3><p>根据前面所述 <code>scheme</code> 中的所有变量都是同一种类型 <code>pointer to anything</code> 。那么 <code>scheme</code> 是无类型的吗？虽然 <code>scheme</code> 变量是无类型的，但是 <code>scheme</code> 对象却有一个带有类型信息的头部，你无法将 <code>+</code> 应用于两个字符串，所以 <code>scheme</code> 是 <code>动态类型</code> ，其类型检查发生在运行时。好的编译器会在编译期间进行类型推导，生成更高效的代码，所以不用太过担心效率问题。</p><h3 id="The-Empty-List"><a href="#The-Empty-List" class="headerlink" title="The Empty List"></a>The Empty List</h3><p>在 <code>scheme</code> 中存在一个空指针值，也把它叫做 <code>the empty list</code> ，打印出来为 <code>()</code> 。空列表是一个比较特殊的对象，空指针是一个指向特殊结尾的列表对象。我们可以忽略空指针和空列表在语义上的区别，对于空指针可以使用 <code>null?</code> 来判断。那么为什么空指针对象会被称为空列表呢？后续会给出解释，主要与 <code>scheme</code> 大量使用列表有关。</p><h2 id="Pairs-and-Lists"><a href="#Pairs-and-Lists" class="headerlink" title="Pairs and Lists"></a>Pairs and Lists</h2><h3 id="cdr-linked-lists"><a href="#cdr-linked-lists" class="headerlink" title="cdr-linked lists"></a>cdr-linked lists</h3><p>前面我们介绍了 <code>pair</code> ，本节介绍 <code>list</code> ，其实 <code>scheme</code> 中根本没有 <code>list</code> 数据类型，<code>list</code> 不过是一系列 <code>pair</code> 构成，以空指针结束，而空指针是空列表，包含以空指针结束的0个 <code>pair</code> ，这也解释了刚刚提到的为什么空指针也被称作空列表。</p><p><code>(define foo '(22 15 6))</code>  其结构如下：<br><img src="foolist.png" alt="list"></p><p>更直观的表现形式是：<br><img src="barlist.png" alt="list"></p><p><strong>顺便提一下 <code>pair</code> 和 <code>list</code> 相关的几个操作， <code>car</code> 返回 <code>pair</code> 第一部分， <code>cdr</code> 返回 <code>pair</code> 的第二部分，类型为 <code>list</code> ，<code>cons</code> 生成一个新的 <code>pair</code> ，第一个域指向第一个参数，第二个域指向第二个参数，第二个参数一般为 <code>list</code> 。</strong></p><h3 id="Lists-and-Quoting"><a href="#Lists-and-Quoting" class="headerlink" title="Lists and Quoting"></a>Lists and Quoting</h3><p>如果每次生成 <code>list</code> 都用 <code>cons</code> 未免太过繁琐， <code>scheme</code> 提供了用 <code>quote</code> 以字面量形式书写 <code>list</code> 的方式。 <code>(quote (1  2 3))</code> 返回 <code>list (1 2 3)</code> 。<br>对于 <code>quote</code> 注意以下几点：</p><ol><li><code>quote</code> 是一种特殊形式，不是 <code>procedure</code> 。</li><li><code>quote</code> 返回的是数据结构，不是字符串对象，该数据结构可以嵌套，可以是列表、树或者数组等等。</li><li><code>quote</code> 多次执行，返回的是同一个数据结构，如果要每次返回不同的数据结构，请使用 <code>list</code>。</li><li><code>quote</code> 可用引号代替 <code>'</code> 。</li></ol><h3 id="Where-the-Empty-List-Got-its-Name"><a href="#Where-the-Empty-List-Got-its-Name" class="headerlink" title="Where the Empty List Got its Name"></a>Where the Empty List Got its Name</h3><p>通过前面的 <code>list</code> 和 <code>quote</code> ，我们知道空指针和空列表的联系了。对于给定的列表 <code>'(1 2 3)'</code>  第一次 <code>cdr</code> 返回的是列表 <code>(2 3)</code> ，继续 <code>cdr</code> 返回的是列表 <code>(3)</code> ，再次 <code>cdr</code> 返回的就是空列表 <code>()</code> ，包含 0 项的列表等和空指针是一回事。</p><h3 id="Some-Handy-Procedures-that-Operate-on-Lists"><a href="#Some-Handy-Procedures-that-Operate-on-Lists" class="headerlink" title="Some Handy Procedures that Operate on Lists"></a>Some Handy Procedures that Operate on Lists</h3><p>由于 <code>scheme</code> 的 <code>list</code> 十分灵活和强大，所以 <code>scheme</code> 提供了一些处理列表的过程。</p><h4 id="length"><a href="#length" class="headerlink" title="length"></a>length</h4><p><code>length</code> 返回列表的长度，如 <code>(length '(0 #t #f)) returns 3</code> 。</p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><code>list</code> 接收一个或者多个参数，构造前面提到的 <code>cdr-linked</code> 列表，每个 <code>pair</code> 的第一个域指向对应的参数。</p><p><code>list</code> 和 <code>cons</code> 都可以构造列表，但是 <code>list</code> 直接用参数构建列表，而 <code>cons</code> 是将新的数据项加入到已有列表中。有一个细节值得注意，构建只有一个数据项的列表，采用 <code>list</code> 是 <code>(list 1)</code> 而用 <code>cons</code> 语法为 <code>(cons 1 '()')</code> 。</p><h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><p><code>append</code> 输入参数为两个或者更多的列表，构建一个新的列表。如 <code>(append '(1 2) '(3 4))</code> 返回 <code>(1 2 3 4)</code> ，但是 <code>(list '(1 2) '(3 4))</code> 返回 <code>((1 2) (3 4))</code> 。注意两者之间的区别， <code>append</code> 要求其参数为列表，将各个列表中的元素组成一个新的列表，而 <code>list</code> 对其元素并无要求。另外值得注意的是， <code>append</code> 只会连接顶层的元素，并不会展平(<code>flatten</code>)嵌套的结构。如<br> </p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">(append '((1 2) (3 4))       '((5 6) (7 8)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>返回 <code>((1 2) (3 4) (5 6) (7 8))</code> 。此外，<code>append</code> 的元素是共享的，改变其中一个其他会跟着改变，这也是强调 <code>无副作用</code> 计算的原因。<p></p><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><p>和 <code>append</code> 类似，将给定列表反序。</p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">(reverse '(1 2 3 4)) ;(4 3 2 1)(reverse '((1 2) (3 4)));returns ((3 4) (1 2)), not ((4 3) (2 1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="member"><a href="#member" class="headerlink" title="member"></a>member</h4><p>schemeVal x list –&gt;bool<br>传入一个搜索的值和列表，判断列表中是否有该值。</p><h3 id="Recursion-Over-Lists-and-Other-Data-Structures"><a href="#Recursion-Over-Lists-and-Other-Data-Structures" class="headerlink" title="Recursion Over Lists and Other Data Structures"></a>Recursion Over Lists and Other Data Structures</h3><p> <code>scheme</code> 中递归具有举足轻重的地位，用递归过程操作递归数据结构将十分简单。例如我们要深拷贝 <code>pair-tree</code> ，首先 <code>pair-tree</code> 的递归定义如下：</p><ul><li>a non-pair (leaf), or</li><li>a pair whose car and cdr are pair-trees</li></ul><p>第一个规则是基本条件，不需要递归，第二个条件的定义涉及到递归，某个内部节点的 <code>car cdr</code> 也是 <code>pair-trees</code> 。编写对应的递归程序是比较容易的，首先将对应数据结构的递归定义描述清楚，然后用程序按照递归定义遍历数据结构并计算结果。</p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">(define (pair-tree-deep-copy thing)   (if (not (pair? thing))       thing       (cons (pair-tree-deep-copy (car thing))             (pair-tree-deep-copy (cdr thing)))))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>pair-tree-deep-copy</code> 能够拷贝 <code>pair-tree</code> 但是拷贝 <code>proper list</code> 时就有问题，因为 其 <code>car</code> 并非是一个 <code>pair</code> ，导致 <code>pair-tree-deep-copy</code> 直接使用 <code>car</code> 值，而没有进一步拷贝。  <code>proper list</code> 拷贝定义如下：</p><ul><li>the empty list if the original list is empty, or</li><li>(if the list is nonempty) a pair whose car value is the same as the car of the original list, and whose cdr value is a copy of the rest of the original list.</li></ul><p>代码如下：</p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">(define (list-copy lis)   (cond ((null? lis)          '())         (else          (cons (car lis)                (list-copy (cdr lis))))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>编写递归的关键是准确定义某个过程返回什么，以及假定该过程确实返回了该结果，然后利用归纳法，将子问题合并得到原过程的结果。</strong></p><h3 id="Type-and-Equality-Predicates"><a href="#Type-and-Equality-Predicates" class="headerlink" title="Type and Equality Predicates"></a>Type and Equality Predicates</h3><p>由于 <code>scheme</code> 的值是指向堆对象的指针，那么其数据类型是什么，决定了能够进行何种操作。</p><h4 id="Type-Predicates"><a href="#Type-Predicates" class="headerlink" title="Type Predicates"></a>Type Predicates</h4><p><code>scheme</code> 提供了几个判断数据类型的谓词，<code>number?,  string?, character?, vector?, pair? ,and  port?</code></p><h4 id="Equality-Predicates"><a href="#Equality-Predicates" class="headerlink" title="Equality Predicates"></a>Equality Predicates</h4><p><code>相等</code> 的含义在不同环境是不一样的， <code>scheme</code> 提供了 <code>equal? eq? eqv?</code> 等多种方式，<code>equal?</code> 指结构上的值相等，如 <code>(equal? '(1 2 3) '(1 2 3))</code> 返回 <code>#t</code> ；而 <code>eq?</code> 比较的是两个对象的地址是否相等。由于 <code>eq?</code> 比较的是两个变量是否引用同一个对象，是指针的比较，所以相对来说更快。 <code>eqv?</code> 用于比较两个数字是否相等，如果传入的不是数字，会立即报错。</p><h4 id="Choosing-Equality-Predicates"><a href="#Choosing-Equality-Predicates" class="headerlink" title="Choosing Equality Predicates"></a>Choosing Equality Predicates</h4><p>这么多种相等比较，我们该如何选择呢？可以用以下几条规则判断：</p><ul><li>eq? is useful for fast identity (same object) comparisons of non-numbers,</li><li>= performs numeric comparisons on numbers,</li><li>eqv? is like eq?, but treats copies of the same number as though they were the same object, and</li><li>equal? performs a “deep” comparison of the structure of data structures. (It uses eqv? for components that are numbers.)</li></ul><h3 id="Quoting-and-Literals"><a href="#Quoting-and-Literals" class="headerlink" title="Quoting and Literals"></a>Quoting and Literals</h3><p>在传统程序中，字面量往往只能表示有限的数字或者字符串，而 <code>scheme</code> 中，字面量可以创建复杂、嵌套的数据结构。另一方面， <code>scheme</code> 的代码和字面量数据十分相似。比如，<code>(min 1 2)</code> 作为表达式代表求较小值，如果我们用字面量 <code>(define foo (quote (min 1 2)))</code> 定义 <code>foo</code> ，不难发现 <code>foo</code> 代表的数据结构和表达式形式上是一致的，唯一区别便是，一个表示表达式，另一个代表 <code>list</code> 。该 <code>list</code> 结构如下：<br><img src="quote.png" alt="quote"></p><h4 id="Simple-Literals-and-Self-Evaluation"><a href="#Simple-Literals-and-Self-Evaluation" class="headerlink" title="Simple Literals and Self-Evaluation"></a>Simple Literals and Self-Evaluation</h4><p>如果仔细观察会发现，<code>scheme</code> 中数字和布尔值并没有加引号来避免 <code>scheme</code> 对待其他表达式一样执行它，那么数字和布尔值是否被执行了呢？这涉及到 <code>scheme</code> 中特殊的规则，数字和布尔值的执行结果就是它本身，这种表达式叫做 <code>自执行（self-evaluating）</code> 。</p><h2 id="Local-Variables-and-Lexical-Scope"><a href="#Local-Variables-and-Lexical-Scope" class="headerlink" title="Local Variables and Lexical Scope"></a>Local Variables and Lexical Scope</h2><p>还记得最前面我们提到， <code>scheme</code> 是支持嵌套作用域块结构的语言。代码块可以嵌套，每个代码块可以定义局部变量，该变量的作用范围为该代码块。</p><p>另一方面 <code>scheme</code> 支持词法作用域，也叫静态作用域，从字面理解，静态是指我们通过阅读代码便可以确定每个变量的作用范围。相反动态作用域指变量的作用范围必须在运行时确定，这会带来很多麻烦，基本已经没有语言采用动态作用域了。</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>让我先来看段 <code>c</code> 语言代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">{  int x = 10;   int y = 20;   foo(x,y);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当进入代码块时，会分配存储空间给本地变量 <code>x y</code> ，并且存储空间会被初始化为 <code>10 20</code> ，以上这个过程我们称为 <code>x y</code> 被绑定了，即绑定是一种 <code>name</code> 到 <code>storage</code> 的关联。当离开代码块时 <code>x y</code> 的绑定消失了，可能在外层 <code>x y</code> 是和其他值绑定的。在 <code>c</code> 语言中局部变量的存储空间一般分配在活动栈上。</p><p><code>scheme</code> 的 <code>let</code> 与上述代码类似：</p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">...(let ((x 10)      (y 20))   (foo x y))...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有一点需要注意， <code>scheme</code> 的局部变量分配在堆上，那效率是不是很低呢？好的编译器会将其优化存储在寄存器中，所以不用担心效率问题。</p><h3 id="Lexical-Scope"><a href="#Lexical-Scope" class="headerlink" title="Lexical Scope"></a>Lexical Scope</h3><p>刚刚提到，<code>scheme</code> 支持嵌套块结构，那么内部的块可能会重复定义局部变量：</p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">(let ((x 10)    ; outer binding of x      (a 20))   ; binding of a   (foo x)   (let ((x (bar))       ; inner binding of x         (b (baz x x)))  ; binding of b      (quux x a)      (quux y b))   (baz x a)  ; refers to outer x (and a)   (baz x b)) ; illegal?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先声明一个概念 <code>bingding environment</code> ，绑定环境就是名称集合到存储位置的映射。在程序执行的每个点能够 <code>看得到</code> 的绑定关系就是程序执行的环境。最外层是全局绑定关系，当进入一个新的块时，会生成一个新的绑定关系，同时链接到上层环境中，如果存在同名变量，内层变量会覆盖外层变量绑定。当需要查找某个变量的绑定关系时，由内向外依次查找。块结构和作用域可以用轮廓图清晰的表示：</p><p><img src="blockstructure.png" alt="blockstructure"></p><p>从图中可以看出， <code>let</code> 前面定义的变量对后续变量莱索是不可见的。如果需要可见需要用 <code>let*</code> 。</p><h3 id="let-1"><a href="#let-1" class="headerlink" title="let*"></a>let*</h3><p>前面说了， <code>let</code> 前面定义的变量对后续变量不可见，为了达到可见的效果我们可以嵌套 <code>let</code> :</p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">(let ((a-structure (some-procedure)))   (let ((a-substructure (get-some-subpart a-structure)))      (let ((a-subsubstructure (get-another-subpart a-substructure)))         (foo a-substructure))))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需求是满足了，如果变量太多，这样写起来肯定不优雅，所以 <code>scheme</code> 提供了 <code>let*</code> 语法糖：</p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">(let* ((a-structure (some-procedure))       (a-substructure (get-some-subpart a-structure))       (a-subsubstructure (get-another-subpart a-substructure)))   (foo a-substructure))))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="letstar.png" alt="letstar"></p><h2 id="Procedures"><a href="#Procedures" class="headerlink" title="Procedures"></a>Procedures</h2><h3 id="Procedures-are-First-Class"><a href="#Procedures-are-First-Class" class="headerlink" title="Procedures are First Class"></a>Procedures are First Class</h3><p>在  <code>scheme</code> 中，procedure 是一等的，可以将 <code>procedure</code> 作为参数或者返回值。对应表达式 <code>(+ a b)</code> ，<code>scheme</code> 会做一下事情：</p><ol><li>look up the value of (the current binding of) the variable +, which we assume is a procedure,</li><li>look up the values of (the current bindings of) the variables a and b, and</li><li>apply the procedure to those values, i.e., call it with those values as arguments.</li></ol><p>注意 <code>procedure</code> 不仅仅只能以 <code>name</code> 提供，如果该表达式的值是一个 <code>procedure</code> 也是可以的。如 <code>((look-up-appropriate-procedure key) foo bar)</code> 。</p><h3 id="Anonymous-Procedures-and-lambda"><a href="#Anonymous-Procedures-and-lambda" class="headerlink" title="Anonymous Procedures and lambda"></a>Anonymous Procedures and lambda</h3><p>在 <code>scheme</code> 中用 <code>lambda</code> 代表匿名过程，使用 <code>define</code> 定义过程不过是 <code>lambda</code> 的语法糖。</p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">(define (double x)   (+ x x))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>等价于</p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">(define double (lambda (x)                  (+ x x)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="lambda-and-Lexical-Scope"><a href="#lambda-and-Lexical-Scope" class="headerlink" title="lambda and Lexical Scope"></a>lambda and Lexical Scope</h3><p>前面介绍过 <code>scheme</code> 是词法作用域，那么在定义 <code>lambda</code> 过程时，应该创建哪些东西呢？首先 <code>lambda</code> 包含形式参数和函数体，这里有一个概念 <code>自由变量</code> 指函数体中不包含形参的变量，可以这么理解，那些在函数体中和形式参数同名的变量被约束了，其他的变量是自由的。当 <code>lambda</code> 被执行时自由变量应该在哪儿找它的绑定呢？答案是 <code>lambda</code> 的环境，所以创建 <code>lambda</code> 时需要记录过程所在环境。包含 <code>lambda</code> 形参、函数体以及所在环境的整体叫做 <code>闭包</code> 。</p><h3 id="Local-Definitions"><a href="#Local-Definitions" class="headerlink" title="Local Definitions"></a>Local Definitions</h3><p>如果某些过程只在特定的范围有效，可以使用局部定义，而不用定义成全局的。</p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">(define (quadruple x)   (let ((double (lambda (x)                    (+ x x))))      (double (double x))))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>局部过程也遵守词法作用域。</p><h3 id="Recursive-Local-Procedures-and-letrec"><a href="#Recursive-Local-Procedures-and-letrec" class="headerlink" title="Recursive Local Procedures and letrec"></a>Recursive Local Procedures and letrec</h3><p>根据前面的描述，可以利用 <code>let</code> 和 <code>lambda</code> 来定义本地过程，但是怎么定义递归过程呢？<br>尝试：</p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">(define (foo x)   (let ((local-proc (lambda (y)                        ...                        (local-proc ...)   ; recursive call?  No.                        ...)))      ...      (local-proc x)      ...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码的问题是，local-proc 对于其函数体不可见，其作用域范围如下图所示：<br><img src="letrec.png" alt="letrec"></p><p>这正是 <code>letrec</code> 解决的事， <code>letrec</code> 先声明所有变量，分配存储空间，但是并未赋值。 <code>letrec</code> 保证所有变量都是可见的。其作用域如下图所示：<br><img src="letrec2.png" alt="letrec"></p><p><code>letrec</code> 对互递归也能很好的支持：</p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">(define (my-proc)   (letrec ((local-proc-1 (lambda ()                             ...                             (local-proc-2)                             ...))            (local-proc-2 (lambda ()                             ...                             (local-proc-1)                             ...)))      (local-proc-1))) ; start off mutual recursion by calling local-proc-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="letrec3.png" alt="letrec"></p><h3 id="Multiple-defines-are-like-a-letrec"><a href="#Multiple-defines-are-like-a-letrec" class="headerlink" title="Multiple defines are like a letrec"></a>Multiple defines are like a letrec</h3><p>有了 <code>letrec</code> 我们可以解释 <code>define</code> 的工作机制了。</p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">...(define (foo)   (... (bar) ...))(define (bar)   (... (baz) ...))(define (baz)   (... (quux) ...))...(foo)...;等价于...(define foo        (lambda ()           (... (bar) ...)))(define bar        (lambda ()           (... (baz) ...)))(define baz        (lambda ()           (... (foo) ...)))...(foo)...;等价于(letrec (...         (foo (lambda ()                 (... (bar) ...)))         (bar (lambda ()                 (... (baz) ...)))         (baz (lambda ()                 (... (foo) ...)))         ...) ... (foo) ...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的局部过程也可以用 <code>letrec</code> 去糖：</p><pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme">(define (my-proc)   (define (local-proc-1)      ...)   (define (local-proc-2)      ...)   (local-proc-1)   (local-proc-1));等价于(define (my-proc)  (letrec ((local-proc-1 (lambda () ...))           (local-proc-2 (lambda () ...)))    (local-proc-1)    (local-proc-2)));去糖(define my-proc  (lambda ()    (letrec ((local-proc-1 (lambda () ...))             (local-proc-2 (lambda () ...)))      (local-proc-1)      (local-proc-2))))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> scheme </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言 </tag>
            
            <tag> scheme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己动手构建简易虚拟机和编译器-构建XVM虚拟机</title>
      <link href="/2018/05/27/zi-ji-dong-shou-gou-jian-jian-yi-xu-ni-ji-he-bian-yi-qi-gou-jian-xvm-xu-ni-ji/"/>
      <url>/2018/05/27/zi-ji-dong-shou-gou-jian-jian-yi-xu-ni-ji-he-bian-yi-qi-gou-jian-xvm-xu-ni-ji/</url>
      
        <content type="html"><![CDATA[<p>前面我们已经将汇编语言汇编成可执行文件，接下来将构建让其运行的运行时环境（XVM XtremeScript Virtual Machine）。本章将阐述虚拟机如何工作， XVM 原型和构造细节。</p><a id="more"></a><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>平时编写的代码最终会转换成机器码，运行在硬件上，而虚拟机模拟了硬件环境，字节码（运行在虚拟机上的代码，类似于机器码）将运行于虚拟机上。</p><p><img src="vm.png" alt="vm"></p><p>由于虚拟机模拟了硬件环境，所以虚拟机也拥有一套运行时环境，虚拟机屏蔽了底层系统的复杂性，拥有较好的扩展性和便捷性，不过由于构建在底层系统之上，所以牺牲了一定的性能。</p><p>XVM 基本架构如下：</p><p><img src="vmarch.png" alt="vmarch"></p><h2 id="VM-主要部件"><a href="#VM-主要部件" class="headerlink" title="VM 主要部件"></a>VM 主要部件</h2><h3 id="指令流"><a href="#指令流" class="headerlink" title="指令流"></a>指令流</h3><p>指令流作为程序核心，由编译后的操作码和操作数组成。</p><p><img src="instrStream.png" alt="instrStream"></p><h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>VM 是基于栈的体系结构，运行时栈底部包含全局变量，然后是栈帧，栈帧之间可能包含由 <code>push</code> 和 <code>pop</code> 指令压入的 0-N 个其他元素。</p><p><img src="runtimeStack.png" alt="runtimeStack"></p><h3 id="全局数据表"><a href="#全局数据表" class="headerlink" title="全局数据表"></a>全局数据表</h3><p>接下来两个主要的全局数据结构是：函数表和主机 API 调用表，函数表中保存了函数的相关信息， Host API Call Table 保存了主机调用函数信息。</p><p><img src="globalTable.png" alt="globalTable"></p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>正如操作系统支持多任务一样，VM 也支持同时运行多个脚本，每个脚本的运行时环境相互独立，但是又可以相互通信。</p><p><img src="multithread.png" alt="multithread"></p><h3 id="与主机整合"><a href="#与主机整合" class="headerlink" title="与主机整合"></a>与主机整合</h3><p>脚本语言通过集成层实现了 VM 与 Host APP 之间的通信。</p><p><img src="VmToHost.png" alt="VmToHost"></p><h2 id="虚拟机生命周期"><a href="#虚拟机生命周期" class="headerlink" title="虚拟机生命周期"></a>虚拟机生命周期</h2><p>虚拟机也像其他程序一样，拥有完整的生命周期。简要分为以下几个阶段：</p><ol><li>加载脚本，初始化主要数据结构</li><li>定位脚本入口，开始执行周期</li><li>不断执行指令流中指令</li><li>终止执行，释放主要数据结构和其他资源</li></ol><h3 id="加载脚本"><a href="#加载脚本" class="headerlink" title="加载脚本"></a>加载脚本</h3><p>虚拟机首先将执行文件加载到内存，然后将执行文件中的主要数据结构装载到虚拟机运行时环境。</p><p><img src="loadExe.png" alt="loadExe"></p><h3 id="定位入口点并执行"><a href="#定位入口点并执行" class="headerlink" title="定位入口点并执行"></a>定位入口点并执行</h3><p>在物理 CPU 执行程序时有一个指向当前指令的指针 IP(instruction pointer) ，虚拟机执行时也有相应的指令指针 PC( program counter). 在我们的脚本语言中，_Main 函数作为函数的入口点。</p><h3 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h3><p>当 VM 找到入口点后（通过 _Main 函数或者其他函数调用），VM 便开始源源不断的执行指令，和 CPU 指令执行过程类似，VM 也将指令执行分为几个典型的阶段：</p><ol><li>Opcode Identification 指令执行的第一个阶段便是获取操作码</li><li>Operand Resolution 操作数在不同的操作符中具有不同的含义，该过程涉及到识别、定位和转换操作数。该过程称为 <code>operand resolution</code> ，在指令执行周期中是最复杂的。</li><li>Instruction Execution 一旦获取了操作符和操作数，就需要根据指令的语义执行相应的逻辑了。</li><li>Store Results 许多指令执行完后都需要保存相应的结果，该阶段将指令执行结果存入目标地址。</li></ol><p><img src="executeCycle.png" alt="executeCycle"></p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>由于 XASM 核心操作之一就是函数调用，所以怎么实现函数的调用和返回至关重要。</p><h4 id="函数调用-1"><a href="#函数调用-1" class="headerlink" title="函数调用"></a>函数调用</h4><p>函数调用的基本步骤是：压入函数参数、压入返回地址和压入本地变量。</p><p><img src="functionCall.png" alt="functionCall"></p><p>不过这里存在两个问题：</p><h5 id="在函数执行完成返回时，怎么才能知道-Return-Address-距离栈顶多远呢？"><a href="#在函数执行完成返回时，怎么才能知道-Return-Address-距离栈顶多远呢？" class="headerlink" title="在函数执行完成返回时，怎么才能知道 Return Address 距离栈顶多远呢？"></a>在函数执行完成返回时，怎么才能知道 <code>Return Address</code> 距离栈顶多远呢？</h5><p><img src="problem1.png" alt="problem1"></p><p>只有通过函数结构能够读取到 Ret 指令位置，还记得前面介绍局部变量时，起始位置是从 -2 开始的，-1 便是为存储函数索引保留的。</p><h4 id="第二个问题是函数弹出栈帧时，运行栈的-iFrameIndex-指针需要更新为指向前一个栈帧"><a href="#第二个问题是函数弹出栈帧时，运行栈的-iFrameIndex-指针需要更新为指向前一个栈帧" class="headerlink" title="第二个问题是函数弹出栈帧时，运行栈的 iFrameIndex 指针需要更新为指向前一个栈帧"></a>第二个问题是函数弹出栈帧时，运行栈的 <code>iFrameIndex</code> 指针需要更新为指向前一个栈帧</h4><p>理想的情况是弹出栈帧后，栈顶便为前一个栈帧的 <code>iFrameIndex</code> ，但是如果栈帧之间通过 <code>push</code> 指令压入了其他元素，那么我们便无法定位前一个栈帧正确的 <code>iFrameIdex</code> 了。由于前面我们已经预留了一个位置保持函数返回地址，与此同时也可以将 <code>iFrameIdex</code> 存放在该位置。</p><p><img src="funcIndexiFrameIndex.png" alt="funcIndexiFrameIndex"></p><p>总结一下函数调用过程：</p><ol><li>从函数表中获取函数信息</li><li>压入函数返回值</li><li>压入栈帧。栈帧大小为本地数据大小加上 Ret 指令</li><li>将 调用函数的 <code>iFuncIndex</code> 和前一个栈帧的栈顶索引 <code>iOffsetIndex</code> 存入栈顶元素</li></ol><h4 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h4><p>为了从函数返回，弹出栈顶元素，通过 <code>iFuncIndex</code> 取得函数信息，计算返回值位置，弹出当前栈帧，更新新的栈顶元素的 <code>iFrameIdex</code> 和 <code>iTopIndex</code> ，然后通过无条件跳转到返回地址。</p><p><img src="functionret.png" alt="functionret"></p><h3 id="终止和关闭虚拟机"><a href="#终止和关闭虚拟机" class="headerlink" title="终止和关闭虚拟机"></a>终止和关闭虚拟机</h3><p>脚本运行完成后，一定记得释放资源，否则多次运行脚本后，会造成内存溢出。</p><h2 id="XVM-原型架构"><a href="#XVM-原型架构" class="headerlink" title="XVM 原型架构"></a>XVM 原型架构</h2><p>XVM 原型包含 <code>Script Header</code>,<code>Instruction Stream</code>,<code>Runtime Stack</code>,<code>Function Table</code> 和 <code>Host API Call Table</code>。</p><h3 id="Script-header"><a href="#Script-header" class="headerlink" title="Script header"></a>Script header</h3><p>脚本头包含以下内容：</p><ol><li>A Pause Flag.</li><li>The Presence of _Main ().</li><li>_Main ()’s Function Index.</li><li>Global Data Size.</li><li>The _RetVal Register.</li></ol><h3 id="Runtime-Values"><a href="#Runtime-Values" class="headerlink" title="Runtime Values"></a>Runtime Values</h3><p>由于脚本语言是无类型的，所以不能用类似 C 语言的 int,float 或者 char* 代表运行时值，因为运行过程中可能从一种数据类型转换到另一种数据类型，所以需要用一个结构体代表运行时值（runtime values），结构体如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _Value // A runtime value{  int iType; // Type  union // The value  {    int iIntLiteral; // Integer literal    float fFloatLiteral; // Float literal    char * pstrStringLiteral; // String literal    int iStackIndex; // Stack Index    int iInstrIndex; // Instruction index    int iFuncIndex; // Function index    int iHostAPICallIndex; // Host API Call index    int iReg; // Register code  };  int iOffsetIndex; // Index of the offset}Value;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="指令流-1"><a href="#指令流-1" class="headerlink" title="指令流"></a>指令流</h3><p>指令流的结构和执行文件中指令流的表示方式类似：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _Instr // An instruction{  int iOpcode; // The opcode  int iOpCount; // The number of operands  Value * pOpList; // The operand list}Instr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="instrMemory.png" alt="instrMemory"></p><h3 id="运行时栈-1"><a href="#运行时栈-1" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>运行时栈以栈为基础，栈中元素便是运行时值（runtime values）， c 语言中没有现成的栈实现，不过可以用数组配合一个索引模拟栈，栈结构如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _RuntimeStack // A runtime stack{  Value * pElmnts; // The stack elements  int iSize; // The number of elements in the stack  int iTopIndex; // The top index  int iFrameIndex; // Index of the top of the current  // stack frame.}RuntimeStack;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Frame-Index"><a href="#Frame-Index" class="headerlink" title="Frame Index"></a>Frame Index</h3><p>为什么会存在 <code>iFrameIndex</code> 呢？，还记得栈帧中所有的本地变量和参数都是相对于<code>栈顶</code>引用的，此处的 <code>栈顶</code> 可能会因 <code>push</code> 指令发生改变，所以需要将最初的<code>栈顶</code> 记录下来，即存入 <code>iFrameIndex</code> 中，这样无论栈顶如何变化，本地变量和参数引用都不会发生变化。</p><h3 id="Function-Table"><a href="#Function-Table" class="headerlink" title="Function Table"></a>Function Table</h3><p>由于 XVM 需要访问函数的信息，不过这些信息都是只读的，所以可以用如下结构表示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _Func // Function table element{  int iEntryPoint; // The entry point  int iParamCount; // Number of parameters to expect  int iLocalDataSize; // Total size of all local data  int iStackFrameSize; // Total size of the stack frame}Func;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>iStackFrameSize</code> 为 <code>iParamCount+iLocalDataSize+1</code> ，虽然可以实时计算出该值，不过在虚拟机执行过程中会高频计算该值，所以提前用一个字段保存能提高性能。</p><p><img src="functionTable.png" alt="functionTable"></p><h3 id="Host-API-Call-Table"><a href="#Host-API-Call-Table" class="headerlink" title="Host API Call Table"></a>Host API Call Table</h3><p>Host API Call Table 中包含调用表和数量。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _HostAPICallTable // A host API call table{  char ** ppstrCalls; // Pointer to the call array  int iSize; // The number of calls in the array}HostAPICallTable;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="脚本运行时数据结构"><a href="#脚本运行时数据结构" class="headerlink" title="脚本运行时数据结构"></a>脚本运行时数据结构</h3><p>综合前面各个数据结构，便可以得到脚本运行时的数据结构：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _Script // Encapsulates a full script{  // Header data  int iGlobalDataSize; // The size of the script's global  // data  int iIsMainFuncPresent; // Is _Main () present?  int iMainFuncIndex; // _Main ()'s function index  int iIsPaused; // Is the script currently paused?  int iPauseEndTime; // If so, when should it resume?  // Register file  Value _RetVal; // The _RetVal register  // Script data  InstrStream InstrStream; // The instruction stream  RuntimeStack Stack; // The runtime stack  Func * pFuncTable; // The function table  HostAPICallTable HostAPICallTable; // The host API call table}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="构建-XVM-原型"><a href="#构建-XVM-原型" class="headerlink" title="构建 XVM 原型"></a>构建 XVM 原型</h2><p>XVM 原型包含以下几个阶段：</p><ol><li>加载脚本，初始化脚本结构</li><li>定位 _Main() 函数入口，开始执行循环</li><li>当用户按下按键后终止执行，释放资源并关闭程序</li></ol><h3 id="加载-XSE-可执行文件"><a href="#加载-XSE-可执行文件" class="headerlink" title="加载 .XSE 可执行文件"></a>加载 .XSE 可执行文件</h3><p>.XSE 格式回顾</p><h4 id="XSE-Main-Header"><a href="#XSE-Main-Header" class="headerlink" title=".XSE Main Header"></a>.XSE Main Header</h4><p><img src="mainHeader.png" alt="mainHeader"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// Create a buffer to hold the file's ID string// (4 bytes + 1 null terminator = 5)char * pstrIDString;pstrIDString = ( char * ) malloc ( 5 );// Read the string (4 bytes) and append a null terminatorfread ( pstrIDString, 4, 1, pScriptFile );pstrIDString [ strlen ( XSE_ID_STRING ) ] = '\0';// Compare the data read from the file to the ID string and exit on an error// if they don't matchif ( strcmp ( pstrIDString, XSE_ID_STRING ) != 0 )  return LOAD_ERROR_INVALID_XSE;// Free the bufferfree ( pstrIDString );// Read the script version (2 bytes total)int iMajorVersion = 0,iMinorVersion = 0;fread ( &amp; iMajorVersion, 1, 1, pScriptFile );fread ( &amp; iMinorVersion, 1, 1, pScriptFile );// Validate the version, since this prototype only supports version 0.4 scriptsif ( iMajorVersion != 0 || iMinorVersion != 4 )  return LOAD_ERROR_UNSUPPORTED_VERS;// Read the stack size (4 bytes)fread ( &amp; g_Script.Stack.iSize, 4, 1, pScriptFile );// Check for a default stack size requestif ( g_Script.Stack.iSize == 0 )  g_Script.Stack.iSize = DEF_STACK_SIZE;// Allocate the runtime stackint iStackSize = g_Script.Stack.iSize;g_Script.Stack.pElmnts = ( Value * )malloc ( iStackSize * sizeof ( Value ) );// Read the global data size (4 bytes)fread ( &amp; g_Script.iGlobalDataSize, 4, 1, pScriptFile );// Check for presence of _Main () (1 byte)fread ( &amp; g_Script.iIsMainFuncPresent, 1, 1, pScriptFile );// Read _Main ()'s function index (4 bytes)fread ( &amp; g_Script.iMainFuncIndex, 4, 1, pScriptFile );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Instruction-Stream"><a href="#Instruction-Stream" class="headerlink" title="Instruction Stream"></a>Instruction Stream</h4><p><img src="instrStreamStruct.png" alt="instrStreamStruct"></p><p><img src="instructionStruct.png" alt="instructionStruct"></p><p><img src="opStream.png" alt="opStream"></p><p><img src="opStruct.png" alt="opStruct"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">for ( int iCurrInstrIndex = 0;iCurrInstrIndex &lt; g_Script.InstrStream.iSize;++ iCurrInstrIndex ){  // Read the opcode (2 bytes)  g_Script.InstrStream.pInstr [ iCurrInstrIndex ].iOpcode = 0;  fread ( &amp; g_Script.InstrStream.pInstrs [ iCurrInstrIndex ].iOpcode,  2, 1, pScriptFile );  // Read the operand count (1 byte)  g_Script.InstrStream.pInstr [ iCurrInstrIndex ].iOpCount = 0;  fread ( &amp; g_Script.InstrStream.pInstrs [ iCurrInstrIndex ].iOpCount,  1, 1, pScriptFile );  int iOpCount = g_Script.InstrStream.pInstrs [ iCurrInstrIndex ].iOpCount;  // Allocate space for the operand list in a temporary pointer  Value * pOpList;  pOpList = ( Value * ) malloc ( iOpCount * sizeof ( Value ) );  // Read in the operand list (N bytes)  for ( int iCurrOpIndex = 0; iCurrOpIndex &lt; iOpCount; ++ iCurrOpIndex )  {    // Read in the operand type (1 byte)    pOpList [ iCurrOpIndex ].iType = 0;    fread ( &amp; pOpList [ iCurrOpIndex ].iType, 1, 1, pScriptFile );    // Depending on the type, read in the operand data    switch ( pOpList [ iCurrOpIndex ].iType )    {        // Integer literal        case OP_TYPE_INT:          fread ( &amp; pOpList [ iCurrOpIndex ].iIntLiteral,          sizeof ( int ), 1, pScriptFile );          break;        // Floating-point literal        case OP_TYPE_FLOAT:          fread ( &amp; pOpList [ iCurrOpIndex ].fFloatLiteral,          sizeof ( float ), 1, pScriptFile );          break;        // String index        case OP_TYPE_STRING:          // Since there's no field in the Value structure for string          // table          // indices, read the index into the integer literal field          // and set          // its type to string index          fread ( &amp; pOpList [ iCurrOpIndex ].iIntLiteral, sizeof ( int ),          1, pScriptFile );          pOpList [ iCurrOpIndex ].iType = OP_TYPE_STRING;          break;        // Instruction index        case OP_TYPE_INSTR_INDEX:          fread ( &amp; pOpList [ iCurrOpIndex ].iInstrIndex,          sizeof ( int ), 1, pScriptFile );          break;        // Absolute stack index        case OP_TYPE_ABS_STACK_INDEX:          fread ( &amp; pOpList [ iCurrOpIndex ].iStackIndex,          sizeof ( int ), 1, pScriptFile );          break;        // Relative stack index        case OP_TYPE_REL_STACK_INDEX:          fread ( &amp; pOpList [ iCurrOpIndex ].iStackIndex, sizeof ( int ),          1, pScriptFile );          fread ( &amp; pOpList [ iCurrOpIndex ].iOffsetIndex,          sizeof ( int ), 1, pScriptFile );          break;        // Function index        case OP_TYPE_FUNC_INDEX:          fread ( &amp; pOpList [ iCurrOpIndex ].iFuncIndex, sizeof ( int ),          1, pScriptFile );          break;        // Host API call index        case OP_TYPE_HOST_API_CALL_INDEX:          fread ( &amp; pOpList [ iCurrOpIndex ].iHostAPICallIndex,          sizeof ( int ), 1, pScriptFile );          break;        // Register        case OP_TYPE_REG:          fread ( &amp; pOpList [ iCurrOpIndex ].iReg, sizeof ( int ),          1, pScriptFile );          break;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取过程如下：</p><p><img src="readingInstr.png" alt="readingInstr"></p><h4 id="String-Table"><a href="#String-Table" class="headerlink" title="String Table"></a>String Table</h4><p><img src="stringTable.png" alt="stringTable"><br><img src="stringStruct.png" alt="stringStruct"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// Run through each operand in the instruction stream and assign copies// of string operands' corresponding string literalsfor ( int iCurrInstrIndex = 0; iCurrInstrIndex &lt; g_Script.InstrStream.iSize;++ iCurrInstrIndex ){  // Get the instruction's operand count and a copy of its operand list  int iOpCount = g_Script.InstrStream.pInstrs [ iCurrInstrIndex ].iOpCount;  Value * pOpList = g_Script.InstrStream.pInstrs [ iCurrInstrIndex ].pOpList;  // Loop through each operand  for ( int iCurrOpIndex = 0; iCurrOpIndex &lt; iOpCount; ++ iCurrOpIndex )  {    // If the operand is a string index, make a local copy of    // its corresponding string in the table    if ( pOpList [ iCurrOpIndex ].iType == OP_TYPE_STRING )    {      // Get the string index from the operand's integer literal field      int iStringIndex = pOpList [ iCurrOpIndex ].iIntLiteral;      // Allocate a new string to hold a copy of the one in the table      char * pstrStringCopy;      pstrStringCopy = ( char * )      malloc ( strlen ( ppstrStringTable [ iStringIndex ] ) + 1 );      // Make a copy of the string      strcpy ( pstrStringCopy, ppstrStringTable [ iStringIndex ] );      // Save the string pointer in the operand list      pOpList [ iCurrOpIndex ].pstrStringLiteral = pstrStringCopy;    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在读取字符串表时，我们会直接将字符串拷贝到指令流中：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// Loop through each instruction in the streamfor ( int CurrInstr = 0; CurrInstr &lt; g_Script.InstrCount; ++ CurrInstr ){  // Get the instruction's operand count  int OpCount = g_Script.InstrStream.Instrs [ CurrInstr ].OpCount;  // Loop through each operand in the instruction  for ( int CurrOp = 0; CurrOp &lt; OpCount; ++ CurrOp )  {      // Get the current operand type    int OpType = g_Script.InstrStream.Instrs \    [ CurrInstr ].OpList [ CurrOp ].Type;    // Is this a string operand?    if ( OpType == OP_TYPE_STRING )    {      // The string index is in the IntLiteral field      int StringIndex = g_Script.InstrStream \      [ CurrInstr ].OpList [ CurrOp ].IntLiteral;      // Get the string from the table      string StringOp = StringTable [ StringIndex ];      // Save the string value in the operand      g_Script.InstrStream.Instrs [ CurrInstr ].OpList \      [ CurrOp ].StringLiteral = OP_TYPE_STRING;    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取完字符串表后，要记得释放原先的字符串表资源：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// Free the original stringsfor ( iCurrStringIndex = 0; iCurrStringIndex &lt; iStringTableSize;++ iCurrStringIndex )  free ( ppstrStringTable [ iCurrStringIndex ] );// Free the string table itselffree ( ppstrStringTable );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Function-Table-Structure"><a href="#Function-Table-Structure" class="headerlink" title="Function Table Structure"></a>Function Table Structure</h4><p><img src="funcTable.png" alt="funcTable"><br><img src="funcTableStruct.png" alt="funcTableStruct"></p><p>读取函数表比较直接：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// Read the function count (4 bytes)int iFuncTableSize;fread ( &amp; iFuncTableSize, 4, 1, pScriptFile );// Allocate the tableg_Script.pFuncTable = ( Func * ) malloc ( iFuncTableSize * sizeof ( Func ) )// Read each functionfor ( int iCurrFuncIndex = 0; iCurrFuncIndex &lt; iFuncTableSize;++ iCurrFuncIndex ){  // Read the entry point (4 bytes)  int iEntryPoint;  fread ( &amp; iEntryPoint, 4, 1, pScriptFile );  // Read the parameter count (1 byte)  int iParamCount = 0;  fread ( &amp; iParamCount, 1, 1, pScriptFile );  // Read the local data size (4 bytes)  int iLocalDataSize;  fread ( &amp; iLocalDataSize, 4, 1, pScriptFile );  // Calculate the stack size  int iStackFrameSize = iParamCount + 1 + iLocalDataSize;  // Write everything to the function table  g_Script.pFuncTable [ iCurrFuncIndex ].iEntryPoint = iEntryPoint;  g_Script.pFuncTable [ iCurrFuncIndex ].iParamCount = iParamCount;  g_Script.pFuncTable [ iCurrFuncIndex ].iLocalDataSize = iLocalDataSize;  g_Script.pFuncTable [ iCurrFuncIndex ].iStackFrameSize = iStackFrameSize;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Host-API-Call-Table-Structure"><a href="#Host-API-Call-Table-Structure" class="headerlink" title="Host API Call Table Structure"></a>Host API Call Table Structure</h4><p><img src="hostAPICallTable.png" alt="hostAPICallTable"><br><img src="hostAPICallStructure.png" alt="hostAPICallStructure"></p><p>读取 Host API 也比较直接：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// Read the host API call countfread ( &amp; g_Script.HostAPICallTable.iSize, 4, 1, pScriptFile );// Allocate the tableg_Script.HostAPICallTable.ppstrCalls = ( char ** )malloc ( g_Script.HostAPICallTable.iSize * sizeof ( char * ) );for ( int iCurrCallIndex = 0; iCurrCallIndex &lt; g_Script.HostAPICallTable.iSize;++ iCurrCallIndex ){  // Read the host API call string size (1 byte)  int iCallLength = 0;  fread ( &amp; iCallLength, 1, 1, pScriptFile );  // Allocate space for the string plus the null terminator in a  // temporary pointer  char * pstrCurrCall;  pstrCurrCall = ( char * ) malloc ( iCallLength + 1 );  // Read the host API call string data and append the null terminator  fread ( pstrCurrCall, iCallLength, 1, pScriptFile );  pstrCurrCall [ iCallLength ] = '\0';  // Assign the temporary pointer to the table  g_Script.HostAPICallTable.ppstrCalls [ iCurrCallIndex ] = pstrCurrCall;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 重学计算机系列 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己动手构建简易虚拟机和编译器-构建XASM汇编器（5）</title>
      <link href="/2018/05/27/zi-ji-dong-shou-gou-jian-jian-yi-xu-ni-ji-he-bian-yi-qi-gou-jian-xasm-hui-bian-qi-5/"/>
      <url>/2018/05/27/zi-ji-dong-shou-gou-jian-jian-yi-xu-ni-ji-he-bian-yi-qi-gou-jian-xasm-hui-bian-qi-5/</url>
      
        <content type="html"><![CDATA[<p>上一章中，我们讲述了描述汇编语言的各种数据结构，本章我们将把汇编指令和一些重要的数据结构写入最后的执行文件中。</p><a id="more"></a><h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><p>在有了存储各个指令的数据结构后，我们需要利用词法分析和语法分析，将汇编指令汇编成可执行文件。</p><p><img src="xasm.png" alt="xasm"></p><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>汇编器的输入是类似与 <code>Move Y,X</code> 的汇编指令，词法分析要做的工作就是将其切分成一个个的词素：</p><pre class="line-numbers language-none"><code class="language-none">MOVY,X(NEWLINE)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么我们应该怎么切分一条指令语句呢？如果仅仅用空白切分是不够的，因为 <code>Y</code> 和 <code>,</code> 之间是没有空白的，但是它们是两个不同的词素。这里我们可以扩大分隔字符的范围，不仅仅是空白，还可以是其他的单个字符如 <code>[</code>,<code>]</code>,<code>{</code>,<code>}</code> 等，这些分隔符就是词素之间区分的标志。<br>单个字符 Token 如下：</p><p><img src="singleToken.png" alt="singleToken"></p><p>多个字符 Token 如下：</p><p><img src="multiTokens.png" alt="multiTokens"></p><p>其中 <code>Token</code> 代表该词素的类型，而词素只该 <code>Token</code> 具体的值。<br>在词法分析过程中，我们会经常用到一些接口函数，比如 GetNextToken(),<br>GetCurrLexeme(), GetLookAheadChar(),SkipToNextLine(), and ResetLexer() .<br>其中 <code>GetLookAheadChar()</code> 主要用于解决解析 <code>Var MyVar</code> 和 <code>Var MyVar[256]</code> 时存在不确定性，只有当我们向前看一个字符时，才能确定当前声明的是变量还是数组。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p> 首先我们应该对源代码进行一些清理，如去掉注释和前后空白，所以需要 <code>StripComments</code> 和 <code>TrimWhitespace</code> 函数。</p><p> 在扫描源代码时，需要记录当前的 Token 起始位置，可以用两个指针实现，如下图所示：</p><p> <img src="token.png" alt="token"></p><p> index0 和 index1 跳过空白，index0 指向第一个字符，index1 不断扫描直到遇到下一个  <code>Token</code> 时停止。</p><p> 值得注意的是，由于我们允许转义字符，所以在扫描字符串时，需要注意判断当前是否在字符串中的方法。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c">  /******************************************************************************************  *  *   GetNextToken ()  *  *   Extracts and returns the next token from the character stream. Also makes a copy of  *   the current lexeme for use with GetCurrLexeme ().  */  Token GetNextToken ()  {      // ---- Lexeme Extraction      // Move the first index (Index0) past the end of the last token, which is marked      // by the second index (Index1).      g_Lexer.iIndex0 = g_Lexer.iIndex1;      // Make sure we aren't past the end of the current line. If a string is 8 characters long,      // it's indexed from 0 to 7; therefore, indices 8 and beyond lie outside of the string and      // require us to move to the next line. This is why I use &gt;= for the comparison rather      // than &gt;. The value returned by strlen () is always one greater than the last valid      // character index.      if ( g_Lexer.iIndex0 &gt;= strlen ( g_ppstrSourceCode [ g_Lexer.iCurrSourceLine ] ) )      {          // If so, skip to the next line but make sure we don't go past the end of the file.          // SkipToNextLine () will return FALSE if we hit the end of the file, which is          // the end of the token stream.          if ( ! SkipToNextLine () )              return END_OF_TOKEN_STREAM;      }      // If we just ended a string, tell the lexer to stop lexing      // strings and return to the normal state      if ( g_Lexer.iCurrLexState == LEX_STATE_END_STRING )          g_Lexer.iCurrLexState = LEX_STATE_NO_STRING;      // Scan through the potential whitespace preceding the next lexeme, but ONLY if we're      // not currently parsing a string lexeme (since strings can contain arbitrary whitespace      // which must be preserved).      if ( g_Lexer.iCurrLexState != LEX_STATE_IN_STRING )      {          // Scan through the whitespace and check for the end of the line          while ( TRUE )          {              // If the current character is not whitespace, exit the loop because the lexeme              // is starting.              if ( ! IsCharWhitespace ( g_ppstrSourceCode [ g_Lexer.iCurrSourceLine ][ g_Lexer.iIndex0 ] ) )                  break;              // It is whitespace, however, so move to the next character and continue scanning              ++ g_Lexer.iIndex0;          }      }      // Bring the second index (Index1) to the lexeme's starting character, which is marked by      // the first index (Index0)      g_Lexer.iIndex1 = g_Lexer.iIndex0;      // Scan through the lexeme until a delimiter is hit, incrementing Index1 each time      while ( TRUE )      {          // Are we currently scanning through a string?          if ( g_Lexer.iCurrLexState == LEX_STATE_IN_STRING )          {              // If we're at the end of the line, return an invalid token since the string has no              // ending double-quote on the line              if ( g_Lexer.iIndex1 &gt;= strlen ( g_ppstrSourceCode [ g_Lexer.iCurrSourceLine ] ) )              {                  g_Lexer.CurrToken = TOKEN_TYPE_INVALID;                  return g_Lexer.CurrToken;              }              // If the current character is a backslash, move ahead two characters to skip the              // escape sequence and jump to the next iteration of the loop              if ( g_ppstrSourceCode [ g_Lexer.iCurrSourceLine ][ g_Lexer.iIndex1 ] == '\\' )              {                  g_Lexer.iIndex1 += 2;                  continue;              }              // If the current character isn't a double-quote, move to the next, otherwise exit              // the loop, because the string has ended.              if ( g_ppstrSourceCode [ g_Lexer.iCurrSourceLine ][ g_Lexer.iIndex1 ] == '"' )                  break;              ++ g_Lexer.iIndex1;          }          // We are not currently scanning through a string          else          {              // If we're at the end of the line, the lexeme has ended so exit the loop              if ( g_Lexer.iIndex1 &gt;= strlen ( g_ppstrSourceCode [ g_Lexer.iCurrSourceLine ] ) )                  break;              // If the current character isn't a delimiter, move to the next, otherwise exit the loop              if ( IsCharDelimiter ( g_ppstrSourceCode [ g_Lexer.iCurrSourceLine ][ g_Lexer.iIndex1 ] ) )                  break;              ++ g_Lexer.iIndex1;          }      }      // Single-character lexemes will appear to be zero characters at this point (since Index1      // will equal Index0), so move Index1 over by one to give it some noticable width      if ( g_Lexer.iIndex1 - g_Lexer.iIndex0 == 0 )          ++ g_Lexer.iIndex1;      // The lexeme has been isolated and lies between Index0 and Index1 (inclusive), so make a local      // copy for the lexer      unsigned int iCurrDestIndex = 0;      for ( unsigned int iCurrSourceIndex = g_Lexer.iIndex0; iCurrSourceIndex &lt; g_Lexer.iIndex1; ++ iCurrSourceIndex )      {          // If we're parsing a string, check for escape sequences and just copy the character after          // the backslash          if ( g_Lexer.iCurrLexState == LEX_STATE_IN_STRING )              if ( g_ppstrSourceCode [ g_Lexer.iCurrSourceLine ][ iCurrSourceIndex ] == '\\' )                  ++ iCurrSourceIndex;          // Copy the character from the source line to the lexeme          g_Lexer.pstrCurrLexeme [ iCurrDestIndex ] = g_ppstrSourceCode [ g_Lexer.iCurrSourceLine ][ iCurrSourceIndex ];          // Advance the destination index          ++ iCurrDestIndex;      }      // Set the null terminator      g_Lexer.pstrCurrLexeme [ iCurrDestIndex ] = '\0';      // Convert it to uppercase if it's not a string      if ( g_Lexer.iCurrLexState != LEX_STATE_IN_STRING )          _strupr ( g_Lexer.pstrCurrLexeme );      // ---- Token Identification      // Let's find out what sort of token our new lexeme is      // We'll set the type to invalid now just in case the lexer doesn't match any      // token types      g_Lexer.CurrToken = TOKEN_TYPE_INVALID;      // The first case is the easiest-- if the string lexeme state is active, we know we're      // dealing with a string token. However, if the string is the double-quote sign, it      // means we've read an empty string and should return a double-quote instead      if ( strlen ( g_Lexer.pstrCurrLexeme ) &gt; 1 || g_Lexer.pstrCurrLexeme [ 0 ] != '"' )      {          if ( g_Lexer.iCurrLexState == LEX_STATE_IN_STRING )          {              g_Lexer.CurrToken = TOKEN_TYPE_STRING;              return TOKEN_TYPE_STRING;          }      }      // Now let's check for the single-character tokens      if ( strlen ( g_Lexer.pstrCurrLexeme ) == 1 )      {          switch ( g_Lexer.pstrCurrLexeme [ 0 ] )          {              // Double-Quote              case '"':                  // If a quote is read, advance the lexing state so that strings are lexed                  // properly                  switch ( g_Lexer.iCurrLexState )                  {                      // If we're not lexing strings, tell the lexer we're now                      // in a string                      case LEX_STATE_NO_STRING:                          g_Lexer.iCurrLexState = LEX_STATE_IN_STRING;                          break;                      // If we're in a string, tell the lexer we just ended a string                      case LEX_STATE_IN_STRING:                          g_Lexer.iCurrLexState = LEX_STATE_END_STRING;                          break;                  }                  g_Lexer.CurrToken = TOKEN_TYPE_QUOTE;                  break;              // Comma              case ',':                  g_Lexer.CurrToken = TOKEN_TYPE_COMMA;                  break;              // Colon              case ':':                  g_Lexer.CurrToken = TOKEN_TYPE_COLON;                  break;              // Opening Bracket              case '[':                  g_Lexer.CurrToken = TOKEN_TYPE_OPEN_BRACKET;                  break;              // Closing Bracket              case ']':                  g_Lexer.CurrToken = TOKEN_TYPE_CLOSE_BRACKET;                  break;              // Opening Brace              case '{':                  g_Lexer.CurrToken = TOKEN_TYPE_OPEN_BRACE;                  break;              // Closing Brace              case '}':                  g_Lexer.CurrToken = TOKEN_TYPE_CLOSE_BRACE;                  break;              // Newline              case '\n':                  g_Lexer.CurrToken = TOKEN_TYPE_NEWLINE;                  break;          }      }      // Now let's check for the multi-character tokens      // Is it an integer?      if ( IsStringInteger ( g_Lexer.pstrCurrLexeme ) )          g_Lexer.CurrToken = TOKEN_TYPE_INT;      // Is it a float?      if ( IsStringFloat ( g_Lexer.pstrCurrLexeme ) )          g_Lexer.CurrToken = TOKEN_TYPE_FLOAT;      // Is it an identifier (which may also be a line label or instruction)?      if ( IsStringIdent ( g_Lexer.pstrCurrLexeme ) )          g_Lexer.CurrToken = TOKEN_TYPE_IDENT;      // Check for directives or _RetVal      // Is it SetStackSize?      if ( strcmp ( g_Lexer.pstrCurrLexeme, "SETSTACKSIZE" ) == 0 )          g_Lexer.CurrToken = TOKEN_TYPE_SETSTACKSIZE;      // Is it Var/Var []?      if ( strcmp ( g_Lexer.pstrCurrLexeme, "VAR" ) == 0 )          g_Lexer.CurrToken = TOKEN_TYPE_VAR;      // Is it Func?      if ( strcmp ( g_Lexer.pstrCurrLexeme, "FUNC" ) == 0 )          g_Lexer.CurrToken = TOKEN_TYPE_FUNC;      // Is it Param?      if ( strcmp ( g_Lexer.pstrCurrLexeme, "PARAM" ) == 0 )          g_Lexer.CurrToken =TOKEN_TYPE_PARAM;      // Is it _RetVal?      if ( strcmp ( g_Lexer.pstrCurrLexeme, "_RETVAL" ) == 0 )          g_Lexer.CurrToken = TOKEN_TYPE_REG_RETVAL;// Is it an instruction?InstrLookup Instr;if ( GetInstrByMnemonic ( g_Lexer.pstrCurrLexeme, &amp; Instr ) )    g_Lexer.CurrToken = TOKEN_TYPE_INSTR;      return g_Lexer.CurrToken;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <div class="note warning"><p>词法分析一般用正则语言描述，通过状态机实现</p></div><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p> 编写代码难免有错误，编译器应该有能力指出错误，错误处理包含三个方面：<br> dectection,resynchroization and message output. 在这里为了简化，我们不会 <code>重新同步</code> ，只要发现错误立即打印并终止编译。涉及到的函数如下：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"> void ExitOnError ( char * pstrErrorMssg ){  // Print the message  printf ( "Fatal Error: %s.\n", pstrErrorMssg );  // Exit the program  Exit ();}void ExitOnCodeError ( char * pstrErrorMssg ){  // Print the message  printf ( "Error: %s.\n\n", pstrErrorMssg );  printf ( "Line %d\n", g_Lexer.iCurrSourceLine );  // Reduce all of the source line's spaces to tabs so it takes less  // space and so the caret lines up with the current token properly  char pstrSourceLine [ MAX_SOURCE_LINE_SIZE ];  strcpy ( pstrSourceLine, g_ppstrSourceCode [ g_Lexer.iCurrSourceLine ] );  // Loop through each character and replace tabs with spaces  for ( unsigned int iCurrCharIndex = 0;      iCurrCharIndex &lt; strlen ( pstrSourceLine ); ++ iCurrCharIndex )    if ( pstrSourceLine [ iCurrCharIndex ] == '\t' )  pstrSourceLine [ iCurrCharIndex ] = ' ';  // Print the offending source line  printf ( "%s", pstrSourceLine );  // Print a caret at the start of the (presumably) offending lexeme  for ( unsigned int iCurrSpace = 0; iCurrSpace &lt; g_Lexer.iIndex0;  ++ iCurrSpace )    printf ( " " );  printf ( "^\n" );  // Print message indicating that the script could not be assembled  printf ( "Could not assemble %s.\n", g_pstrExecFilename );  // Exit the program  Exit ();}void ExitOnCharExpectedError ( char cChar ){  // Create an error message based on the character  char * pstrErrorMssg = ( char * ) malloc ( strlen ( "' ' expected" ) );  sprintf ( pstrErrorMssg, "'%c' expected", cChar );  // Exit on the code error  ExitOnCodeError ( pstrErrorMssg );}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="语法分析（Parsing）"><a href="#语法分析（Parsing）" class="headerlink" title="语法分析（Parsing）"></a>语法分析（Parsing）</h2><p>完成词法分析后，接下来将进行语法分析，语法分析一般采用两种方法：自底向上和自顶向下。这里采用类似与 <code>递归下降</code> 的方法解析语句，由于 XASM 汇编语言比较简单，我们的语法分析中没有 <code>递归</code> 的调用。</p><p><img src="parser.png" alt="parser"></p><h3 id="初始化分析器"><a href="#初始化分析器" class="headerlink" title="初始化分析器"></a>初始化分析器</h3><p>首先初始化一些标志位和变量。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// ---- Initialize the script headerg_ScriptHeader.iStackSize = 0;g_ScriptHeader.iIsMainFuncPresent = FALSE;// ---- Set some initial variablesg_iInstrStreamSize = 0;g_iIsSetStackSizeFound = FALSE;g_ScriptHeader.iGlobalDataSize = 0;// Set the current function's flags and variablesint iIsFuncActive = FALSE;FuncNode * pCurrFunc;int iCurrFuncIndex;char pstrCurrFuncName [ MAX_IDENT_SIZE ];int iCurrFuncParamCount = 0;int iCurrFuncLocalDataSize = 0;// Create an instruction definition structure to hold instruction information// when dealing with instructions.InstrLookup CurrInstr;// Reset the lexerResetLexer ();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="解析指令"><a href="#解析指令" class="headerlink" title="解析指令"></a>解析指令</h3><h4 id="SetStackSize"><a href="#SetStackSize" class="headerlink" title="SetStackSize"></a>SetStackSize</h4><p><code>SetStackSize 1024</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">case TOKEN_TYPE_SETSTACKSIZE:  // SetStackSize can only be found in the global scope, so make sure we  // aren't in a function.  if ( iIsFuncActive )    ExitOnCodeError ( ERROR_MSSG_LOCAL_SETSTACKSIZE );  // It can only be found once, so make sure we haven't already found it  if ( g_iIsSetStackSizeFound )    ExitOnCodeError ( ERROR_MSSG_MULTIPLE_SETSTACKSIZES );  // Read the next lexeme, which should contain the stack size  if ( GetNextToken () != TOKEN_TYPE_INT )    ExitOnCodeError ( ERROR_MSSG_INVALID_STACK_SIZE );  // Convert the lexeme to an integer value from its string  // representation and store it in the script header  g_ScriptHeader.iStackSize = atoi ( GetCurrLexeme () );  // Mark the presence of SetStackSize for future encounters  g_iIsSetStackSizeFound = TRUE;  break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Func"><a href="#Func" class="headerlink" title="Func"></a>Func</h4><pre class="line-numbers language-none"><code class="language-none">Func MovePlayer{<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对应的 Token</p><pre class="line-numbers language-none"><code class="language-none">TOKEN_TYPE_FUNCTOKEN_TYPE_IDENTTOKEN_TYPE_NEWLINETOKEN_TYPE_OPEN_BRACE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在函数分析中，主要处理函数入口、设置 <code>iIsFuncAative</code> 标志位、设置函数索引、函数参数数量、函数局部变量数量、是否是主函数以及添加返回指令。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">case TOKEN_TYPE_FUNC:{  // First make sure we aren't in a function already, since nested functions  // are illegal  if ( iIsFuncActive )    ExitOnCodeError ( ERROR_MSSG_NESTED_FUNC );  // Read the next lexeme, which is the function name  if ( GetNextToken () != TOKEN_TYPE_IDENT )    ExitOnCodeError ( ERROR_MSSG_IDENT_EXPECTED );  char * pstrFuncName = GetCurrLexeme ();  // Calculate the function's entry point, which is the instruction  // immediately following the current one, which is in turn equal to the  // instruction stream size  int iEntryPoint = g_iInstrStreamSize;  // Try adding it to the function table, and print an error if it's already  // been declared  int iFuncIndex = AddFunc ( pstrFuncName, iEntryPoint );  if ( iFuncIndex == -1 )    ExitOnCodeError ( ERROR_MSSG_FUNC_REDEFINITION );  // Is this the _Main () function?  if ( strcmp ( pstrFuncName, MAIN_FUNC_NAME ) == 0 )  {    g_ScriptHeader.iIsMainFuncPresent = TRUE;    g_ScriptHeader.iMainFuncIndex = iFuncIndex;  }  // Set the function flag to true for any future encounters and  // reinitialize function tracking variables  iIsFuncActive = TRUE;  strcpy ( pstrCurrFuncName, pstrFuncName );  iCurrFuncIndex = iFuncIndex;  iCurrFuncParamCount = 0;  iCurrFuncLocalDataSize = 0;  // Read any number of line breaks until the opening brace is found  while ( GetNextToken () == TOKEN_TYPE_NEWLINE );    // Make sure the lexeme was an opening brace    if ( g_Lexer.CurrToken != TOKEN_TYPE_OPEN_BRACE )      ExitOnCharExpectedError ( '{' );  // All functions are automatically appended with Ret, so increment the  // required size of the instruction stream  ++ g_iInstrStreamSize;  break;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="note warning"><p>注意函数返回语句 Ret </p></div><p>当匹配到函数结束符时，写入函数参数数量、局部变量数量同时设置<code>iIsFuncAative</code> 标志位。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">case TOKEN_TYPE_CLOSE_BRACE:  // This should be closing a function, so make sure we're in one  if ( ! iIsFuncActive )    ExitOnCharExpectedError ( '}' );  // Set the fields we've collected  SetFuncInfo ( pstrCurrFuncName, iCurrFuncParamCount,  iCurrFuncLocalDataSize );  // Close the function  iIsFuncActive = FALSE;  break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Var-Var"><a href="#Var-Var" class="headerlink" title="Var/Var []"></a>Var/Var []</h4><p>由于变量和数组前面部分是一样的，所以需要向前看符号确定是否是数组。</p><p><img src="variable.png" alt="variable"></p><p>另一方面变量分为本地变量和全局变量，同时我们为每个栈帧保留了一个元素，以供虚拟机使用。</p><p><img src="stackframe.png" alt="stackframe"></p><p><img src="runtimeStack.png" alt="runtimeStack"></p><p>变量的解析：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">case TOKEN_TYPE_VAR:{  // Get the variable's identifier  if ( GetNextToken () != TOKEN_TYPE_IDENT )    ExitOnCodeError ( ERROR_MSSG_IDENT_EXPECTED );  char pstrIdent [ MAX_IDENT_SIZE ];  strcpy ( pstrIdent, GetCurrLexeme () );  // This version of the code only handles single variables  int iSize = 1;  // Determine the variable's index into the stack  // If the variable is local, then its stack index is always the local data  // size + 2 subtracted from zero  int iStackIndex;  if ( iIsFuncActive )    iStackIndex = -( iCurrFuncLocalDataSize + 2 );  // Otherwise it's global, so it's equal to the current global data size  else    iStackIndex = g_ScriptHeader.iGlobalDataSize;  // Attempt to add the symbol to the table  if ( AddSymbol ( pstrIdent, iSize, iStackIndex, iCurrFuncIndex ) == -1 )    ExitOnCodeError ( ERROR_MSSG_IDENT_REDEFINITION );  // Depending on the scope, increment either the local or global data size  // by the size of the variable  if ( iIsFuncActive )    iCurrFuncLocalDataSize += iSize;  else    g_ScriptHeader.iGlobalDataSize += iSize;  break;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组的格式如下：</p><pre class="line-numbers language-none"><code class="language-none">Var MyArray[1024]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其对应的 Token 序列为：</p><p><code>TOKEN_TYPE_VAR, TOKEN_TYPE_IDENT, TOKEN_TYPE_OPEN_BRACE, TOKEN_TYPE_INT, TOKEN_TYPE_CLOSE_BRACE</code></p><p>代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">case TOKEN_TYPE_VAR:{  // Get the variable's identifier  if ( GetNextToken () != TOKEN_TYPE_IDENT )    ExitOnCodeError ( ERROR_MSSG_IDENT_EXPECTED );  char pstrIdent [ MAX_IDENT_SIZE ];  strcpy ( pstrIdent, GetCurrLexeme () );  // Now determine its size by finding out if it's an array or not, otherwise  // default to 1.  int iSize = 1;  // Find out if an opening bracket lies ahead  if ( GetLookAheadChar () == '[' )  {    // Validate and consume the opening bracket    if ( GetNextToken () != TOKEN_TYPE_OPEN_BRACKET )      ExitOnCharExpectedError ( '[' );      // We're parsing an array, so the next lexeme should be an integer    // describing the array's size    if ( GetNextToken () != TOKEN_TYPE_INT )      ExitOnCodeError ( ERROR_MSSG_INVALID_ARRAY_SIZE );    // Convert the size lexeme to an integer value    iSize = atoi ( GetCurrLexeme () );    // Make sure the size is valid, in that it's greater than zero    if ( iSize &lt;= 0 )      ExitOnCodeError ( ERROR_MSSG_INVALID_ARRAY_SIZE );    // Make sure the closing bracket is present as well    if ( GetNextToken () != TOKEN_TYPE_CLOSE_BRACKET )      ExitOnCharExpectedError ( ']' );    }    // Determine the variable's index into the stack    // If the variable is local, then its stack index is always the local data    // size + 2 subtracted from zero    int iStackIndex;    if ( iIsFuncActive )      iStackIndex = -( iCurrFuncLocalDataSize + 2 );    // Otherwise it's global, so it's equal to the current global data size    else      iStackIndex = g_ScriptHeader.iGlobalDataSize;    // Attempt to add the symbol to the table    if ( AddSymbol ( pstrIdent, iSize, iStackIndex, iCurrFuncIndex ) == -1 )      ExitOnCodeError ( ERROR_MSSG_IDENT_REDEFINITION );    // Depending on the scope, increment either the local or global data size    // by the size of the variable    if ( iIsFuncActive )      iCurrFuncLocalDataSize += iSize;    else      g_ScriptHeader.iGlobalDataSize += iSize;    break;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="note warning"><p>注意变量作用域是本地还是全局，以及变量栈索引的计算</p></div><h4 id="Param"><a href="#Param" class="headerlink" title="Param"></a>Param</h4><p>根据栈帧的分配，函数参数的位置如下：</p><p><img src="param.png" alt="param"></p><p>参数格式为 <code>Param Y</code> ， Token 序列为 TOKEN_TYPE_PARAM,  TOKEN_TYPE_IDENT</p><p>代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">case TOKEN_TYPE_PARAM:{  // Read the next token to get the identifier  if ( GetNextToken () != TOKEN_TYPE_IDENT )    ExitOnCodeError ( ERROR_MSSG_IDENT_EXPECTED );  // Read the identifier, which is the current lexeme  char * pstrIdent = GetCurrLexeme ();  // Calculate the parameter's stack index  int iStackIndex = -( pCurrFunc-&gt;iLocalDataSize + 2 +  ( iCurrFuncParamCount + 1 ) );  // Add the parameter to the symbol table  if ( AddSymbol ( pstrIdent, 1, iStackIndex, iCurrFuncIndex ) == -1 )    ExitOnCodeError ( ERROR_MSSG_IDENT_REDEFINITION );  // Increment the current parameter count  ++ iCurrFuncParamCount;  break;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Line-Labels"><a href="#Line-Labels" class="headerlink" title="Line Labels"></a>Line Labels</h4><p>标签格式 <code>MyLabel:</code> 其 Token 序列为 TOKEN_TYPE_IDENT TOKEN_TYPE_COLON<br>代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">case TOKEN_TYPE_IDENT:{  // Make sure it's a line label  if ( GetLookAheadChar () != ':' )    ExitOnCodeError ( ERROR_MSSG_INVALID_INSTR );  // Make sure we're in a function, since labels can only appear there  if ( ! iIsFuncActive )    ExitOnCodeError ( ERROR_MSSG_GLOBAL_LINE_LABEL );  // The current lexeme is the label's identifier  char * pstrIdent = GetCurrLexeme ();  // The target instruction is always the value of the current  // instruction count, which is the current size - 1  int iTargetIndex = g_iInstrStreamSize - 1;  // Save the label's function index as well  int iFuncIndex = iCurrFuncIndex;  // Try adding the label to the label table, and print an error if it  // already exists  if ( AddLabel ( pstrIdent, iTargetIndex, iFuncIndex ) == -1 )    ExitOnCodeError ( ERROR_MSSG_LINE_LABEL_REDEFINITION );  break;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="note warning"><p>注意标签代表的指令为 g_iInstrStreamSize - 1</p></div><h4 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h4><p>在解析指令是只需要根据指令查找表，逐一比对当前 Token 和 当前指令的各个部分即可。指令查找表中每一条指令包含以下内容：</p><ol><li>指令助记符</li><li>操作码</li><li>操作数数量</li><li>操作数</li></ol><p>操作符字段掩码如下：<br><img src="bitfieldMask.png" alt="bitfieldMask"></p><p>在解析的过程中，首先判断 Token 类型，然后验证是否和当前操作符类型一致，整型、浮点数和 _RetVal 相对简单，而 <code>TOKEN_TYPE_IDENT</code> 可能对应以下几种操作符：</p><ul><li>Variables/Array Indices</li><li>Line Labels</li><li>Function Names</li><li>Host API Calls</li></ul><p>具体哪种类型需要根据下一个 Token 判断。</p><h2 id="构建-XSE-可执行文件"><a href="#构建-XSE-可执行文件" class="headerlink" title="构建 .XSE 可执行文件"></a>构建 .XSE 可执行文件</h2><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>按照顺序将 Header 写入文件中。</p><h3 id="指令流"><a href="#指令流" class="headerlink" title="指令流"></a>指令流</h3><p>写入指令流的步骤如下：</p><ol><li>写入指令数量</li><li>循环每个指令，写入操作码和操作数数量</li><li>循环操作数数组，写入操作数类型和操作数数据</li></ol><h3 id="String-Table-Function-Table-and-Host-Api-Table"><a href="#String-Table-Function-Table-and-Host-Api-Table" class="headerlink" title="String Table,Function Table and Host Api Table"></a>String Table,Function Table and Host Api Table</h3><p>直接写入对应表格中的数据即可。</p><h2 id="汇编过程"><a href="#汇编过程" class="headerlink" title="汇编过程"></a>汇编过程</h2><h3 id="加载源文件"><a href="#加载源文件" class="headerlink" title="加载源文件"></a>加载源文件</h3><p><img src="sourceFile.png" alt="sourceFile"></p><h3 id="First-Pass"><a href="#First-Pass" class="headerlink" title="First Pass"></a>First Pass</h3><p>由于跳转指令是标签时，存在向前引用问题，所以汇编过程采用两阶段汇编。第一阶段主要构建 Label Table,Function Table 和 Sysmbol Table。<br><img src="firstPass.png" alt="firstPass"></p><h3 id="Second-Pass"><a href="#Second-Pass" class="headerlink" title="Second Pass"></a>Second Pass</h3><p>第二阶段主要是解析指令。</p><h2 id="生成可执行文件-XSE"><a href="#生成可执行文件-XSE" class="headerlink" title="生成可执行文件 .XSE"></a>生成可执行文件 .XSE</h2><p>本阶段将前面搜集的各种数据结构以二进制格式写入执行文件中。</p><p><img src="xse.png" alt="xse"></p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 重学计算机系列 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring研究</title>
      <link href="/2018/05/25/spring-yan-jiu/"/>
      <url>/2018/05/25/spring-yan-jiu/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>##<br>##<br>##</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 框架 </category>
          
          <category> spring </category>
          
          <category> IOC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 框架 </tag>
            
            <tag> spring </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全面介绍递归-思考递归的方法</title>
      <link href="/2018/05/22/quan-mian-jie-shao-di-gui-si-kao-di-gui-de-fang-fa/"/>
      <url>/2018/05/22/quan-mian-jie-shao-di-gui-si-kao-di-gui-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>同一个方法多次使用，我们就可以试图对其抽象、总结，看能不能形成方法论，从而指导我们更快解决类似问题，设计模式便是很好的代表。递归设计也有一定的模式可寻，本章简要讨论递归设计的一般步骤，以及通过图例的方式帮助我们进行递归设计。</p><a id="more"></a><p>##<br>##<br>##</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常与错误处理探讨-异步错误处理(下）</title>
      <link href="/2018/05/19/yi-chang-yu-cuo-wu-chu-li-tan-tao-yi-bu-cuo-wu-chu-li-xia/"/>
      <url>/2018/05/19/yi-chang-yu-cuo-wu-chu-li-tan-tao-yi-bu-cuo-wu-chu-li-xia/</url>
      
        <content type="html"><![CDATA[<p>由前面文章知道，同步环境可以使用错误返回码、异常等方式处理异常，在异步环境下，捕获异常的代码和抛出异常的代码不在同一个上下文（有可能是同一个线程），所以错误返回码和  <code>try catch</code> 方式都会失效。本章结束异步环境的异常处理方式。</p><a id="more"></a><h2 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h2><p>假设有如下异步代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token keyword">async</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'async error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">async</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'after async'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'error caught:'</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//永远不会执行</span><span class="token punctuation">}</span><span class="token comment">//after async</span><span class="token comment">// Uncaught Error: async error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述异常捕获失败的原因是，由于 <code>async</code> 是异步的，在 <code>try catch</code> 执行时并没有异常，而 <code>async</code> 的异常发生在不同的上下文。</p><p>通过回调函数可以解决上述问题：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">successCallback</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"It succeeded with "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">failureCallback</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"It failed with "</span> <span class="token operator">+</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">doSomething</span><span class="token punctuation">(</span>successCallback<span class="token punctuation">,</span> failureCallback<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是存在多层嵌套调用时，就会发生所谓的 <code>Callback Hell </code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">doSomethingElse</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newResult</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">doThirdThing</span><span class="token punctuation">(</span>newResult<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">finalResult</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Got the final result: '</span> <span class="token operator">+</span> finalResult<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> failureCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> failureCallback<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> failureCallback<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="javascript-Promise"><a href="#javascript-Promise" class="headerlink" title="javascript Promise"></a>javascript Promise</h3><p>Promise 是异步编程的一种解决方案，比传统的回调函数和事件解决方案更合理和更强大。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。一旦状态改变，就不会再变，任何时候都可以得到这个结果。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// ... some code</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment">/* 异步操作成功 */</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token function">doSomethingElse</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">newResult</span> <span class="token operator">=&gt;</span> <span class="token function">doThirdThing</span><span class="token punctuation">(</span>newResult<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">finalResult</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Got the final result: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>finalResult<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>failureCallback<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用 <code>ajax</code> 封装的 <code>promise</code> 实例</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">getJSON</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token function-variable function">handler</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>readyState <span class="token operator">!==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    client<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>    client<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> handler<span class="token punctuation">;</span>    client<span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">"json"</span><span class="token punctuation">;</span>    client<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">"Accept"</span><span class="token punctuation">,</span> <span class="token string">"application/json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    client<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> promise<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token string">"/posts.json"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">json</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Contents: '</span> <span class="token operator">+</span> json<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'出错了'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token string">'/posts.json'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">posts</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// ...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'发生错误！'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下两种方法是等价的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 写法一</span><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 写法二</span><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然 <code>then</code> 里面也可以定义回调处理错误，但是建议用 <code>catch</code> ，因为 <code>catch</code> 可以捕获前面 <code>then</code> 参数的异常。</p><div class="note warning"><p>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p></div><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">someAsyncThing</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 下面一行会报错，因为x没有声明</span>    <span class="token function">resolve</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><p><span class="token function">someAsyncThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">‘everything is great’</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></p></code><p><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Uncaught (in promise) ReferenceError: x is not defined</span><br><span class="token comment">// 123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></p></pre>:hexoPostRenderEscape–&gt;<p></p><p>catch 方法中还可以继续抛出异常，只要后面跟有 catch 就能继续捕获异常</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">someAsyncThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">someOtherAsyncThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'oh no'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 下面一行会报错，因为y没有声明</span>  y <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'carry on'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// oh no [ReferenceError: x is not defined]</span><span class="token comment">// carry on [ReferenceError: y is not defined]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="java-异步编程中的-Promise-模式"><a href="#java-异步编程中的-Promise-模式" class="headerlink" title="java 异步编程中的 Promise 模式"></a>java 异步编程中的 Promise 模式</h3><p>在 JDK 1.8 里也引入了类 JavaScript promise 模式的CompletableFuture。这个类提供了大量的异步编程中 Promise 的各种方式。下面例举几个。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">CompletableFuture.supplyAsync(this::findReceiver)                 .thenApply(this::sendMsg)                 .thenAccept(this::notify);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的这个链式处理和 JavaScript 中的then()方法很像，其中的 supplyAsync() 表示执行一个异步方法，而 thenApply() 表示执行成功后再串联另外一个异步方法，最后是 thenAccept() 来处理最终结果。<br>CompletableFuture 异常处理如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">CompletableFuture.supplyAsync(Integer::parseInt) // 输入: "ILLEGAL"                 .thenApply(r -&gt; r * 2 * Math.PI)                 .thenApply(s -&gt; "apply&gt;&gt; " + s)                 .exceptionally(ex -&gt; "Error: " + ex.getMessage());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Go-语言也可以实现类似的-Promise-模式"><a href="#Go-语言也可以实现类似的-Promise-模式" class="headerlink" title="Go 语言也可以实现类似的 Promise 模式"></a>Go 语言也可以实现类似的 Promise 模式</h3><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，类似于协程。可以将 <code>Generator</code> 看作一个状态机，内部封装了很多状态。<br>Generator 运行模式如下<br><img src="generator.png" alt="generator"></p><p><code>Generator.prototype.throw()</code> 可以抛出异常，如果 Generator 内部有 catch 语句，则会捕获异常，否则会继续传播到外层函数。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var g = function* () {  try {    yield;  } catch (e) {    console.log('内部捕获', e);  }};var i = g();i.next();try {  i.throw('a');  i.throw('b');} catch (e) {  console.log('外部捕获', e);}// 内部捕获 a// 外部捕获 b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于 generator 异常需要注意以下几点：</p><ol><li>如果外部和内部函数都没有 catch 语句，则程序会终止。</li><li>g.throw 会顺带执行一次 next 函数</li><li>要在 generator 内部捕获异常，需要首先调用一次 next 函数</li><li>要注意，不要混淆遍历器对象的throw方法和全局的throw命令。</li><li>Generator 函数和外层函数可以相互传递异常。一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true</li></ol><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function* g() {  yield 1;  console.log('throwing an exception');//3  throw new Error('generator broke!');  yield 2;  yield 3;}function log(generator) {  var v;  console.log('starting generator');//1  try {    v = generator.next();    console.log('第一次运行next方法', v);//2  } catch (err) {    console.log('捕捉错误', v);//4  }  try {    v = generator.next();    console.log('第二次运行next方法', v);  } catch (err) {    console.log('捕捉错误', v);  }  try {    v = generator.next();    console.log('第三次运行next方法', v);//5  } catch (err) {    console.log('捕捉错误', v);  }  console.log('caller done');//6}log(g());// starting generator// 第一次运行next方法 { value: 1, done: false }// throwing an exception// 捕捉错误 { value: 1, done: false }// 第三次运行next方法 { value: undefined, done: true }// caller done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>async 就是 generator 的语法糖。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'出错了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// Error：出错了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。<br>promise 模式同样会导致太多的嵌套调用，而 async 更加清晰、易懂。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function chainAnimationsPromise(elem, animations) {  // 变量ret用来保存上一个动画的返回值  let ret = null;  // 新建一个空的Promise  let p = Promise.resolve();  // 使用then方法，添加所有动画  for(let anim of animations) {    p = p.then(function(val) {      ret = val;      return anim(elem);    });  }  // 返回一个部署了错误捕捉机制的Promise  return p.catch(function(e) {    /* 忽略错误，继续执行 */  }).then(function() {    return ret;  });}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">chainAnimationsGenerator</span><span class="token punctuation">(</span><span class="token parameter">elem<span class="token punctuation">,</span> animations</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> anim <span class="token keyword">of</span> animations<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">anim</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">/* 忽略错误，继续执行 */</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C# 中也有类似的 async/await 的实现。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://es6.ruanyifeng.com/#docs/async">http://es6.ruanyifeng.com/#docs/async</a></li><li><a href="https://www.jianshu.com/p/78dfb38ac3d7">https://www.jianshu.com/p/78dfb38ac3d7</a><hr></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 错误 </category>
          
          <category> 异常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> 错误 </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常与错误处理探讨-C# Java异常处理(中）</title>
      <link href="/2018/05/19/yi-chang-yu-cuo-wu-chu-li-tan-tao-c-java-yi-chang-chu-li-zhong/"/>
      <url>/2018/05/19/yi-chang-yu-cuo-wu-chu-li-tan-tao-c-java-yi-chang-chu-li-zhong/</url>
      
        <content type="html"><![CDATA[<p>从 <code>异常与错误处理探讨-概念介绍</code> 知道， Java 和 C# 都有语言内置异常模块。本章中，我们会探讨两者异常的异同和一些最佳实践。</p><a id="more"></a><h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p>java 和 C# 都有一套面向对象的异常继承体系，异常作为一个对象存在，拥有异常栈和异常链，使用多态性能够对异常进行分类处理。</p><h3 id="Java异常体系"><a href="#Java异常体系" class="headerlink" title="Java异常体系"></a>Java异常体系</h3><p>java异常体系如下：<br><img src="javaexception.png" alt="javaexception"></p><p>从上图可知，java 异常体系分为三大块：<br>Checked exceptions 检查异常是必须在函数签名体现，并且编译器会强制检查的异常。从意图上讲，检查异常是指在正常系统操作中可以预期的问题，这些异常是可以恢复的，比如网络问题、文件不存在等。对于检查异常正确的响应是重试或者提醒用户重新输入。<br>Unchecked exceptions 非检查异常不需要在 throw 语句声明，编译器也不会强制要求你处理。非检查异常继承自 RuntimeException 如 NullPointerException ，它一般是运行时产生、几乎不用重试，我们应该用日志记录它。<br>Errors 错误代表严重的运行时故障，一般会导致程序崩溃，几乎不能恢复。好的日志能帮助我们快速定位错误并修复。</p><h3 id="C-异常"><a href="#C-异常" class="headerlink" title="C# 异常"></a>C# 异常</h3><p>C# 包含两种类型的异常 <code>ApplicationException</code> 和 <code>SystemException</code> ，C# 没有检查异常和非检查异常的区别，都是运行时异常，用户自定义异常应该继承 <code>ApplicationException</code> ，<code>SystemException</code> 是功系统内部使用。</p><h2 id="抛出和捕获异常"><a href="#抛出和捕获异常" class="headerlink" title="抛出和捕获异常"></a>抛出和捕获异常</h2><p>在 java 和 C# 中我们都可以使用 try catch throw 子句捕获和抛出异常，其异常捕获如下图所示：<br><img src="exceptionmethod.png" alt="exceptionmethod"></p><p>我们可以处理多个异常类型：</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">static void ReadFile(string fileName){    // Exceptions could be thrown in the code below    try    {        TextReader reader = new StreamReader(fileName);        string line = reader.ReadLine();        Console.WriteLine(line);        reader.Close();    }    catch (FileNotFoundException fnfe)    {        // Exception handler for FileNotFoundException        // We just inform the user that there is no such file        Console.WriteLine(            "The file '{0}' is not found.", fileName);    }    catch (IOException ioe)    {        // Exception handler for other input/output exceptions        // We just print the stack trace on the console        Console.WriteLine(ioe.StackTrace);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>异常会和 catch 语句依次匹配，找到匹配的异常处理程序后便停止。<br>我们可以遍历整个异常栈，如果不能处理异常，可以重新包装异常信息后再次抛出。</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">static void Main(){    try    {        string fileName = "WrongFileName.txt";        ReadFile(fileName);    }    catch (Exception e)    {        throw new ApplicationException("Smth. bad happened", e);    }}static void ReadFile(string fileName){    TextReader reader = new StreamReader(fileName);    string line = reader.ReadLine();    Console.WriteLine(line);    reader.Close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="finally与资源清理"><a href="#finally与资源清理" class="headerlink" title="finally与资源清理"></a>finally与资源清理</h2><p>没考虑到异常往往会导致资源未清理，如下所示：</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">static void ReadFile(string fileName){    TextReader reader = new StreamReader(fileName);    string line = reader.ReadLine();    Console.WriteLine(line);    reader.Close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>finally 语义保证了无论如何，资源都可以被成功清理：</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">static void ReadFile(string fileName){    TextReader reader = null;    try    {        reader = new StreamReader(fileName);        string line = reader.ReadLine();        Console.WriteLine(line);    }    finally    {        // Always close "reader" (if it was opened)        if (reader != null)        {            reader.Close();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更紧凑的方式：</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">static void ReadFile(string fileName){    TextReader reader = new StreamReader(fileName);    try    {        string line = reader.ReadLine();        Console.WriteLine(line);    }    finally    {        reader.Close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当有多个资源需要清理时：</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">static void ReadFile(string filename){    Resource r1 = new Resource1();    try    {        Resource r2 = new Resource2();        try        {            // Use r1 and r2        }        finally        {            r2.Release();        }    }    finally    {        r1.Release();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">static void ReadFile(string filename){    Resource r1 = null;    Resource r2 = null;    try    {        Resource r1 = new Resource1();        Resource r2 = new Resource2();        // Use r1 and r2    }    finally    {        if (r1 != null)        {            r1.Release();        }        if (r2 != null)        {            r2.Release();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 java 中当finally 有 return 语句时，可能会覆盖 catch 中的返回值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class Main {    public static void main(String[] args) {        String str = new Main().openFile();        System.out.println(str);    }    public String openFile() {        try {            FileInputStream inputStream = new FileInputStream("d:/a.txt");            int ch = inputStream.read();            System.out.println("aaa");            return "step1";        } catch (FileNotFoundException e) {            System.out.println("file not found");            return "step2";        }catch (IOException e) {            System.out.println("io exception");            return "step3";        }finally{            System.out.println("finally block");            return "finally";        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出为：</p><pre class="line-numbers language-none"><code class="language-none">file not foundfinally blockfinally<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>C# 中如果类实现了 <code>IDisposable</code> 接口，资源清理可以使用 <code>using</code> 关键字：</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">using (StreamReader reader = new StreamReader(fileName)){    // Use the reader here}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当然也可以使用嵌套的 <code>using</code></p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">using (ResourceType r1 = …)    using (ResourceType r2 = …)        …            using (ResourceType rN = …)                statements;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">using (ResourceType r1 = …, r2 = …, …, rN = …){    statements;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 java 1.7 中，也提出了类似的 <code>try-with-resources</code> ，相应的资源必须实现 <code>java.lang.AutoCloseable</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">static String readFirstLineFromFile(String path) throws IOException {    try (BufferedReader br =                   new BufferedReader(new FileReader(path))) {        return br.readLine();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="异常的优点"><a href="#异常的优点" class="headerlink" title="异常的优点"></a>异常的优点</h2><p>异常相对于其他错误处理方法（返回值、全局状态变量、信号）有哪些优点呢？</p><h3 id="分离异常处理代码和正常业务逻辑"><a href="#分离异常处理代码和正常业务逻辑" class="headerlink" title="分离异常处理代码和正常业务逻辑"></a>分离异常处理代码和正常业务逻辑</h3><p>试想以下代码</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">void ReadFile(){    OpenTheFile();    while (FileHasMoreLines)    {        ReadNextLineFromTheFile();        PrintTheLine();    }    CloseTheFile();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 打开文件、读取行、打印行、关闭文件都有可能出错，如果采用返回值处理，整个代码结构如下所示：</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">int ReadFile(){    errorCode = 0;    openFileErrorCode = OpenTheFile();    // Check whether the file is open    if (openFileErrorCode == 0)    {        while (FileHasMoreLines)        {            readLineErrorCode = ReadNextLineFromTheFile();            if (readLineErrorCode == 0)            {                // Line has been read properly                PrintTheLine();            }            else            {                // Error during line reading                errorCode = -1;                break;            }        }        closeFileErrorCode = CloseTheFile();        if (closeFileErrorCode != 0 &amp;&amp; errorCode == 0)        {            errorCode = -2;        }        else        {            errorCode = -3;        }    }    else if (openFileErrorCode == -1)    {        // File does not exist        errorCode = -4;    }    else if (openFileErrorCode == -2)    {        // File can't be open        errorCode = -5;    }    return errorCode;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现返回值处理方式让代码难懂，结构也变得像<code>意大利面条</code>一样复杂。<br>而异常处理方式便清晰多了：</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">void ReadFile(){    try    {        OpenTheFile();        while (FileHasMoreLines)        {            ReadNextLineFromTheFile();            PrintTheLine();        }    }    catch (FileNotFoundException)    {        DoSomething();    }    catch (IOException)    {        DoSomethingElse();    }    finally    {        CloseTheFile();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="将异常分组"><a href="#将异常分组" class="headerlink" title="将异常分组"></a>将异常分组</h4><p>面向的多态性使得我们可以对某一类异常集中处理：</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">catch (IOException e){    // Handle IOException and all its descendants}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="在最合适的地方处理异常"><a href="#在最合适的地方处理异常" class="headerlink" title="在最合适的地方处理异常"></a>在最合适的地方处理异常</h4><p>假设有如下三个方法：</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">Method3(){    Method2();}Method2(){    Method1();}Method1(){    ReadFile();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 Method3 对 Method1 的错误感兴趣，用返回值处理则形式如下：</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">void Method3(){    errorCode = Method2();    if (errorCode != 0)        process the error;    else        DoTheActualWork();}int Method2(){    errorCode = Method1();    if (errorCode != 0)        return errorCode;    else        DoTheActualWork();}int Method1(){    errorCode = ReadFile();    if (errorCode != 0)        return errorCode;    else        DoTheActualWork();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果采用返回值，我们必须分析错误代码，然后逐层将其传递，当调用层次比较深时，情况将变得十分复杂。<br>而用异常的传播特点却可以轻松实现：</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">void Method3(){    try    {        Method2();    }    catch (Exception e)    {        process the exception;    }}void Method2(){    Method1();}void Method1(){    ReadFile();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h4 id="不要用异常来控制流程、只有在必要的地方使用异常"><a href="#不要用异常来控制流程、只有在必要的地方使用异常" class="headerlink" title="不要用异常来控制流程、只有在必要的地方使用异常"></a>不要用异常来控制流程、只有在必要的地方使用异常</h4><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">static void ReadFile(string filename){    StreamReader reader = null;    try    {        reader = new StreamReader(filename);        while (!reader.EndOfStream)        {            string line = reader.ReadLine();            Console.WriteLine(line);        }        reader.Close();    }    catch (FileNotFoundException)    {        Console.WriteLine(            "The file '{0}' does not exist.", filename);    }    finally    {        if (reader != null)        {            reader.Close();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于找不到文件十分普遍，将希望全部寄托于异常代价太大，我们可以多做写检查和校验，提前避免异常：</p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">static void ReadFile(string fileName){    if (!File.Exists(fileName))    {        Console.WriteLine(            "The file '{0}' does not exist.", fileName);        return;    }    StreamReader reader = new StreamReader(fileName);    using (reader)    {        while (!reader.EndOfStream)        {            string line = reader.ReadLine();            Console.WriteLine(line);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>Validate User</li><li>Insert User</li><li>Validate address</li><li>Insert address</li><li>If problem the Rollback everything<br>以上流程可以稍加修改就能避免不必要的异常处理：</li><li>Validate User</li><li>Validate address</li><li>Insert User</li><li>Insert address</li><li>If problem the Rollback everything<h4 id="不要让用户看到不该看到的异常信息"><a href="#不要让用户看到不该看到的异常信息" class="headerlink" title="不要让用户看到不该看到的异常信息"></a>不要让用户看到不该看到的异常信息</h4><img src="extouser.png" alt="extouser"><br>同样的敏感信息也不要呈现给用户：<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Main { public static void main(String[] args) {     try {         String user = null;         String pwd = null;         login(user,pwd);     } catch (Exception e) {         System.out.println(e.getMessage());     } } public static void login(String user,String pwd) {     if(user==null||pwd==null)         throw new NullPointerException("用户名或者密码为空");     //... }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="将异常抛出在合适的抽象层"><a href="#将异常抛出在合适的抽象层" class="headerlink" title="将异常抛出在合适的抽象层"></a>将异常抛出在合适的抽象层</h4></li></ol><p>在我们抛出异常时要注意抛出的异常要和抛出方法所表达的上下文相符，例如处理数组的方法抛出 <code>IndexOutOfRangeException</code> 是合适的，但是处理利息的方法抛出 <code>IndexOutOfRangeException</code> 就不合适了，它可以抛出如 <code>InvalidInterestException</code> 异常。</p><h4 id="千万不要生吞异常"><a href="#千万不要生吞异常" class="headerlink" title="千万不要生吞异常"></a>千万不要生吞异常</h4><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">try{    string fileName = "WrongTextFile.txt";    ReadFile(fileName);}catch (Exception e){ }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>毫无疑问，这和忽略错误一样可怕！</p><h4 id="异常信息足够完整"><a href="#异常信息足够完整" class="headerlink" title="异常信息足够完整"></a>异常信息足够完整</h4><p>异常信息不能含糊不清、太简短，更不能提供错误的信息。一般要包括异常发生的时间、地点和其他上下文信息。</p><pre class="line-numbers language-none"><code class="language-none">Error.  Bad!Error reading settings file.  not good!Error reading settings file: C:\Users\Administrator\MyApp\MyApp.settings ok!Error reading settings file: C:\Users\Administrator\MyApp\MyApp.settings. Number expected at line 17.  good!throw new FormatException(    string.Format("Invalid character at position {0}. " +    "Number expected but character '{1}' found.", index, ch));  better!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="保证异常发生后程序的状态一致性"><a href="#保证异常发生后程序的状态一致性" class="headerlink" title="保证异常发生后程序的状态一致性"></a>保证异常发生后程序的状态一致性</h4><p><strong>A method should either do the work it is created for or throw an exception. In case of wrong input the method should throw an exception and should not return a wrong result!</strong></p><p>假设我们要拷贝一个大文件到 USB，拷贝过程中发生异常，以下几种情况哪种是正确的呢？</p><ul><li><del>The file is not copied and no error message is shown.</del></li><li><del>The file is partially copied and no error message is shown.</del></li><li><del>The file is partially copied and error message is shown.</del></li><li>The file is not copied and error message is shown.<br>一定要注意异常安全问题，保证异常发生后程序处于明确的状态。</li></ul><h4 id="只捕获能够处理的异常"><a href="#只捕获能够处理的异常" class="headerlink" title="只捕获能够处理的异常"></a>只捕获能够处理的异常</h4><p><strong>A method should not catch all exceptions – it should only catch the ones it can process correctly.</strong><br>如果不知道怎么处理异常，继续传播吧！</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">catch (NoSuchMethodException e) {   throw e; //Avoid this as it doesn't help anything}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>不要为了捕获异常而捕获异常。</p><h4 id="抛出和捕获的异常类型尽量具体"><a href="#抛出和捕获的异常类型尽量具体" class="headerlink" title="抛出和捕获的异常类型尽量具体"></a>抛出和捕获的异常类型尽量具体</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void foo() throws Exception { //Incorrect way}public void foo() throws SpecificException1, SpecificException2 { //Correct way}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">try{    ReadFile("CorrectTextFile.txt");}catch (Exception){    Console.WriteLine("File not found.");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>试想下当读取文件时，该文件未授权则抛出的是 <code>UnauthorizedAccessException</code> 异常，如果通通用 Exception 捕获，输出的却是 <code>File not found.</code> ，这无疑会误导我们。</p><h4 id="注意不要丢失异常"><a href="#注意不要丢失异常" class="headerlink" title="注意不要丢失异常"></a>注意不要丢失异常</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">catch (NoSuchMethodException e) {   throw new MyServiceException("Some information: " + e.getMessage());  //Incorrect way}catch (NoSuchMethodException e) {   throw new MyServiceException("Some information: " , e);  //Correct way}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="避免重复记录异常信息"><a href="#避免重复记录异常信息" class="headerlink" title="避免重复记录异常信息"></a>避免重复记录异常信息</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">catch (NoSuchMethodException e) {   LOGGER.error("Some information", e);   throw e;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同时记录和抛出异常会重复记录异常信息，当我们排查错误时会十分困惑异常发生的真正位置。</p><h4 id="避免在finally里面抛出异常"><a href="#避免在finally里面抛出异常" class="headerlink" title="避免在finally里面抛出异常"></a>避免在finally里面抛出异常</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">try {  someMethod();  //Throws exceptionOne} finally {  cleanUp();    //If finally also threw any exception the exceptionOne will be lost forever}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在finally里面尽量不要抛出异常，如果实在有可能抛出异常，做好日志记录，否则异常会永远丢失。</p><h4 id="不要使用-printStackTrace-类似的方法"><a href="#不要使用-printStackTrace-类似的方法" class="headerlink" title="不要使用 printStackTrace() 类似的方法"></a>不要使用 printStackTrace() 类似的方法</h4><p>首先 printStackTrace() 是将异常输出到 <code>stardard error stream</code> ，在复杂的环境很难判断输出的地方，同时缺乏上下文信息，其他开发人员看到异常信息将无从下手。</p><h4 id="不处理异常就不需要使用catch语句"><a href="#不处理异常就不需要使用catch语句" class="headerlink" title="不处理异常就不需要使用catch语句"></a>不处理异常就不需要使用catch语句</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">try {  someMethod();  //Method 2} finally {  cleanUp();    //do cleanup here}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Throw-early-catch-late"><a href="#Throw-early-catch-late" class="headerlink" title="Throw early catch late"></a>Throw early catch late</h4><p>尽可能早的抛出异常，有足够信息时才处理异常。即在低层次抛出异常，高层次处理异常。<br>This principle implicitly says that you will be more likely to throw it in the low-level methods, where you will be checking if single values are null or not appropriate. And you will be making the exception climb the stack trace for quite several levels until you reach a sufficient level of abstraction to be able to handle the problem.</p><h4 id="尽量减少异常日志信息"><a href="#尽量减少异常日志信息" class="headerlink" title="尽量减少异常日志信息"></a>尽量减少异常日志信息</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">--------bad-------LOGGER.debug("Using cache sector A");LOGGER.debug("Using retry sector B");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">--------good-------LOGGER.debug("Using cache sector A, using retry sector B");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="当线程被中断时，终止线程"><a href="#当线程被中断时，终止线程" class="headerlink" title="当线程被中断时，终止线程"></a>当线程被中断时，终止线程</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">while (true) {  try {    Thread.sleep(100000);  } catch (InterruptedException e) {} //Don't do this  doSomethingCool();}while (true) {  try {    Thread.sleep(100000);  } catch (InterruptedException e) {    break;  }}doSomethingCool();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="用模板方法代替重复的-try-catch"><a href="#用模板方法代替重复的-try-catch" class="headerlink" title="用模板方法代替重复的 try catch"></a>用模板方法代替重复的 try catch</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class DBUtil{    public static void closeConnection(Connection conn){        try{            conn.close();        } catch(Exception ex){            //Log Exception - Cannot close connection        }    }}public void dataAccessCode() {    Connection conn = null;    try{        conn = getConnection();        ....    } finally{        DBUtil.closeConnection(conn);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="为所有异常建立相关的文档"><a href="#为所有异常建立相关的文档" class="headerlink" title="为所有异常建立相关的文档"></a>为所有异常建立相关的文档</h4><p>最好为可能抛出异常的方法建立相关文档说明。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.introprogramming.info/english-intro-csharp-book/read-online/chapter-12-exception-handling/#_Toc362296485">http://www.introprogramming.info/english-intro-csharp-book/read-online/chapter-12-exception-handling/#_Toc362296485</a></li><li><a href="https://www.logicbig.com/tutorials/core-java-tutorial/java-language/checked-unchecked-exceptions.html">https://www.logicbig.com/tutorials/core-java-tutorial/java-language/checked-unchecked-exceptions.html</a></li><li><a href="https://howtodoinjava.com/best-practices/java-exception-handling-best-practices/">https://howtodoinjava.com/best-practices/java-exception-handling-best-practices/</a></li><li><a href="https://juejin.im/post/5ae66791f265da0b92655c5d#heading-19">https://juejin.im/post/5ae66791f265da0b92655c5d#heading-19</a></li><li><a href="https://www.yegor256.com/2015/07/28/checked-vs-unchecked-exceptions.html">https://www.yegor256.com/2015/07/28/checked-vs-unchecked-exceptions.html</a></li><li><a href="https://blog.takipi.com/the-surprising-truth-of-java-exceptions-what-is-really-going-on-under-the-hood/">https://blog.takipi.com/the-surprising-truth-of-java-exceptions-what-is-really-going-on-under-the-hood/</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch09-01-unrecoverable-errors-with-panic.html">https://doc.rust-lang.org/book/second-edition/ch09-01-unrecoverable-errors-with-panic.html</a></li><li><a href="https://pdfs.semanticscholar.org/a834/36e314643ddb40bc7f84554e33488df4b51e.pdf">https://pdfs.semanticscholar.org/a834/36e314643ddb40bc7f84554e33488df4b51e.pdf</a></li><li><a href="http://seclab.cs.sunysb.edu/sekar/cse307/ln/exception4.pdf">http://seclab.cs.sunysb.edu/sekar/cse307/ln/exception4.pdf</a></li><li><a href="https://www.inf.unibz.it/~calvanese/teaching/ip/lecture-notes/uni10.pdf">https://www.inf.unibz.it/~calvanese/teaching/ip/lecture-notes/uni10.pdf</a></li><li><a href="https://www.zhihu.com/question/35193523">https://www.zhihu.com/question/35193523</a><hr></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 错误 </category>
          
          <category> 异常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> 错误 </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常与错误处理探讨-概念介绍（上）</title>
      <link href="/2018/05/19/yi-chang-yu-cuo-wu-chu-li-tan-tao-gai-nian-jie-shao-shang/"/>
      <url>/2018/05/19/yi-chang-yu-cuo-wu-chu-li-tan-tao-gai-nian-jie-shao-shang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>人总会犯错，悔过是圣人，坚持就是恶魔</p><footer><strong>本杰明.富兰克林</strong></footer></blockquote><a id="more"></a><h2 id="错误来源"><a href="#错误来源" class="headerlink" title="错误来源"></a>错误来源</h2><p>错误可能并且一定会发生。几乎任何操作都会带来意想不到的结果。网络异常、磁盘空间耗完、内存溢出等等。如果不对这些错误情况处理，毫无疑问我们的软件将脆弱不堪。一般错误可以归为以下几类：</p><h3 id="用户错误"><a href="#用户错误" class="headerlink" title="用户错误"></a>用户错误</h3><p>用户总是会以你想不到的方式操作软件。错误的输入、荒谬的操作，都有可能与我们预期不一致。一个好的程序有责任指出错误所在，并帮助用户来改正它。</p><h3 id="程序员错误"><a href="#程序员错误" class="headerlink" title="程序员错误"></a>程序员错误</h3><p>任何人都不可能永远编写 <code>bug free</code> 的代码，空指针、非法参数，这些是程序员编写代码不当造成的错误，我们应该尽量避免。</p><h3 id="意外情况"><a href="#意外情况" class="headerlink" title="意外情况"></a>意外情况</h3><p>现实总有太多的不确定性，网络连接失败，打印机墨水耗尽，磁盘空间耗尽，对于这些错误我们是无能为力的。</p><h2 id="错误的报告机制"><a href="#错误的报告机制" class="headerlink" title="错误的报告机制"></a>错误的报告机制</h2><p>我们需要一套完善的机制应对各种错误情况，提高代码的稳定性。至少我们应该做到以下几点：</p><ol><li>当问题出现时能够提出错误</li><li>检测到所有的错误</li><li>恰当的处理错误</li><li>如果不能处理错误，传播它。</li></ol><p>错误报告机制一般有如下几种：</p><h3 id="不报告"><a href="#不报告" class="headerlink" title="不报告"></a>不报告</h3><p>这或许是最简单的处理错误的方式。不过如果你想让你的程序随意崩溃，以一种不可预知的方式运行，那你大可忽略错误。忽略、逃避错误，以一种侥幸心理对待错误，是大忌！！另一种处理忽略错误的做法是，遇到错误立即中止程序，这种方法虽然比完全忽略好一点，不过这并不是一个好的工程解决方案。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>用一个返回值表示操作成功与否，这或许是一个简单可行的机制。根据返回值的类型和位置不同，一般又有以下几种方法：</p><ol><li>返回一个复合数据类型如元组，比如 Nodejs Go 语言就是采用这种方法。</li><li>通过函数参数返回错误代码，在 C++或者 .NET中可以通过引用参数传递， C 语言中，可以通过指针控制，不过这种方法既不美观也不直观。windows API 更进一步采用 HRESULT 统一返回错误代码，输出参数也通过函数参数传递，不过这使得函数参数语义变得复杂。</li><li>预留一些返回值表示错误。比如 length 返回 -1 代表错误或者未找到，因为长度不可能是负数；指针返回 NULL 表示操作失败。这种方法有时会有问题，比如返回值全部都有业务意义时，我们就无法区分错误情况了。</li></ol><h3 id="错误状态变量"><a href="#错误状态变量" class="headerlink" title="错误状态变量"></a>错误状态变量</h3><p>由上面知道函数返回值并不总是能分出一部分表示错误情况，将错误状态设置成全局变量似乎是可行之道。 C 语言标准通过 errno 来应用这种技术，不过这要求我们使用函数前，必须手动清除 errno。这种隐性的要求是出现 bug 的常见原因。功能上看，这种方法和返回值是等价的，但是它的缺陷之多足以让人放弃它。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常作为管理错误的语言工具，Java Python C# Javascript 都支持异常。当代码遇到无法处理的问题是，程序运行便会停止，并抛出异常（一个错误对象—）。运行时环境会自动在调用栈中向后退，直到找到可以处理异常的代码。根据异常处理之后的运行情况，有以下两种模式：</p><ol><li>终止模式。程序在捕获异常的处理程序执行完后继续执行。 Java C# 都属于这一类。</li><li>恢复模式。顾名思义，程序会从异常出现的地方恢复执行。</li></ol><p>异常一般不能忽略，如果没有捕获或者处理，异常会传播到调用栈的最高层，往往会导致程序崩溃。异常在面向对象中一般都有一套类层次定义，实现了多态。<br>异常并非完美，首先异常会造成性能上的损失，其次异常的特点决定了它不适合异步、并行编程。另一个重要话题涉及到 <code>异常安全(excaption safe)</code> ，有恢复能力的代码必须是异常安全的。不论出现什么异常，它都能 <code>正确</code> 执行。 异常安全有以下几个层次。这些层次都是对调用代码而言的。</p><ol><li>基本保证。如果出现异常必须保证不会泄露资源。但是代码的状态可能并不能保证，比如函数向容器添加 10 个元素，有可能全部添加，有可能添加了部分。</li><li>强力保证。这种保证比基本保证严格得多。即使通过你的代码传播了一个异常，程序的状态保存不变。任何对象和全局变量都不变。以上面例子而言，一个对象也不会插入。</li><li>不抛出保证。操作永远不能抛出异常，这意味着我们不能调用任何可能抛出异常的操作。</li></ol><p>异常安全对应保证程序的状态一致性十分重要，这也是有人反对异常的地方，见<a href="http://www.lighterra.com/papers/exceptionsharmful/" title="Exception HandlingConsidered Harmful">这儿</a>。<br>异常按照同步、异步以及异常的发现者，分为以下几类：</p><ol><li>Detected by the environment and raised synchronously;e.g. array bounds error or divide by zero</li><li>Detected by the application and raised synchronously, e.g.the failure of a program-defined assertion check</li><li>Detected by the environment and raised asynchronously;e.g. an exception raised due to the failure of some health monitoring mechanism</li><li>Detected by the application and raised asynchronously;e.g. one process may recognise that an error condition has occurred which will result in another process not meeting its deadline or not terminating correctly</li></ol><p>通常对异常处理有以下几个要求：</p><ol><li>– R1: The facility must be simple to understand and use</li><li>– R2: The code for exception handling should not obscure understanding of the program’s normal error-free operation</li><li>– R3: The mechanism should be designed so that run-time overheads are incurred only when handling an exception</li><li>– R4: The mechanism should allow the uniform treatment of exceptions detected both by the environment and by the program</li><li>– R5: the exception mechanism should allow recovery actions to be programmed</li></ol><p>详细请参考<a href="https://www.cs.york.ac.uk/rts/books/RTSbookThirdEdition/chap6.pdf" title="Exceptions and Exception Handling">这儿</a></p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号是硬件中断的软件等价物。通过信号处理程序处理错误事件，程序从被中断的位置继续执行。操作系统为每个信号提供了合理的错误处理程序，我们可以覆盖这些默认的处理程序。</p><h2 id="检测错误"><a href="#检测错误" class="headerlink" title="检测错误"></a>检测错误</h2><h3 id="返回值和错误状态变量"><a href="#返回值和错误状态变量" class="headerlink" title="返回值和错误状态变量"></a>返回值和错误状态变量</h3><p>这两种错误表现形式决定了，我们需要判断函数的返回值或者全局变量，以确定是否发生故障。<br>不过调用层次较多时，会让我的代码结构可读性降低，变得混乱不堪。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">void nastyErrorHandling(){  if(op1()){    //do something    if(op2()){      //do something      if(op3()){        //do more..      }    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上问题可以解决吗？可以的，通过引入一个状态变量 <code>ok</code> 比如：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">void flattenedErrorHandling(){  bool ok=op1();  if(ok){    //do something    ok=op2();  }  if(ok){    //do something    ok=op3();  }  //....  if(!ok){    //clean up after errors  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过这种方法对代码由一定限制，那就是中间不能 <code>return</code> 否则会跳过资源清理。<br>为了解决提前退出和资源清理，又有了饱受争议的 <code>goto</code> 语句。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">void gotHell(){  if(op1()) goto error;  //do something  if(op2()) goto error;  //do something  if(op3()) goto error;  //do more  return;  error:    //clean up}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++ 中倒是可以用类似智能指针的 RAII(Resource Acquisition Is Iniitiallization)的技术避免上述问题。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class LockGuard{public:    LockGuard(std::mutex &amp;m):_m(m){      m.lock();    }    ~LockGuard(){      m.unlock();    }private:    std::mutex&amp;_m;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Go 中可以用 <code>defer</code> 关键字实现类似效果。</p><h3 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h3><p>异常发生时，你可以选择捕获和处理异常，如果无处处理该异常则让它继续传播到更高层。Java是唯一一个强制实施异常规范作为函数签名一部分的主流语言。 C++ 中异常规范是运行时实施的。</p><h3 id="信号-1"><a href="#信号-1" class="headerlink" title="信号"></a>信号</h3><p>检查信号的方式只有一种：为其安装一个处理程序。</p><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>错误总会发生。那么我们应该采取什么措施呢？这个问题没有统一的答案。很大程度上取决于环境和错误的严重程度。为了做成决策，我们需要知道错误的关键信息：</p><ol><li>错误来源。错误的来源是一个核心组件或是第三方库，这需要我们必须弄清楚。</li><li>错误上下文。错误发生的上下文是什么？清晰的错误上下文能够帮助我们快速修复错误。</li><li>程序状态。错误发生的操作当前的状态是什么？全部完成、完成了一半或者一点没完成？</li><li>错误发生的时间。错误发生的时间点，是刚刚发生还是两小时前？</li><li>错误的严重性。错误的严重性决定了损失的大小。</li><li>如何修正错误。这个问题的答案有时很明显，有时也许不那么明显，通常情况我们需要其他信息辅助判断。</li></ol><h3 id="处理错误的时机"><a href="#处理错误的时机" class="headerlink" title="处理错误的时机"></a>处理错误的时机</h3><p>对于应该在何时处理错误，存在两个不同的学派：</p><h4 id="尽可能早的处理"><a href="#尽可能早的处理" class="headerlink" title="尽可能早的处理"></a>尽可能早的处理</h4><p>一发现错误就对其处理，这可以让控制流经过较少的无效状态代码。对返回错误代码的函数来说通常是最佳的选择。</p><h4 id="尽可能迟的处理"><a href="#尽可能迟的处理" class="headerlink" title="尽可能迟的处理"></a>尽可能迟的处理</h4><p>支持该观点的人认为，检测到错误的代码往往是不知道如何处理错误的。异常很适合该放手，我们可以让异常传播到能够处理它的地方。这让错误的检测和处理清晰的分开。理论上将错误的处理与业务逻辑分开很好，但是二者往往交织在一起，强行分开会使编码复杂。折中的方案是，让错误处理与错误发生的地方保持合适的距离，使得错误有清晰的上下文，同时又不会破坏正常代码的结构。</p><h3 id="处理错误的内容"><a href="#处理错误的内容" class="headerlink" title="处理错误的内容"></a>处理错误的内容</h3><p>错误发生了，我们也捕获了错误，那我们具体应该做些什么呢？</p><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>任何工程项目都应该使用日志工具。日志可以搜集重要的跟踪信息，不仅能够帮助我们分析错误，在分析用户行为、系统性能等方面都十分重要。日志内容应包含前面提到的所有关键信息，保证错误上下文足够完整。但是也应该注意，不要记录重复的错误信息和其他无关信息，这会给发现错误带来干扰和障碍。</p><h4 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h4><p>如有必要，我们应该讲错误报告给用户，比如文件被占用，可以报告用户让其关闭占用文件。但是要注意报告的频率和用语，用户不希望遭受无休止的错误报告轰炸，同时也不应该将敏感信息和专业错误的信息呈现给用户。</p><h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>不是所有的错误都意味着世界末日，有些错误我们应该尝试恢复，例如网络信号不稳定，我们可以尝试间歇性重连。无法处理错误时，可以抛出错误，或许上层代码知道如何处理。</p><h4 id="忽略"><a href="#忽略" class="headerlink" title="忽略"></a>忽略</h4><p>忽略错误并不能节省时间。我们会花费比编写错误处理程序多得多的时间来查找出现错误的原因。所以，忘记这种处理方式吧！</p><h4 id="传播"><a href="#传播" class="headerlink" title="传播"></a>传播</h4><p>无法处理错误时，唯一的选择是清理并传播错误。一般有两种传播方式：</p><ol><li>输出搜集到的所有错误信息（返回相同的原因代码或传播异常）</li><li>重新解释错误信息，返回不同的错误代码</li></ol><p>我们尽量应该使得错误代码与发生错误的操作概念上相关或一致。另一方面，我们在包装错误信息时尽量保留整个错误链。</p><h2 id="设计错误处理方案注意点"><a href="#设计错误处理方案注意点" class="headerlink" title="设计错误处理方案注意点"></a>设计错误处理方案注意点</h2><p>大多数时候错误处理都只停留在单个开发者层面，没有形成统一的错误处理方案。错误处理应该基于系统而不应该基于开发者。统一的错误处理不仅能减少响应时间，也有利于持续集成和交付（<code>CI/CD</code>）。设计错误处理方案应该考虑如下几点：</p><ol><li>Establish naming conventions and standard error messages across the team. Align error names with business logic and naming conventions from other systems. Naming should not be unique to any one developer;</li><li>Always include version information and details about releases or commits in your errors;</li><li>Identify the feature and/or unit test associated with the error;</li><li>Create a standard for exception handling and clearly communicate this to the entire team;</li><li>Leverage error monitoring tools to quickly spot and respond to errors.</li></ol><p>编写错误消息应该注意一下几点：</p><ol><li>用户不会像程序员那样思考，例如磁盘空间只剩 <code>10k</code> ，在用户看来可能是 1<code>OK</code> 。</li><li>报告信息不要太专业。满屏的异常调用栈会吓到用户的！</li><li>不要呈现毫无意义的错误代码。试想当用户面对一个错误消息： <code>Error code 007</code> 时该怎么办?错误代码应该作为错误消息的一部分，而不是全部。</li><li>将错误与警告醒目的区分开。</li></ol><h2 id="管理错误"><a href="#管理错误" class="headerlink" title="管理错误"></a>管理错误</h2><p>我们不能把希望都寄托在错误处理上，有很多错误我们应该尽力避免：</p><ol><li>检查所有的函数参数。</li><li>检查执行过程中关键点的不变条件是否满足。</li><li>检查外部值的有效性，防止恶意用户的输入，如 <code>SQL注入</code>。</li><li>检查系统调用和下级函数的返回状态。</li></ol><p>在管理程序错误的出现、检查和处理时，要考虑以下因素：</p><ol><li>与其处理错误，不如提前避免它。</li><li>定义程序在不正常环境的预期行为。</li><li>清晰定义错误处理层次，不同组件负责哪个错误。</li><li>不同情况选择合适的错误表达方式。有人认为对于不期望发生的事，可以采用异常，觉得可能发生的事可以使用返回码。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://raygun.com/blog/errors-and-exceptions">https://raygun.com/blog/errors-and-exceptions</a></li><li><a href="https://raygun.com/blog/architecting-your-software-errors-for-better-error-reporting">https://raygun.com/blog/architecting-your-software-errors-for-better-error-reporting</a></li><li><a href="https://www.inf.unibz.it/~calvanese/teaching/ip/lecture-notes/uni10.pdf">https://www.inf.unibz.it/~calvanese/teaching/ip/lecture-notes/uni10.pdf</a></li><li><a href="https://pdfs.semanticscholar.org/a834/36e314643ddb40bc7f84554e33488df4b51e.pdf">https://pdfs.semanticscholar.org/a834/36e314643ddb40bc7f84554e33488df4b51e.pdf</a></li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 错误 </category>
          
          <category> 异常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> 错误 </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全面介绍递归-递归编程基本概念</title>
      <link href="/2018/05/17/quan-mian-jie-shao-di-gui-di-gui-bian-cheng-ji-ben-gai-nian/"/>
      <url>/2018/05/17/quan-mian-jie-shao-di-gui-di-gui-bian-cheng-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从前有座山,山上有座庙,庙里有个老和尚和一个小和尚,有一天,老和尚对小和尚说:从前有座山,山上有座庙,庙里有个老和尚和一个小和尚,有一天,老和尚对小和尚说:从前有座山,山上有座庙,庙里有个老和尚和一个小和尚,有一天,老和尚对小和尚说…….</p></blockquote><p>或许这是我们最早接触的递归。</p><a id="more"></a><h2 id="递归的两个重要方面"><a href="#递归的两个重要方面" class="headerlink" title="递归的两个重要方面"></a>递归的两个重要方面</h2><p>我们在对问题进行递归求解时，我们必须了解递归的两个方面即问题分解和归约。</p><h3 id="问题分解"><a href="#问题分解" class="headerlink" title="问题分解"></a>问题分解</h3><p><code>分解</code> 不仅仅在递归中，在整个计算机科学甚至生活中都十分重要。当我们面对一个复杂问题时，可以将问题分解成一个个小问题，然后逐个击破，最后整合结果便可求解复杂问题。例如要求一个数组的和。即</p><p><img src="nsum.png" alt="nsum"></p><p>$$ S(a)=a[0]+a[1]+…+a[n-1] $$</p><p>我们可以将原问题分解为求前 n-1 个正整数的和，再加上 n-1 即</p><p><img src="nsum1.png" alt="nsum1"></p><p>通过分解原问题变得简单了，除了上面这种分解方法，我们还可以想到以下分解方法</p><p><img src="nsum2.png" alt="nsum2"><br><img src="nsum3.png" alt="nsum3"></p><p>通过观察发现这些分解方式都有一个共同点，子问题和原问题都属于同一类型，只是问题规模变小，也就变得更简单。通过不断的分解，最终会得到 <code>基本情况</code> ，即当 n 取 1 的时候我们很容易就知道结果为 $ a[0] $  。</p><h2 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h2><p>归纳是另一个递归汇总至关重要的因素，归纳是数学证明的一个概念。递归编程关键点是我们必须假设子问题能够成功，这对于初学者可能有些难以置信，毕竟我们还没有完成递归代码，却要假设它能够正确处理，这涉及到 <code>recursive "leap of faith"</code> 即递归成功的信心。初学者往往会纠结于模拟递归执行的过程，最终发现“越陷越深”，被递归绕晕了。所以不必纠结于递归子问题如何运行，我们只需要假设它正确即可，但是我们怎么确定结果是正确的呢？这就要用到数学归纳法了。<br>数学归纳法分两步：</p><ol><li>基本情况。验证公式对于初始条件成立。</li><li>归纳。假设公式对于 <code>n</code> 成立，这一步叫做归纳假设，然后基于归纳假设证明取 <code>n+1</code> 时公式仍然正确。<br>假设我们要证明前 n 项和。</li></ol><p>$$S(n)=\sum_{i=1}^ni=\frac{n(n+1)}{2}$$</p><p>第一步，验证基本情况。当 <code>i=1</code> 时公式成立 $S(n)=1$<br>假设 <code>i=n</code> 时公式成立，即 $S(n)=\sum_{i=1}^ni=\frac{n(n+1)}{2}$ 要证明 $S(n+1)=\sum_{i=1}^{n+1}i=\frac{(n+1)(n+2)}{2}$ 由于 $S(n+1)=S(n)+(n+1)$ 带入归纳假设 $S(n)$ 化简即证原式。</p><h2 id="命令是和申明式编程"><a href="#命令是和申明式编程" class="headerlink" title="命令是和申明式编程"></a>命令是和申明式编程</h2><p>编程范式有多种，其中包括命令式的，如 Java C++ C C# 等我们常用的语言，这类语言编写的程序主要是一条条命令，用控制流程和指令修改数据状态编程。而申明式编程主要通过描述程序应该做什么，没有显示的流程控制，函数式编程和 <code>SQL</code> 就是典型的申明式编程，函数式编程没有 <code>副作用</code> ，通过计算数学函数得到结果，由于不会修改程序状态，天然适合并发编程。</p><p>命令式编程对应 <code>how program work</code> ，申明式编程对应 <code>what program perform</code> 。递归编程是申明式的，所以我们应该关注 <code>函数完成了什么（what function accomplish）</code> 而不是 <code>函数怎么完成的（how function accomplish）</code> 。</p><h2 id="迭代和递归"><a href="#迭代和递归" class="headerlink" title="迭代和递归"></a>迭代和递归</h2><p>迭代和递归解决问题的能力是等价的，每一个递归的解法也可以转换诶迭代的解法，反之亦然。很多问题递归更加容易设计和完成，递归更加直观、优雅和容易理解。递归一般用栈实现，我们可以用栈模拟递归。虽然递归简单和容易理解，但是递归往往效率低下、更耗内存，并且有可能造成栈溢出。递归和迭代不是对立的，二者可以共存，比如回溯往往需要结合递归和迭代。</p><h2 id="递归的分类"><a href="#递归的分类" class="headerlink" title="递归的分类"></a>递归的分类</h2><p>根据递归的类型可以将递归分为以下几类：</p><h3 id="线性递归"><a href="#线性递归" class="headerlink" title="线性递归"></a>线性递归</h3><p>线性递归是指递归函数只会调用自身一次，比如上面的前 <code>n</code> 项和。</p><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>尾递归属于线性递归，只是递归调用出现在函数的最后，编译器一般能够将尾递归优化为迭代。</p><h3 id="多递归"><a href="#多递归" class="headerlink" title="多递归"></a>多递归</h3><p>和线性递归相对的是函数会递归调用多次自身，这种策略也称作<code>分治法</code>。</p><h3 id="互递归"><a href="#互递归" class="headerlink" title="互递归"></a>互递归</h3><p>存在循环调用的便是互递归，比如 <code>A</code> 调用 <code>B</code> ，<code>B</code> 调用 <code>C</code> ，<code>C</code> 又调用 <code>A</code> ，那么这三者之间就是互递归。</p><h3 id="嵌套递归"><a href="#嵌套递归" class="headerlink" title="嵌套递归"></a>嵌套递归</h3><p>嵌套递归是指递归调用的参数是递归调用，嵌套递归比较少见，形式如下：</p><p>$$<br>f(n,s)=<br>\begin{cases}<br>1+s &amp;\text{if $n=1 $ or $n=2$} \\<br>f(n-1,s+f(n-2,0))  &amp; \text{if $ n&gt;2$} \\<br>\end{cases}<br>$$</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全面介绍递归-序言</title>
      <link href="/2018/05/17/quan-mian-jie-shao-di-gui/"/>
      <url>/2018/05/17/quan-mian-jie-shao-di-gui/</url>
      
        <content type="html"><![CDATA[<blockquote><p>To iterate is human,to recurse divine.</p></blockquote><a id="more"></a><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归作为一个广泛的概念存在于各个学科，如数学、生物学、语言学、计算机，甚至艺术。在计算机中作为一种问题求解策略，可以说无处不在。如果你网上搜索递归相关资料，会发现都是零散的资料，单独介绍递归的书籍很少，递归一般都是作为算法书籍的一章被介绍，而 <code>Introduction to Recursive Programming</code> 这本书比较全面的介绍了递归相关话题，后面将结合该书以及其他资料，对递归作一次比较全面的介绍。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己动手构建简易虚拟机和编译器-构建XASM汇编器（4）</title>
      <link href="/2018/05/13/zi-ji-dong-shou-gou-jian-jian-yi-xu-ni-ji-he-bian-yi-qi-gou-jian-xasm-hui-bian-qi/"/>
      <url>/2018/05/13/zi-ji-dong-shou-gou-jian-jian-yi-xu-ni-ji-he-bian-yi-qi-gou-jian-xasm-hui-bian-qi/</url>
      
        <content type="html"><![CDATA[<p>本章我们将构建XASM汇编器，将汇编代码汇编成虚拟机可以执行的二进制文件。</p><a id="more"></a><h2 id="本章所处位置"><a href="#本章所处位置" class="headerlink" title="本章所处位置"></a>本章所处位置</h2><p><img src="xasm.png" alt="xasm"></p><h2 id="汇编内容"><a href="#汇编内容" class="headerlink" title="汇编内容"></a>汇编内容</h2><p>根据前一章的内容可知，汇编器的主要工作是将汇编代码转换成虚拟机能解析执行的机器码。主要包含以下几个方面的内容。</p><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><p>汇编指令采用的是助记符形式，如 <code>Mov X,4</code> 等，最终会被翻译为如 <code>3 2 4</code> 这样的机器码。<br>要翻译自然需要一个指令查找表，当 C 语言被翻译成机器码时，参考的是 CPU 制造商提供的汇编参考手册，而这里的汇编代码会运行在我们自己的虚拟机上，那么参考手册需要我们来提供。在实现层面上，可以用语言提供的数据结构如链表、哈希表来存储所有的指令映射关系，如下图所示。</p><p><img src="opcodelookuptable.png" alt="opcodelookuptable"></p><p>上述映射表格中，每一条记录除了存储助记符对应的操作码之外，还需要存储该指令的操作数列表，其中操作数列表中包含了各个操作数的操作符类型和数据，由于一个操作符的类型可能有几种，如 <code>Mov X,Y</code> 中， <code>Y</code> 可以是整形、浮点数、字符串或者变量，所以我们可以用 Bit Vector 来存储多种类型的情况，如下图所示：</p><p><img src="bitvector.png" alt="bitvector"></p><h3 id="汇编变量"><a href="#汇编变量" class="headerlink" title="汇编变量"></a>汇编变量</h3><p>由于我们的虚拟机是基于栈实现的，所以变量、数组会被汇编为基于当前栈的索引。需要注意的地方是，全局变量能够在任意地方访问，而局部变量是基于当前作用域访问，故全局变量采用从下往上的正索引值，局部变量采用基于当前栈顶向下的索引值，全局变量采用绝对定位，局部变量采用相对定位。</p><p><img src="stackindex.png" alt="stackindex"></p><p>变量计算方法为：如果一个函数有 4 个变量， 2 个参数，那么该函数的栈帧的大小为 7(4+2+1) ，其中多加的 1 为函数返回值，四个变量的索引分别为 -1~-4 ，函数返回地址为 -5 ，两个参数索引为 -6 和 -7 。</p><p><img src="stackframe.png" alt="stackframe"><br><img src="variables.png" alt="variables"></p><p>注意上图中栈帧是以 -2 开始而不是 -1 ，主要是为记录其他数据预留了一个位置，后续章节会介绍。</p><h3 id="汇编操作数"><a href="#汇编操作数" class="headerlink" title="汇编操作数"></a>汇编操作数</h3><p>由上一章知道，我们的指令包含多种类型的操作数，如下图所示：</p><p><img src="operandtypes.png" alt="operandtypes"></p><p>其实每条指令的操作数有两个不同点，其一是指令包含的操作数类型，其二是指令包含的操作数个数。所以只要我们记录了这两个数据，便能识别一条指令，指令被汇编后的格式如下：</p><p><img src="instructionformat.png" alt="instructionformat"></p><h3 id="汇编字符串"><a href="#汇编字符串" class="headerlink" title="汇编字符串"></a>汇编字符串</h3><p>初一想，字符串也可以像整型、浮点数一样，直接汇编到指令流里面啊，但是这样做的结果不仅使得我们最后的指令流格式丑陋，同时也不便于优化性能。很自然的我们可以想到用索引（指针）的方式，在最后的指令流将字符串字面量替换为指向字符串表的索引，如下图所示：</p><p><img src="stringliteral.png" alt="stringliteral"></p><h3 id="汇编跳转和函数调用"><a href="#汇编跳转和函数调用" class="headerlink" title="汇编跳转和函数调用"></a>汇编跳转和函数调用</h3><p>函数调用和跳转指令在汇编后都会被替换为对应指令的索引，如下图所示：</p><p><img src="labelasm.png" alt="labelasm"></p><p>观察上图会发现一个问题，在处理第 5 条语句时 Label1 在下一行，而下一行还没解析，这涉及到 <code>forward reference</code> （向前引用）</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>如果汇编代码量很大或者为了性能考虑，可以将代码分块载入内存汇编，不过这会增加复杂性。为了实现简单我们采用全部载入内存的方式。</p><h2 id="XVM输入部分（-XVM-汇编脚本指令）"><a href="#XVM输入部分（-XVM-汇编脚本指令）" class="headerlink" title="XVM输入部分（ XVM 汇编脚本指令）"></a>XVM输入部分（ XVM 汇编脚本指令）</h2><p>XVM 汇编脚本代码由以下部分组成。</p><h3 id="SetStackSize"><a href="#SetStackSize" class="headerlink" title="SetStackSize"></a>SetStackSize</h3><p>SetStackSize能够指定脚本代码栈大小：</p><pre class="line-numbers language-none"><code class="language-none">SetStackSize 1024<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果大小为 0 或者未写该指令，按照 XVM 默认大小 1024 分配。</p><h3 id="Func"><a href="#Func" class="headerlink" title="Func"></a>Func</h3><pre class="line-numbers language-none"><code class="language-none">Func _Main(){  ;代码入口}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>XVM 脚本代码会在源文件中查找 _Main 函数，如果找到则以此为入口，否则需要其他函数调用代码才会执行。此外，函数不支持嵌套定义，汇编器会默认加上 Ret 语句，在函数完成时返回。</p><h3 id="Var-Var"><a href="#Var-Var" class="headerlink" title="Var/Var []"></a>Var/Var []</h3><p>XVM 汇编脚本支持单个变量和一维数组：</p><pre class="line-numbers language-none"><code class="language-none">Var XVar X[16]Var Y[X]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Param"><a href="#Param" class="headerlink" title="Param"></a>Param</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">Func MyFunc{  ; Declare parameters  Param U  Param V  Param W  ; Declare local variables  Var X  Var Y  Var MyArray [ 16 ]  ; Begin function code  Mov MyArray [ 0 ], U  Mov MyArray [ 1 ], V  Mov MyArray [ 2 ], W}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意参数压入顺序和声明顺序，如下：</p><p><img src="paramseq.png" alt="paramseq"></p><p>第二种方法保证了栈的索引与声明顺序一致。</p><h3 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h3><p>指令格式如下：</p><pre class="line-numbers language-none"><code class="language-none">Mnemonic Operand,Operand，Operand<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 Operand 包含 Integer ,floating-point literals,String literals,variables,Array Indices,Line Label,Functions 和 Host API Calls</p><h3 id="Line-Labels"><a href="#Line-Labels" class="headerlink" title="Line Labels"></a>Line Labels</h3><p>标号格式如下：</p><pre class="line-numbers language-none"><code class="language-none">Label:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Host-API-Function-Calls"><a href="#Host-API-Function-Calls" class="headerlink" title="Host API Function Calls"></a>Host API Function Calls</h3><p>Host API 会像字符串一样处理，因为 Host API 要一直保留到运行时。</p><h3 id="RetVal-寄存器"><a href="#RetVal-寄存器" class="headerlink" title="_RetVal 寄存器"></a>_RetVal 寄存器</h3><p>_RetVal 是一个全局变量，会传递函数的返回值。</p><h3 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h3><p>XVM 脚本支持以下两种注释：</p><pre class="line-numbers language-none"><code class="language-none">;这是注释Mov X,Y ;这也是注释<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class="line-numbers language-none"><code class="language-none">; Example script; Demonstrates the basic layout of an XVM; assembly-language script.; ---- Globals ------------------------------------------------Var GlobalVarVar GlobalArray [ 256 ]; ---- Functions ----------------------------------------------; A simple addition functionFunc MyAdd{  ; Import our parameters  Param Y  Param X  ; Declare local data  Var Sum  Mov Sum, X  Add Sum, Y  ; Put the result in the _RetVal register  Mov _RetVal, Sum  ; Remember, Ret will be automatically added}; Just a bizarre function that does nothing in particularFunc MyFunc{  ; This function doesn't accept parameters  ; But it does have local data  Var MySum  ; We're going to test the Add function, so we'll  ; start by pushing two integer parameters.  Push 16  Push 32  ; Next we make the function call itself  Call MyAdd  ; And finally, we grab the return value from _RetVal  Mov MySum, _RetVal  ; Multiply MySum by 2 and store it in GlobalVar  Mul MySum, 2  Mov GlobalVar, MySum  ; Set some array values  Mov GlobalArray [ 0 ], "This"  Mov GlobalArray [ 1 ], "is"  Mov GlobalArray [ 2 ], "an"  Mov GlobalArray [ 3 ], "array."}; The special _Main () function, which will be automatically executedFunc _Main{  ; Call the MyFunc test function  Call MyFunc}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="XVM输出部分"><a href="#XVM输出部分" class="headerlink" title="XVM输出部分"></a>XVM输出部分</h2><h3 id="XSE-XtremeScript-Script-Executable"><a href="#XSE-XtremeScript-Script-Executable" class="headerlink" title="XSE(XtremeScript Script Executable)"></a>XSE(XtremeScript Script Executable)</h3><p>XASM 会将汇编脚本代码汇编为 .xse 结尾的可执行文件，内容如下：</p><p><img src="xse.png" alt="xse"></p><p>其中各个部分都采用 <code>继承</code> 结构。</p><h3 id="Main-Header"><a href="#Main-Header" class="headerlink" title="Main Header"></a>Main Header</h3><p><img src="mainheader.png" alt="mainheader"><br><img src="mainheader1.png" alt="mainheader1"></p><h3 id="Instruction-Stream"><a href="#Instruction-Stream" class="headerlink" title="Instruction Stream"></a>Instruction Stream</h3><p>指令流结构如下：</p><p><img src="instructionstream.png" alt="instructionstream"><br><img src="instructiontable.png" alt="instructiontable"></p><h3 id="Operand-Types"><a href="#Operand-Types" class="headerlink" title="Operand Types"></a>Operand Types</h3><p>操作数类别代码如下：</p><p><img src="operandtypecode.png" alt="operandtypecode"></p><h3 id="String-Table"><a href="#String-Table" class="headerlink" title="String Table"></a>String Table</h3><p><img src="stringtable.png" alt="stringtable"></p><h3 id="Function-Table"><a href="#Function-Table" class="headerlink" title="Function Table"></a>Function Table</h3><p><img src="functiontable.png" alt="functiontable"></p><h3 id="Host-API-Call-Table"><a href="#Host-API-Call-Table" class="headerlink" title="Host API Call Table"></a>Host API Call Table</h3><p><img src="hostapi.png" alt="hostapi"></p><h2 id="Assembler-实现"><a href="#Assembler-实现" class="headerlink" title="Assembler 实现"></a>Assembler 实现</h2><h3 id="词法分析和语法分析"><a href="#词法分析和语法分析" class="headerlink" title="词法分析和语法分析"></a>词法分析和语法分析</h3><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>词法分析的目的是将源代码的字符流转换为词素（<code>Token</code>），如下所示：</p><p><img src="lexer.png" alt="lexer"></p><pre class="line-numbers language-none"><code class="language-none">MOV SUM , X<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将被转换为如下 <code>Token</code></p><pre class="line-numbers language-none"><code class="language-none">TOKEN_TYPE_INSTRTOKEN_TYPE_IDENTTOKEN_TYPE_COMMATOKEN_TYPE_IDENT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>词法分析是将字符流转换为一个个 <code>Token</code> ，而语法分析器则更进一步，将 <code>Token</code> 组合识别出有意义的程序结构，如下图所示：</p><p><img src="parsing.png" alt="parsing"></p><h2 id="Assembler-Framework"><a href="#Assembler-Framework" class="headerlink" title="Assembler Framework"></a>Assembler Framework</h2><p>在词法和语法分析的过程中，会产生许多中间信息，比如变量、函数、标签等。我们需要用数据结构将其保存，以供生成机器码时使用。如果使用高级语言，则可以使用高级语言提供的数据结构存储，如 C++ 的 STL ， Java 的集合等。 C 语言则可以使用简单的链表存储各种中间数据。</p><h3 id="源代码表示"><a href="#源代码表示" class="headerlink" title="源代码表示"></a>源代码表示</h3><p>源代码可以用一个二维指针表示，如下图所示：</p><p><img src="sourcecode.png" alt="sourcecode"></p><h3 id="指令流"><a href="#指令流" class="headerlink" title="指令流"></a>指令流</h3><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _Instr          // An instruction{  int iOpcode;               // Opcode  int iOpCount;              // Number of operands  Op * pOpList;              // Pointer to operand list}Instr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _Op             // An assembled operand{int iType;                 // Typeunion                      // The value{  int iIntLiteral;       // Integer literal  float fFloatLiteral;   // Float literal  int iStringTableIndex; // String table index  int iStackIndex;       // Stack index  int iInstrIndex;       // Instruction index  int iFuncIndex;        // Function index  int iHostAPICallIndex; // Host API Call index  int iReg;              // Register code};int iOffsetIndex;          // Index of the offset}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意根据 iType 不同，操作数代表的值意义也不一样，故可以用 <code>联合体</code> 表示，其中 <code>iOffsetIndex</code> 是当 <code>union</code> 取 <code>iStackIndex</code> 时才有意义，其中 <code>iStackIndex</code> 代表基地址，iOffsetIndex 代表相对索引。</p><h4 id="脚本头"><a href="#脚本头" class="headerlink" title="脚本头"></a>脚本头</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _ScriptHeader    // Script header data{  int iStackSize;             // Requested stack size  int iGlobalDataSize;        // The size of the script's global data  int iIsMainFuncPresent;     // Is _Main () present?  int iMainFuncIndex;         // _Main ()'s function index}ScriptHeader;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="链表的简单实现"><a href="#链表的简单实现" class="headerlink" title="链表的简单实现"></a>链表的简单实现</h4><p><img src="linkedlist.png" alt="linkedlist"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _LinkedListNode  // A linked list node{  void * pData;               // Pointer to the node's data  _LinkedListNode * pNext;    // Pointer to the next node in the list}LinkedListNode;typedef struct _LinkedList      // A linked list{  LinkedListNode * pHead,    // Pointer to head node  * pTail;    // Pointer to tail node  int iNodeCount;            // The number of nodes in the list}LinkedList;void InitLinkedList ( LinkedList * pList ){  // Set both the head and tail pointers to null  pList-&gt;pHead = NULL;  pList-&gt;pTail = NULL;  // Set the node count to zero, since the list is currently empty  pList-&gt;iNodeCount = 0;}int AddNode ( LinkedList * pList, void * pData ){  // Create a new node  LinkedListNode * pNewNode = ( LinkedListNode * )  malloc ( sizeof ( LinkedListNode ) );  // Set the node's data to the specified pointer  pNewNode-&gt;pData = pData;  // Set the next pointer to NULL, since nothing will lie beyond it  pNewNode-&gt;pNext = NULL;  // If the list is currently empty, set both the head and tail pointers  // to the new node  if ( ! pList-&gt;iNodeCount )  {    // Point the head and tail of the list at the node    pList-&gt;pHead = pNewNode;    pList-&gt;pTail = pNewNode;  }// Otherwise append it to the list and update the tail pointer  else  {// Alter the tail's next pointer to point to the new node    pList-&gt;pTail-&gt;pNext = pNewNode;    // Update the list's tail pointer    pList-&gt;pTail = pNewNode;  }  // Increment the node count  ++ pList-&gt;iNodeCount;  // Return the new size of the linked list - 1, which is the node's index  return pList-&gt;iNodeCount - 1;}void FreeLinkedList ( LinkedList * pList ){  // If the list is empty, exit  if ( ! pList )    return;    // If the list is not empty, free each node    if ( pList-&gt;iNodeCount )    {      // Create a pointer to hold each current node and the next node      LinkedListNode * pCurrNode,      * pNextNode;      // Set the current node to the head of the list      pCurrNode = pList-&gt;pHead;      // Traverse the list      while ( TRUE )      {        // Save the pointer to the next node before freeing the current one        pNextNode = pCurrNode-&gt;pNext;        // Clear the current node's data        if ( pCurrNode-&gt;pData )          free ( pCurrNode-&gt;pData );        // Clear the node itself        if ( pCurrNode )          free ( pCurrNode );        // Move to the next node if it exists; otherwise, exit the loop        if ( pNextNode )          pCurrNode = pNextNode;        else          break;      }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切记链表的释放！</p><h4 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h4><p>复用刚才的链表即可：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int AddString ( LinkedList * pList, char * pstrString ){  // ---- First check to see if the string is already in the list  // Create a node to traverse the list  LinkedListNode * pNode = pList-&gt;pHead;  // Loop through each node in the list  for ( int iCurrNode = 0; iCurrNode &lt; pList-&gt;iNodeCount; ++ iCurrNode )  {    // If the current node's string equals the specified string, return    // its index    if ( strcmp ( ( char * ) pNode-&gt;pData, pstrString ) == 0 )      return iCurrNode;      // Otherwise move along to the next node      pNode = pNode-&gt;pNext;    }  // ---- Add the new string, since it wasn't added  // Create space on the heap for the specified string  char * pstrStringNode = ( char * ) malloc ( strlen ( pstrString ) + 1 );  strcpy ( pstrStringNode, pstrString );  // Add the string to the list and return its index  return AddNode ( pList, pstrStringNode );}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="函数表"><a href="#函数表" class="headerlink" title="函数表"></a>函数表</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _FuncNode        // A function table node{  int iIndex;                 // Index  char pstrName [ MAX_IDENT_SIZE ];    // Name  int iEntryPoint;            // Entry point  int iParamCount;            // Param count  int iLocalDataSize;         // Local data size}FuncNode;int AddFunc ( char * pstrName, int iEntryPoint ){  // If a function already exists with the specified name, exit and return  // an invalid index  if ( GetFuncByName ( pstrName ) )    return -1;  // Create a new function node  FuncNode * pNewFunc = ( FuncNode * ) malloc ( sizeof ( FuncNode ) );  // Initialize the new function  strcpy ( pNewFunc-&gt;pstrName, pstrName );  pNewFunc-&gt;iEntryPoint = iEntryPoint;  // Add the function to the list and get its index  int iIndex = AddNode ( &amp; g_FuncTable, pNewFunc );  // Set the function node's index  pNewFunc-&gt;iIndex = iIndex;  // Return the new function's index  return iIndex;}void SetFuncInfo ( char * pstrName, int iParamCount, int iLocalDataSize ){  // Based on the function's name, find its node in the list  FuncNode * pFunc = GetFuncByName ( pstrName );  // Set the remaining fields  pFunc-&gt;iParamCount = iParamCount;  pFunc-&gt;iLocalDataSize = iLocalDataSize;}FuncNode * GetFuncByName ( char * pstrName ){  // If the table is empty, return a NULL pointer  if ( ! g_FuncTable.iNodeCount )    return NULL;  // Create a pointer to traverse the list  LinkedListNode * pCurrNode = g_FuncTable.pHead;  // Traverse the list until the matching structure is found  for ( int iCurrNode = 0; iCurrNode &lt; g_FuncTable.iNodeCount; ++ iCurrNode )  {    // Create a pointer to the current function structure    FuncNode * pCurrFunc = ( FuncNode * ) pCurrNode-&gt;pData;    // If the names match, return the current pointer    if ( strcmp ( pCurrFunc-&gt;pstrName, pstrName ) == 0 )      return pCurrFunc;    // Otherwise move to the next node    pCurrNode = pCurrNode-&gt;pNext;  }  // The structure was not found, so return a NULL pointer  return NULL;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _SymbolNode      // A symbol table node{  int iIndex;                 // Index  char pstrIdent [ MAX_IDENT_SIZE ];    // Identifier  int iSize;                  // Size (1 for variables, N for arrays)  int iStackIndex;            // The stack index to which the symbol points  int iFuncIndex;             // Function in which the symbol resides}SymbolNode;int AddSymbol ( char * pstrIdent, int iSize, int iStackIndex, int iFuncIndex ){  // If a label already exists  if ( GetSymbolByIdent ( pstrIdent, iFuncIndex ) )    return -1;  // Create a new symbol node  SymbolNode * pNewSymbol = ( SymbolNode * )  malloc ( sizeof ( SymbolNode ) );  // Initialize the new label  strcpy ( pNewSymbol-&gt;pstrIdent, pstrIdent );  pNewSymbol-&gt;iSize = iSize;  pNewSymbol-&gt;iStackIndex = iStackIndex;  pNewSymbol-&gt;iFuncIndex = iFuncIndex;  // Add the symbol to the list and get its index  int iIndex = AddNode ( &amp; g_SymbolTable, pNewSymbol );  // Set the symbol node's index  pNewSymbol-&gt;iIndex = iIndex;  // Return the new symbol's index  return iIndex;}SymbolNode * GetSymbolByIdent ( string Ident, int FuncIndex ){  // Traverse the linked list until a symbol with the proper  // identifier and scope is found.  // First latch onto the initial node  SymbolNode * CurrSymbol = SymbolTable.Head;  // Loop through each node in the list  for ( CurrIndex = 0; CurrIndex &lt; SymbolTable.SymbolCount; ++ CurrIndex )  {    // Check to see if the current node matches the specified identifier    if ( CurrNode.Ident == Ident )    // Now see if their scopes are the same or overlap (global/local)    if ( CurrNode.FuncIndex == FuncIndex || CurrNode.StackIndex &gt;= 0 )      return CurrNode;    // Otherwise move on to the next in the list    CurrNode = CurrNode.Next;  }  // The specified symbol was not found, so return NULL  return NULL;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意条件 <code>if ( CurrNode.FuncIndex == FuncIndex || CurrNode.StackIndex &gt;= 0 )</code> 是因为全局变量 StackIndex 从零开始。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int GetStackIndexByIdent ( char * pstrIdent, int iFuncIndex ){  // Get the symbol's information  SymbolNode * pSymbol = GetSymbolByIdent ( pstrIdent, iFuncIndex );  // Return its stack index  return pSymbol-&gt;iStackIndex;}int GetSizeByIdent ( char * pstrIdent, int iFuncIndex ){  // Get the symbol's information  SymbolNode * pSymbol = GetSymbolByIdent ( pstrIdent, iFuncIndex );  // Return its size  return pSymbol-&gt;iSize;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="标签表"><a href="#标签表" class="headerlink" title="标签表"></a>标签表</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _LabelNode       // A label table node{  int iIndex;                 // Index  char pstrIdent [ MAX_IDENT_SIZE ];    // Identifier  int iTargetIndex;           // Index of the target instruction  int iFuncIndex;             // Function in which the label resides}int AddLabel ( char * pstrIdent, int iTargetIndex, int iFuncIndex ){  // If a label already exists, return -1  if ( GetLabelByIdent ( pstrIdent, iFuncIndex ) )    return -1;  // Create a new label node  LabelNode * pNewLabel = ( LabelNode * ) malloc ( sizeof ( LabelNode ) );  // Initialize the new label  strcpy ( pNewLabel-&gt;pstrIdent, pstrIdent );  pNewLabel-&gt;iTargetIndex = iTargetIndex;  pNewLabel-&gt;iFuncIndex = iFuncIndex;  // Add the label to the list and get its index  int iIndex = AddNode ( &amp; g_LabelTable, pNewLabel );  // Set the index of the label node  pNewLabel-&gt;iIndex = iIndex;  // Return the new label's index  return iIndex;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Host-API-表"><a href="#Host-API-表" class="headerlink" title="Host API 表"></a>Host API 表</h4><p>复用链表即可。</p><p><code>LinkedList g_HostAPICallTable;</code></p><h4 id="指令集查找表"><a href="#指令集查找表" class="headerlink" title="指令集查找表"></a>指令集查找表</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _InstrLookup     // An instruction lookup{  char pstrMnemonic [ MAX_INSTR_MNEMONIC_SIZE ];  // Mnemonic string  int iOpcode;                // Opcode  int iOpCount;               // Number of operands  OpTypes * OpList;           // Pointer to operand list}typedef int OpTypes;#define MAX_INSTR_LOOKUP_COUNT      256      // The maximum number of                                            // instructions the lookup table                                            // will hold#define MAX_INSTR_MNEMONIC_SIZE     16       // Maximum size of an instruction// mnemonic's stringInstrLookup g_InstrTable [ MAX_INSTR_LOOKUP_COUNT ];InstrLookup;int AddInstrLookup ( char * pstrMnemonic, int iOpcode, int iOpCount ){  // Just use a simple static int to keep track of the next instruction  // index in the table.  static int iInstrIndex = 0;  // Make sure we haven't run out of instruction indices  if ( iInstrIndex &gt;= MAX_INSTR_LOOKUP_COUNT )    return -1;  // Set the mnemonic, opcode and operand count fields  strcpy ( g_InstrTable [ iInstrIndex ].pstrMnemonic, pstrMnemonic );  strupr ( g_InstrTable [ iInstrIndex ].pstrMnemonic );  g_InstrTable [ iInstrIndex ].iOpcode = iOpcode;  g_InstrTable [ iInstrIndex ].iOpCount = iOpCount;  // Allocate space for the operand list  g_InstrTable [ iInstrIndex ].OpList = ( OpTypes * )  malloc ( iOpCount * sizeof ( OpTypes ) );  // Copy the instruction index into another variable so it can be returned  // to the caller  int iReturnInstrIndex = iInstrIndex;  // Increment the index for the next instruction  ++ iInstrIndex;  // Return the used index to the caller  return iReturnInstrIndex;}void SetOpType ( int iInstrIndex, int iOpIndex, OpTypes iOpType ){  g_InstrTable [ iInstrIndex ].OpList [ iOpIndex ] = iOpType;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Operand Type Bitfield Masks 如下：</p><p><img src="bitfieldmask.png" alt="bitfieldmask"></p><p>设置如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">iInstrIndex = AddInstrLookup ( "Mov", 0, 2 );SetOpType ( iInstrIndex, 0, OP_FLAG_TYPE_MEM_REF |OP_FLAG_TYPE_REG );SetOpType ( iInstrIndex, 1, OP_FLAG_TYPE_INT |OP_FLAG_TYPE_FLOAT |OP_FLAG_TYPE_STRING |OP_FLAG_TYPE_MEM_REF |OP_FLAG_TYPE_REG );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了直接将指令 <code>硬编码</code> 以外，我们还可以将指令用一种可解析的格式写入文件，如下：</p><pre class="line-numbers language-arm" data-language="arm"><code class="language-arm">Mov 0 2MemRefInt Float String MemRefJmp 19 1Label<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过不同的指令文件，我们的系统就可以解析不同的指令集，使得我们的汇编器扩展性增强。</p><p><img src="instructionSets.png" alt="instructionSets"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>到目前我们的汇编器全局的数据结构如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// Source code representationchar ** g_ppstrSourceCode = NULL;int g_iSourceCodeSize;// The instruction lookup tableInstrLookup g_InstrTable [ MAX_INSTR_LOOKUP_COUNT ];// The assembled instruction streamInstr * g_pInstrStream = NULL;int g_iInstrStreamSize;// The script headerScriptHeader g_ScriptHeader;// The main tablesLinkedList g_StringTable;LinkedList g_FuncTable;LinkedList g_SymbolTable;LinkedList g_LabelTable;LinkedList g_HostAPICallTable;//String tableint AddString ( LinkedList * pList, char * pstrString );//Next up is the function table:int AddFunc ( char * pstrName, int iEntryPoint );FuncNode * GetFuncByName ( char * pstrName );void SetFuncInfo ( char * pstrName, int iParamCount, int iLocalDataSize );//Followed by the symbol and label tables:int AddSymbol ( char * pstrIdent, int iSize, int iStackIndex, int iFuncIndex );SymbolNode * GetSymbolByIdent ( char * pstrIdent, int iFuncIndex );int GetStackIndexByIdent ( char * pstrIdent, int iFuncIndex );int GetSizeByIdent ( char * pstrIdent, int iFuncIndex );int AddLabel ( char * pstrIdent, int iTargetIndex, int iFuncIndex );LabelNode * GetLabelByIdent ( char * pstrIdent, int iFuncIndex );//Lastly, there’s the instruction lookup table:int AddInstrLookup ( char * pstrMnemonic, int iOpcode, int iOpCount );void SetOpType ( int iInstrIndex, int iOpIndex, OpTypes iOpType );int GetInstrByMnemonic ( char * pstrMnemonic, InstrLookup * pInstr );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 重学计算机系列 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己动手构建简易虚拟机和编译器-设计目标（2）</title>
      <link href="/2018/05/12/zi-ji-dong-shou-gou-jian-jian-yi-xu-ni-ji-he-bian-yi-qi-she-ji-mu-biao/"/>
      <url>/2018/05/12/zi-ji-dong-shou-gou-jian-jian-yi-xu-ni-ji-he-bian-yi-qi-she-ji-mu-biao/</url>
      
        <content type="html"><![CDATA[<p>在开始之前，我们必须明确我们的脚本语言需要哪些特性。XtremeScript 是一个类 C 的过程性脚本语言，但是没有 C 的指针、结构体等，显然这些东西会大大增加复杂性。</p><a id="more"></a><h2 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>XtremeScript 只支持简单的单个变量和一维数组。<br>由于 XtremeScript 是无类型的，所以没有专门的 Bool 类型，可以通过整数来实现，故XtremeScript的变量可以赋 整数、浮点数和字符串，如下所示</p><pre class="line-numbers language-none"><code class="language-none">var X=12;var Y=12.2var Z="hello"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>XtremeScript 支持一维数组，由于数组元素可以是任意类型，所以 XtremeScript 数组也可以模拟结构体。</p><h3 id="操作符和表达式"><a href="#操作符和表达式" class="headerlink" title="操作符和表达式"></a>操作符和表达式</h3><ol><li>算术表达式<br><img src="arithmetic.png" alt="算术表达式"></li><li>比特位操作<br>![比特位操作](Bitwise operator.png)</li><li>逻辑操作<br>![比特位操作](Logical Operators.png)</li><li>关系运算<br>![比特位操作](Relational Operators.png)</li><li>操作符优先级<br>![比特位操作](Operator Precedence.png)</li></ol><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>类似与 C 语言的代码块。</p><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>支持分支和循环</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>以 <code>func</code> 为关键字，且不支持函数嵌套定义。</p><pre class="line-numbers language-none"><code class="language-none">func Add(X,Y){  return X+Y;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>支持转义字符和单行注释</p><h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p><img src="words.png" alt="保留字"></p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 重学计算机系列 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己动手构建简易虚拟机和编译器-序言（1）</title>
      <link href="/2018/05/12/zi-ji-dong-shou-gou-jian-jian-yi-xu-ni-ji-he-bian-yi-qi-xu-yan/"/>
      <url>/2018/05/12/zi-ji-dong-shou-gou-jian-jian-yi-xu-ni-ji-he-bian-yi-qi-xu-yan/</url>
      
        <content type="html"><![CDATA[<p><code>编译原理</code> 作为计算机核心课程之一，在我们学习过程中，往往参考 <code>龙书</code> 、<code>虎书</code>、 <code>鲸书</code> 等，这些书中大多充斥着很多理论知识，光是实现书中的算法，就有一定难度了，即使理解了书中算法，理论与实际始终存在鸿沟。当我发现 <code>Game Scripting Mastery</code> 时，才知道了编译原理入门的正确打开方式。在本书中作者最终会完成一个脚本语言、一个虚拟机和编译器，尽管它们都采用了最简单的方式实现，但是对于了解编译原理的整体脉络是大有裨益的，后续文章将对其逐个介绍。</p><a id="more"></a><h2 id="最终目标"><a href="#最终目标" class="headerlink" title="最终目标"></a>最终目标</h2><p>![最终目标](compiler arc.png)</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 重学计算机系列 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己动手构建简易虚拟机和编译器-汇编语言（3）</title>
      <link href="/2018/05/12/zi-ji-dong-shou-gou-jian-jian-yi-xu-ni-ji-he-bian-yi-qi-hui-bian-yu-yan/"/>
      <url>/2018/05/12/zi-ji-dong-shou-gou-jian-jian-yi-xu-ni-ji-he-bian-yi-qi-hui-bian-yu-yan/</url>
      
        <content type="html"><![CDATA[<p>从计算机语言演变史可知，汇编语言是非常底层的语言，那我们为什么不直接从高级语言开始呢？首先， C 、 C++ 都会编译成汇编语言，然后汇编成机器码；其次，我们也可以直接面向汇编来编程，虽然实际开发中很少这样。所以汇编语言作为高级语言和运行时环境的中间人，也同样重要。</p><a id="more"></a><h2 id="汇编指令集"><a href="#汇编指令集" class="headerlink" title="汇编指令集"></a>汇编指令集</h2><p>汇编语言包含了一系列汇编指令，既然高级语言能够编译成汇编语言，那么汇编语言也一定能够实现高级语言的赋值、分支、循环等。</p><ol><li>汇编语言通过 <code>MOV</code> 指令模拟高级语言的赋值语句</li></ol><pre class="line-numbers language-none"><code class="language-none">MOV X,3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>汇编语言通过 <code>CMP</code> 指令模拟条件判断</li></ol><pre class="line-numbers language-none"><code class="language-none">Cmp X, YJG TrueCase; Execute false caseJmp SkipTrueCaseTrueCase:; Execute true caseSkipTrueCase:; The "if construct" is complete,; so the program continues<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="jumpif.png" alt="cmp指令"></p><ol start="3"><li>汇编语言通过 <code>JMP</code> 结合 <code>CMP</code> 指令模拟高级语言的循环</li></ol><p><img src="loop.png" alt="循环"></p><p>一条高级语言的语句一般会被翻译为多条汇编语句，那么汇编语句实现的功能是应该复杂还是简单呢？这就产生了两个流派 <code>RISC</code> 和 <code>CISC</code> ， <code>RISC</code> 提供大量简单高效的指令，而 <code>CISC</code> 则提供相对少量功能强大的指令。这两者没有绝对的好坏，现在的 <code>CPU</code> 已经融合了两者的优点。</p><h2 id="指令的正交性"><a href="#指令的正交性" class="headerlink" title="指令的正交性"></a>指令的正交性</h2><p>指令的正交性是指指令是 <code>平衡的</code> ，即有一个加法指令，那么一定会有一个减法指令。由于历史原因和兼容性，80X86 指令集并不是正交的，80X86 的 <code>Add</code> 和 <code>Sub</code> 指令实现方式与 <code>Div</code> <code>Mul</code> 的实现方式并不一致。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器由于直接位于 <code>CPU</code> 中，所以速度更快，同时寄存器也可以作为传递值的媒介。在 <code>XtremeScript Virtual Machine</code> 中，寄存器仅仅作为全局属性，保存函数返回值。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈作为一种后进先出的数据结构，十分适合处理函数调用。</p><h3 id="栈帧、活动记录"><a href="#栈帧、活动记录" class="headerlink" title="栈帧、活动记录"></a>栈帧、活动记录</h3><p>当我们用栈来实现函数调用时，自然会涉及到以下几个问题：</p><ol><li>怎么传递和获取函数参数？</li><li>函数调用完成后，怎么返回？</li><li>局部变量怎么分配？</li><li>怎么获取变量的索引？</li></ol><p><img src="stackframe.png" alt="栈帧"></p><p>注意：函数参数是由调用者压入，但是注意入栈顺序；另一方面，变量的索引是基于当前栈顶相对定位的。</p><h2 id="XVM-指令集"><a href="#XVM-指令集" class="headerlink" title="XVM 指令集"></a>XVM 指令集</h2><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><pre class="line-numbers language-none"><code class="language-none">Mov Destination,Source<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意 <code>Source</code> 可以为 integer,float,string 或者 memory refrence(variable,array index), 而 <code>Destination</code> 只能为 memory refrence.</p><h3 id="Arithmetic"><a href="#Arithmetic" class="headerlink" title="Arithmetic"></a>Arithmetic</h3><pre class="line-numbers language-none"><code class="language-none">Add Destination, SourceSub Destination, SourceMul Destination, SourceDiv Destination, SourceMod Destination, SourceExp Destination, PowerNeg DestinationInc DestinationDec Destination<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Bitwise"><a href="#Bitwise" class="headerlink" title="Bitwise"></a>Bitwise</h3><pre class="line-numbers language-none"><code class="language-none">And Destination, SourceOr Destination, SourceXOr Destination, SourceNot DestinationShL Destination, ShiftCountShR Destination, ShiftCount<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="String-Processing"><a href="#String-Processing" class="headerlink" title="String Processing"></a>String Processing</h3><pre class="line-numbers language-none"><code class="language-none">Concat String0, String1GetChar Destination, Source, IndexSetChar Index, Destination, Source<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Conditional-Branching"><a href="#Conditional-Branching" class="headerlink" title="Conditional Branching"></a>Conditional Branching</h3><pre class="line-numbers language-none"><code class="language-none">Jmp LabelJE Op0, Op1, LabelJNE Op0, Op1, LabelJG Op0, Op1, LabelJL Op0, Op1, LabelJGE Op0, Op1, LabelJLE Op0, Op1, Label<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Stack-Interface"><a href="#Stack-Interface" class="headerlink" title="Stack Interface"></a>Stack Interface</h3><pre class="line-numbers language-none"><code class="language-none">Push SourcePop Destination<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Function-Interface"><a href="#Function-Interface" class="headerlink" title="Function Interface"></a>Function Interface</h3><pre class="line-numbers language-none"><code class="language-none">Call FunctionNameRetCallHost FunctionName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h3><pre class="line-numbers language-none"><code class="language-none">Pause DurationExit Code<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="XASM-Directives"><a href="#XASM-Directives" class="headerlink" title="XASM Directives"></a>XASM Directives</h2><p>除了 XASM 指令集，XASM 还存在一类 <code>指令</code> ，本身并不会被翻译为机器码，仅仅是给编译器指示作用。</p><h3 id="Stack-and-Data"><a href="#Stack-and-Data" class="headerlink" title="Stack and Data"></a>Stack and Data</h3><pre class="line-numbers language-none"><code class="language-none">SetStackSize 1024<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><pre class="line-numbers language-none"><code class="language-none">Func Add{  Param Y  Param X  Var Sum  Mov Sum, X  Add Sum, Y  Mov _RetVal, Sum}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Escape-Sequences"><a href="#Escape-Sequences" class="headerlink" title="Escape Sequences"></a>Escape Sequences</h3><pre class="line-numbers language-none"><code class="language-none">Mov Quote, "Waring: \"Troops! Mobilize!\""<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h3><pre class="line-numbers language-none"><code class="language-none">; This is a comment.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 重学计算机系列 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何高效学习</title>
      <link href="/2018/05/12/ru-he-gao-xiao-xue-xi/"/>
      <url>/2018/05/12/ru-he-gao-xiao-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>  回想一下在平时的学习过程中，我们的学习步骤有哪些？一般我们首先阅读要学习的内容，然后理解里面的各个知识点，最后可能会做一些练习。经过这几个步骤的学习有什么问题呢？首先我们当时自以为已经完全理解并掌握了相关知识点，隔一段时间，再遇到同样的知识点，可能需要重新学习。其次，即使理解了知识点，当放到实际应用场景中却不会用了。根本原因在于，看似我们看了很多书、学了很多东西，但是这些知识没有经过加工、转换，融入到我们已有的知识体系中，这些知识是孤立的。通过阅读 <code>如何高效学习</code> 一书，可以找到许多值得借鉴的地方。</p><a id="more"></a><h2 id="高效学习思维导图"><a href="#高效学习思维导图" class="headerlink" title="高效学习思维导图"></a>高效学习思维导图</h2><p><img src="LearnMoreStudyLess.png" alt="高效学习"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>当我们在学习新的知识时，将关键点用笔记流的方式勾勒出来，从而对整个知识体系有全局的了解，以便后续深入各个知识点。这是一个将书读薄的过程。</li><li>在我们理解了对应知识点后，要横向、纵向、深度拓展，比如我们在学习 <code>java</code> 异常处理时，需要弄明白外什么需要异常（深度拓展）， <code>java</code> 异常机制与其他语言异常机制有什么联系、异同，各自的优缺点（横向拓展），异常和错误的关系等。这是一个将书读厚的过程。</li><li>当我们理解了对应知识点后，学习并没有结束，一切还停留在理论层面，这时我们应该以项目形式，制订目标和计划，对所学知识进行实战。比如学习编译原理后，可以尝试写一个简单的编译器，学习网络后，可以尝试编写一个简单的服务器。</li></ol><p>通过以上梳理，发现大多数时候我们的学习常常停留在理解层面，没有对知识拓展和应用，导致知识掌握不牢、灵活应用能力差。在以后的学习过程中，我们应该培养高效学习的习惯，真正做到</p><blockquote><p>Learn More Study Less</p></blockquote><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习类 </category>
          
          <category> 方法论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 元认知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parsing Techniques-Introduction</title>
      <link href="/2018/04/09/parsing-techniques-introduction/"/>
      <url>/2018/04/09/parsing-techniques-introduction/</url>
      
        <content type="html"><![CDATA[<p>介绍</p><a id="more"></a><h2 id="解析技术分类"><a href="#解析技术分类" class="headerlink" title="解析技术分类"></a>解析技术分类</h2><p><img src="%E8%A7%A3%E6%9E%90%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB.png" alt="解析技术分类"></p><p>##<br>##</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决问题的策略</title>
      <link href="/2018/03/10/jie-jue-wen-ti-de-ce-lue/"/>
      <url>/2018/03/10/jie-jue-wen-ti-de-ce-lue/</url>
      
        <content type="html"><![CDATA[<p>现实生活中，我们往往只专注于解题本身，而没有思考关于解决问题策略的相关技术，类似认知中的 <code>元认知</code> 。本章主要介绍了解决问题的步骤以及解决问题的基本策略。</p><a id="more"></a><h2 id="解决问题的过程"><a href="#解决问题的过程" class="headerlink" title="解决问题的过程"></a>解决问题的过程</h2><p>解决问题的经典著作 <code>怎样解题(How to Solve It)</code> 将解决问题划分为四个阶段：</p><ol><li>理解问题</li><li>指定解题计划</li><li>按照计划解决问题</li><li>回顾解题过程，思考是否有更好的解题方法</li></ol><h3 id="第一阶段：阅读并理解问题"><a href="#第一阶段：阅读并理解问题" class="headerlink" title="第一阶段：阅读并理解问题"></a>第一阶段：阅读并理解问题</h3><p>理解题意是解决问题最基本的步骤，但是在实际解题过程中，往往存在审题不清、读题不细等问题。所以我们必须仔细阅读题目并理解其含义。</p><h3 id="第二阶段：重新定义和抽象化"><a href="#第二阶段：重新定义和抽象化" class="headerlink" title="第二阶段：重新定义和抽象化"></a>第二阶段：重新定义和抽象化</h3><p>重新定义是指用自己熟悉的概念和术语重构问题，有助于直观理解问题的要求。抽象化则要求我们将题目描述中复杂的东西，抽象成数学语言或者计算机概念，保留最本质的东西。</p><h3 id="第三阶段：制订解题计划"><a href="#第三阶段：制订解题计划" class="headerlink" title="第三阶段：制订解题计划"></a>第三阶段：制订解题计划</h3><p>该阶段我们要思考，用什么方法解决问题、选择什么样的算法和数据结构。</p><h3 id="第四阶段：验证计划"><a href="#第四阶段：验证计划" class="headerlink" title="第四阶段：验证计划"></a>第四阶段：验证计划</h3><p>有了解题计划，不是说马上动笔，我们应该验证下算法是否在所有情况下都正确，确认其时间复杂度和空间复杂度。</p><h3 id="第五阶段：执行计划"><a href="#第五阶段：执行计划" class="headerlink" title="第五阶段：执行计划"></a>第五阶段：执行计划</h3><p>编写代码并调试</p><h3 id="第六阶段：回顾"><a href="#第六阶段：回顾" class="headerlink" title="第六阶段：回顾"></a>第六阶段：回顾</h3><p>本步骤往往最容易忽略，我们不能一味追求 <code>量</code> ，我们更应该追求 <code>质</code> 。</p><blockquote><p><strong>高效的回顾方法应该是，把解题代码和解题过程的经验总结成册，记录解题的方法、着手解题的方式、寻找解题过程中决定性领悟，通过复习这些解题经验，找到问题之间共有的模式，最终形成方法体系和方法论。另外，我们还应该记录自己出错的原因，从失误中学习，因为我们往往会犯同一个错多次。 此外，可以学习别人的解题方案，对于拓宽我们的思路大有裨益。</strong></p></blockquote><h3 id="不会解题时"><a href="#不会解题时" class="headerlink" title="不会解题时"></a>不会解题时</h3><p>没有 <code>银弹</code> ，任何算法和策略都不是万能的，当我们苦苦思索后任无头绪，这个时候可以参考别人的解法。但是参考别人的解法时，一定要思考，为什么没有想到解题的方法，是知识点缺失、方向错误、方法不对？</p><div class="note warning"><p>注意事项：上述策略只是帮助思考，不必完全遵循，需要灵活运用</p></div><h2 id="解决问题的策略"><a href="#解决问题的策略" class="headerlink" title="解决问题的策略"></a>解决问题的策略</h2><p>遇到简单问题可以直接求解，但是对于比较难的问题，需要尝试各种方法，那么应该怎么尝试呢？</p><h2 id="以前解过类似的题吗？"><a href="#以前解过类似的题吗？" class="headerlink" title="以前解过类似的题吗？"></a>以前解过类似的题吗？</h2><p>很多问题看似相差很大，但是只要仔细分析，运用联想思维，便会发现很多问题本质是一样的或者类似的。不过，我们需要掌握每种方法的适用范围，不能生搬硬套。</p><h2 id="能否从简单的方法开始呢？"><a href="#能否从简单的方法开始呢？" class="headerlink" title="能否从简单的方法开始呢？"></a>能否从简单的方法开始呢？</h2><p>面对一个陌生的问题，我们可以想想 <code>能不能用最笨的方法解决呢？</code> ，这样可以避免把简单的问题复杂化。另一方面，高效的算法往往也是由“笨”办法为基础，采用更有效的数据结构和避免重复的计算，就有可能设计出高效的算法。</p><h2 id="能否解题过程公式化？"><a href="#能否解题过程公式化？" class="headerlink" title="能否解题过程公式化？"></a>能否解题过程公式化？</h2><p>一般题目都会提供示例输入和输出，我们可以尝试解决示例，通过从特殊到一般，将特殊情况解决过程公式化，有助于找到正确的解题方法。</p><h2 id="能否简化问题？"><a href="#能否简化问题？" class="headerlink" title="能否简化问题？"></a>能否简化问题？</h2><p>另一个解决问题的工具是，先解决问题的简化版本。简化问题有很多种，比如去掉约束条件、减少计算变量、多维问题降为一维问题。简化后问题求解将变得简单，只要找到简化问题同原问题的联系，便能指导我们找到原问题的解。</p><h2 id="能否画成图？"><a href="#能否画成图？" class="headerlink" title="能否画成图？"></a>能否画成图？</h2><p><code>一图胜千言</code> ，图形能够让我对题目有更加直观的感受。</p><h2 id="能否用公式表达？"><a href="#能否用公式表达？" class="headerlink" title="能否用公式表达？"></a>能否用公式表达？</h2><p>有时如果我们能够将问题用公式重新表达，也是由帮助的。因为公式的各种数学运算如展开、消减，对解题带来莫大好处。</p><h2 id="能分解问题吗？"><a href="#能分解问题吗？" class="headerlink" title="能分解问题吗？"></a>能分解问题吗？</h2><p><code>分而治之</code> 是我们解决问题的法宝。</p><h2 id="能否倒序解决问题？"><a href="#能否倒序解决问题？" class="headerlink" title="能否倒序解决问题？"></a>能否倒序解决问题？</h2><p>正向思维不好解决问题时，适时的采用逆向思维，往往能收到奇效。倒序排序将问题的内在顺序颠倒，经常能豁然开朗。</p><h2 id="能否排序后再求解？"><a href="#能否排序后再求解？" class="headerlink" title="能否排序后再求解？"></a>能否排序后再求解？</h2><p>涉及到序列、操作顺序的题目，如果首先将其排序，经常能简化问题，当我们面对有序的问题时，解答要容易得多。如<a href="http://www.owensworld.com/games/strategy/lights" title="关灯问题">关灯游戏</a> ,本身灯的点击顺序是无关紧要的，同时一个格子没必要点击两次以上。假设以特定顺序点击格子，先确定第一行的状态，第二行也确定了，后面几行以此类推。</p><h2 id="可否只考虑特定形式的答案？"><a href="#可否只考虑特定形式的答案？" class="headerlink" title="可否只考虑特定形式的答案？"></a>可否只考虑特定形式的答案？</h2><p>作为排序法的扩展，还有正规化方法，该方法将得到的任意答案转换为特定形式的变换方法。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 算法问题实战策略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 解决问题策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书单</title>
      <link href="/2018/03/08/shu-dan/"/>
      <url>/2018/03/08/shu-dan/</url>
      
        <content type="html"><![CDATA[<p>书单合集</p><a id="more"></a><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><ol><li>Paring Techniques</li><li>编译原理（龙书）</li><li>The Compiler Design Handbook: Optimizations and Machine Code Generation, Second Edition<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ol><li>introduction to recursive programming</li><li>Recursion via Pascal</li><li>Thinking Recursively with Java</li><li>Practicing Recursion in Java</li></ol></li></ol><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><ol><li>架构探险：从零开始写 JavaWeb 框架.pdf</li><li>[Spring技术内幕：深入解析Spring架构与设计原理（第2版）].计文柯.扫描版</li><li>spring揭秘(完整)</li><li>深入分析Java  Web技术内幕  修订版</li><li>java工程师修炼之道</li><li>码农翻身</li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol><li>PostgreSQL 查询引擎源码技术探析</li></ol><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ol><li><p>JAVA多线程设计模式</p></li><li><p>Java并发编程实战 （java并发的圣经）</p></li><li><p>多处理器编程的艺术 （并发编程的各种算法，java实现，有点难度）</p></li><li><p>并发的艺术 （多核处理器的共享内存模型中的各种算法）</p></li><li><p>Java虚拟机并发编程  （jvm平台上各种语言的并发比较，如java，scala，clojure）</p></li><li><p>Java并发编程的艺术</p></li><li><p>Java 7并发编程实战手册 （java中的并发编程实践，属于API工具书，指南）</p></li><li><p>Java多线程编程实战指南（设计模式篇） (豆瓣)</p></li><li><p>Java多线程编程核心技术 (豆瓣)</p></li><li><p>Java并发编程：核心方法与框架实战Java高并发程序设计</p></li><li><p>七周七并发模型 (豆瓣)（七种并发模型的比较）</p></li><li><p>Go并发编程实战 (豆瓣)C#并发编程经典实例 (豆瓣)</p></li><li><p>C#多线程编程实战 (豆瓣)</p></li><li><p>Haskell并行与并发编程 (豆瓣)</p></li><li><p>事务信息系统 (豆瓣) （数据库层面的并发）</p></li><li><p>C++ Concurrency in Action (豆瓣) （C++中的并发）</p></li><li><p>C++多线程编程实战</p></li><li><p>Akka Concurrency (豆瓣)(大名鼎鼎的AKKA中的并发模式)</p></li><li><p>Scala并发编程 (豆瓣)</p></li><li><p>Mastering Concurrency in Go (豆瓣) （Go中的并发编程）</p></li><li><p>Python编程实战 (豆瓣) （Python中运用设计模式、并发和程序库创建高质量程序）</p></li><li><p>Erlang/OTP并发编程实战 (豆瓣)  （Erlang中的并发）</p></li><li><p>图解Java多线程设计模式</p></li><li><p><a href="https://www.douban.com/doulist/3385709/">https://www.douban.com/doulist/3385709/</a></p></li><li><p><a href="https://www.douban.com/doulist/41916951/">https://www.douban.com/doulist/41916951/</a></p></li><li><p><a href="https://www.douban.com/doulist/3385709/">https://www.douban.com/doulist/3385709/</a></p></li><li><p><a href="https://www.douban.com/doulist/1755664/">https://www.douban.com/doulist/1755664/</a></p></li><li><p><a href="http://www.360doc.com/content/16/1225/21/16163490_617634219.shtml">http://www.360doc.com/content/16/1225/21/16163490_617634219.shtml</a></p></li><li><p><a href="https://www.goodreads.com/shelf/show/concurrency">https://www.goodreads.com/shelf/show/concurrency</a></p></li><li><p>一些博客：《深入浅出 Java Concurrency》目录聊聊并发（一）——深入分析Volatile的实现原理专栏：Java并发编程系列《深入理解并行编程》中文版Java并发性和多线程介绍目录深入理解Java内存模型浅析C++多线程内存模型 – 算法</p></li><li><p>Distributed Algorithms An Intuitive Approach</p></li><li><p>Design and Analysis of Distributed Algorithms</p></li><li><p><a href="https://download.csdn.net/download/Hope2005/1003729">https://download.csdn.net/download/Hope2005/1003729</a><br>I Heart Logs<br>Synchronization Algorithms and Concurrent Programming<br>Event Processing in Action<br>Event-Based Programming<br>Java程序性能优化<br>A Primer on Memory Consistency and Cache Coherence<br>Is Parallel Programming Hard, And, If So, What Can You Do About It?<br>Systems Performance<br>Pattern-Oriented Software Architecture<br>Java虚拟机并发编程<br>Java Performance<br>Advanced Virtual Machine Design and Implementation<br>Oracle JRockit<br>Java Generics and Collections<br>OpenJDK cookbook<br>java并发编程之美<br>Concurrent Programming in Java<br>NoSQL Distilled<br>Immutable Object<br>Algorithms- A Functional Programming Approach<br>AI Algorithms, Data Structures, and Idioms in Prolog, Lisp, and Java<br>Java Concurrent Programming: A Quantitative Approach</p></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>分布式数据库系统原理与应用<br>事务处理<br>数据库系统实现<br>Database Management Systems  by Raghu Ramakrishnan and Johannes Gehrke<br>大规模分布式存储系统<br>MySQL性能调优与架构设计<br>Netty in Action<br>Kafka权威指南<br>Introduction to Recursive Programming<br>Computer Science Distilled: Learn the Art of Solving Computational Problems</p><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>逻辑引擎<br>哥德尔、艾舍尔、巴赫-集异璧之大成<br>数学：确定性的丧失<br>线性代数及其应用<br>3b1b的线性代数的本质<br>Convex Optimization  Stephen Boyd<br>Numerical Optimization<br>矩阵分析与应用<br>Pattern Recognition and Machine Learning<br>Deep Learning<br>《矩阵分析》By Horn Roger</p><h2 id="学习方法类"><a href="#学习方法类" class="headerlink" title="学习方法类"></a>学习方法类</h2><p> 如何高效学习（Learn More Study Learn Less）</p><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p><a href="https://github.com/cquliaoli/Skill-Tree">https://github.com/cquliaoli/Skill-Tree</a><br><a href="https://github.com/y123456yz">https://github.com/y123456yz</a><br><a href="https://github.com/huangz1990/redis-3.0-annotated">https://github.com/huangz1990/redis-3.0-annotated</a><br><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Redis.md">https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Redis.md</a></p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 书单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长递增子序列</title>
      <link href="/2018/03/06/zui-chang-di-zeng-zi-xu-lie/"/>
      <url>/2018/03/06/zui-chang-di-zeng-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<p>小猴子下山，沿着下山的路有一排桃树，每棵树都结了一些桃子。小猴子想摘桃子，但是又一些条件需要遵守，小瘦子只能沿着下山的方向走，不能回头，每棵树最多摘一个，而且一旦摘了一棵树的桃子，就不能再摘比这棵树结的桃子少的树上的桃子，那么小猴子最多能摘到几课桃子呢？</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>距离说明，比如有五棵树，分别结了10，4，5，12，8棵桃子，那么小猴子最多能摘3颗桃子，来自于结了4，5，12颗桃子的桃树。</p><h2 id="解答一"><a href="#解答一" class="headerlink" title="解答一"></a>解答一</h2><p>本题的本质就是最长递增子序列，为了叙述方便，用 $ a_i $ 表示第 <code>i</code> 个元素， $M(t)<em>{0\let\lei-1}$ 为前 <code>t</code>个元素的 <code>LIS(Longest Increasing Subsequence)</code> 的长度， 我们可以这样思考，假设 $M(i)$ 已经求得 ，怎么求  $M(i+1)$ 呢？仅仅通过 $M(i)$ 是无法确定 $M(i+1)$ 的，因为 $ a_i $ , $ a_{i-1} $ 与 $ a</em>{i+1} $ 大小关系未知，所以 $M(i+1)$ 与 $M(t)_{0\le t \le i-1}$ 都有关,另一方面，只是知道 $M(i+1)$ 的长度还不够，我们需要知道 $M(i+1)$ 的结尾数字，这样才能判断是否将 $ a_i $ 加入到 $M(i)$ 末尾，故  $M(i)$ 定义为以 $ a_{i-1} $ 结尾的 <code>LIS</code> 长度 。综上得到递推关系式子：</p><p>$$ M(t)= \lbrace { Max(M(i)_{ i \lt t , a_i \lt a_t }) }+1 \rbrace   $$</p><h2 id="解答二"><a href="#解答二" class="headerlink" title="解答二"></a>解答二</h2><p>看到 <code>最长</code> 、 <code>子序列</code> ，很容易想到另一题 <code>最长公共子序列 LCS </code> ，其实本题也可以通过 <code>LCS</code> 的解法求解，只要将原序列排序，然后求其与原序列的 <code>LCS</code> 。假设两个序列分别为 $ X_n=\lbrace x_1,x_2,x_3,\cdots ,x_n\rbrace , Y_n=\lbrace y_1,y_2,y_3,\cdots ,y_n \rbrace $ ，同样的其 <code>LCS</code> 为 $Z_n=\lbrace z_1,z_2,z_3,\cdots ,z_k \rbrace$ ，注意 $ Z_k $ 与 $ X_n $ , $ Y_n$ 并不一定相等。根据解法一的思想我们怎么求 $ Z_{n+1}$ 呢？同样的我们要找到 $ X_{n+1} $ , $ Y_{n+1}$ ,$ Z_k $ , $ Z_{n+1}$ 的关系，为了叙述方便，令 $C_{i,j}$ 为 $X_i $ 与 $Y_j$ 的 <code>LCS</code>， 如果 $ X_{i+1}= Y_{j+1}$ 必有 $ C_{(i+1,j+1)}= C_{i,j} + 1$ ，否则$ C_{(i+1,j+1)} $ 与 $ C_{(i,j+1)} $ , $ C_{(i+1,j)} $ 都有关。故有以下递推式：</p><p>$$<br>C_{i,j}=<br>\begin{cases}<br>0, &amp; \text{if $i=0,j=0$ }  \\<br>C_{i-1,j-1}, &amp; \text{ if $ i,j \gt  0 $ and $ x_i=y_i$ }   \\<br>Max(C_{i,j-1},C(i-1,j)), &amp; \text{ if $ i,j \gt  0 $ and $ x_i \neq y_i $ }\<br>\end{cases}<br>$$</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单边车线路优化</title>
      <link href="/2018/03/06/dan-bian-che-xian-lu-you-hua/"/>
      <url>/2018/03/06/dan-bian-che-xian-lu-you-hua/</url>
      
        <content type="html"><![CDATA[<p>在快递公司干线运输的车辆使用中，存在着单边车和双边车的两种使用场景，例如 北京中心-杭州中心，两个分拨中心到彼此的单量对等，则可以开双边车（即同一辆车可以往返对开），而当两个中心的对发单量不对等时，则会采用单边车，并且双边车的成本是低于单边车的，即将两辆对开的单边车合并为一辆往返的双边车是能够节省运力成本的。所以实际运行过程中，需要优化单边车。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在快递公司干线运输的车辆使用中，存在着单边车和双边车的两种使用场景，例如 北京中心-杭州中心，两个分拨中心到彼此的单量对等，则可以开双边车（即同一辆车可以往返对开），而当两个中心的对发单量不对等时，则会采用单边车，并且双边车的成本是低于单边车的，即将两辆对开的单边车合并为一辆往返的双边车是能够节省运力成本的。单边车优化原则：<br>将单边车优化的规则进行可抽象为以下三种（ A , B , C 均表示分拨中心）：</p><ol><li>规则-1: A-B 单边车，B-A 单边车 优化方案：将A-B和B-A的两辆单边车合并为双边；</li><li>规则-2: A-B 单边车，B-C 单边车，C-A 单边车 优化方案：将 A-B 、B-C 、C-A 的三辆单边车优化为一辆环形往返车；</li><li>规则-3: A-B 单边车，C-A 单边车，B、C 同省 优化方案：当 B、C 同省，将 A-B 、 C-A 两辆单边优化为一辆环形往返 ；</li></ol><p>问题如下：<br>以某快递公司的实际单边车数据为例（线路ID编码;出分拨中心; 出分拨中心所在省;到达分拨中心;到达分拨中心所在省；车型；），进行优化，优化的规则参照以上，并且优先级依次降低，合并的时候需要考虑车型（分为 17.5m 和 9.6m 两种）：</p><ol><li>相同车型才能进行合并；</li><li>两辆同方向的 9.6m 可以与一辆 17.5m 的对开车型合并优化</li></ol><p><strong>说明：</strong><br>优化输出结果按照规则分类，例如 rule1： 2016120001+2016120002 表示将单边车线路ID编码为 2016120001 和 2016120002 按照规则 1 合并优化。</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>首先直接想到的解法是通过循环判断，针对规则 1 ,两层 <code>for</code> 循环即可，时间复杂度为 $O(n^2)$ ，针对规则 2，需要使用三层 <code>for</code> 循环，时间复杂度未 $O(n^3)$ ，针对规则 3 ，需要两层 <code>for</code> 循环，时间复杂度也为  $O(n^2)$ 。三个规则如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 单边车数据对象 */public static class UnilateralLine {    private String id;    private String sCen;//出发分拨    private String sPro;//出发省    private String eCen;//到达分拨    private String ePro;//到达省    //9.6m/17.5m    private String tType;//车型    public UnilateralLine(String id, String sCen,        String sPro, String eCen, String ePro, String tType) {        this.id = id;        this.sCen = sCen;        this.sPro = sPro;        this.eCen = eCen;        this.ePro = ePro;        this.tType = tType;    }    public String getId() {        return id;    }    public void setId(String id) {        this.id = id;    }    public String getSCen() {        return sCen;    }    public void setSCen(String ePro) {        this.ePro = ePro;    }    public String getSPro() {        return sPro;    }    public void setSPro(String sPro) {        this.sPro = sPro;    }    public String getECen() {        return eCen;    }    public void setECen(String eCen) {        this.eCen = eCen;    }    public String getEPro() {        return ePro;    }    public void setEPro(String ePro) {        this.ePro = ePro;    }    public String getTType() {        return tType;    }    public void setTType(String tType) {        this.tType = tType;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 规则1 * * @param lineList 单边车数据列表 * @return 结果 */public static List&lt;String&gt; unilateralOptRule1(        List&lt;UnilateralLine&gt; lineList) {    List&lt;String&gt; result = new ArrayList&lt;String&gt;();    if (lineList.size() &lt; 2)        return result;    for (int i = 0; i &lt; lineList.size(); i++) {        for (int j = 1; j &lt; lineList.size(); j++) {            //A-&gt;B B-&gt;A            if (lineList.get(i).sCen == lineList.get(j).eCen                    &amp;&amp; lineList.get(i).eCen == lineList.get(j).sCen                    &amp;&amp; lineList.get(i).tType == lineList.get(j).tType) {                result.set(i, (lineList.get(i).id + lineList.get(j).id));                lineList.remove(i);                lineList.remove(j);            }        }    }    return result;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**  * 规则 2  * @param lineList 单边车数据列表  * @return  */ public static List&lt;String&gt;unilateralOptRule2(List&lt;UnilateralLine&gt; lineList){     List&lt;String&gt; result = new ArrayList&lt;String&gt;();     if (lineList.size() &lt; 3)         return result;     for (int i = 0; i &lt; lineList.size(); i++)     {         for(int j=1;j&lt;lineList.size();j++)         {             if(lineList.get(i).eCen == lineList.get(j).sCen){                 for (int k=2;k&lt;lineList.size();k++)                 {                     //A-&gt;B B-&gt;C C-&gt;A, 形成环且满足车型规则                     if(lineList.get(i).sCen==lineList.get(k).eCen                             &amp;&amp;lineList.get(j).eCen==lineList.get(k).sCen                             &amp;&amp;typeCheck(lineList.get(i).tType                             ,lineList.get(k).tType                             ,lineList.get(k).tType)){                         result.set(i, (lineList.get(i).id + lineList.get(j).id + lineList.get(k).id));                         lineList.remove(i);                         lineList.remove(k);                         lineList.remove(j);                     }                 }             }         }     }     return result; }    /**     * 判断是否满足合并规则     * @param type1     * @param type2     * @param type3     * @return     */    public static boolean typeCheck(String type1,String type2,String type3){        String a = "9.6m";        if (type1 == type2 &amp;&amp; type2 == type3) {            return true;        } else {            if (type1 == type2 &amp;&amp; type1.equals(a)) {                return true;            }            if (type1 == type3 &amp;&amp; type1.equals(a)) {                return true;            }            if (type2 == type3 &amp;&amp; type2.equals(a)) {                return true;            }        }        return false;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**  * 规则 3  * @param lineList 单边车数据列表  * @return  */ public static List&lt;String&gt;unilateralOptRule3(List&lt;UnilateralLine&gt; lineList) {     List&lt;String&gt; result = new ArrayList&lt;String&gt;();     if (lineList.size() &lt; 2)         return result;     for (int i = 0; i &lt; lineList.size(); i++) {         for (int j = 1; j &lt; lineList.size(); j++) {             //A-&gt;B C-&gt;A, B C同省，同车型             if (lineList.get(i).sCen == lineList.get(j).eCen                     &amp;&amp; lineList.get(j).ePro == lineList.get(i).sPro                     &amp;&amp;lineList.get(i).tType==lineList.get(j).tType) {                 result.set(i, (lineList.get(i).id + lineList.get(j).id));                 lineList.remove(i);                 lineList.remove(j);             }         }     }     return result; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>从解法一可知，本题的时间复杂度最大为 $O(n^3)$ ，那么能不能降低呢？我们知道往往可以用<strong>空间</strong>换<strong>时间</strong>，所以：</p><ol><li>针对规则 1 ，我们可以用 <code>HashMap</code> 存储单边车对象，其中 <code>Key</code> 为出发<code>分拨中心+到达分拨中心+车型</code>的编码， <code>Value</code> 为相同 <code>Key</code> 的对象个数。查找时 <code>Key</code> 的编码规则为 <code>到达分拨中心+分拨中心+车型</code> ，由于 <code>HashMap</code> 查找 <code>Key</code> 的时间复杂度为 $O(n)$ ，故规则 1 时间复杂度可以降为  $O(n)$ ，加上额外的空间复杂度  $O(n)$ 。</li><li>针对规则 2 ，我们可以将所有的 <code>A-&gt;X , X-&gt;C</code> 生成新的 <code>A-&gt;C</code> ，空间复杂度为   $O(n^2)$ ，然后与原有单边车数据循环匹配，时间复杂度为  $O(n^2)$ ，匹配过程中注意对已经匹配的数据去重。综上，规则 2 的时间复杂度由解法一的  $O(n^3)$ ，变为  $O(n^2)$ 的时间复杂度加上  $O(n^2)$ 的空间复杂度，此外，新生成的 <code>A-&gt;C</code> 可用于规则 3 的判断。</li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 路径优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识预备</title>
      <link href="/2018/03/04/ji-chu-zhi-shi-yu-bei/"/>
      <url>/2018/03/04/ji-chu-zhi-shi-yu-bei/</url>
      
        <content type="html"><![CDATA[<p>  本文介绍开始学习微积分的基础知识，包括实数，坐标系，线段，函数等。</p><a id="more"></a><h2 id="实数和实线"><a href="#实数和实线" class="headerlink" title="实数和实线"></a>实数和实线</h2><ul><li>复数、虚数、实数、有理数、无理数、整数关系如下图所示：<br><img src="numbers.jpeg" alt="复数"></li><li><a href="https://en.wikipedia.org/wiki/Completeness_of_the_real_numbers" title="实数完备性">实数的完备性</a></li></ul><h2 id="线、圆和抛物线"><a href="#线、圆和抛物线" class="headerlink" title="线、圆和抛物线"></a>线、圆和抛物线</h2><p>斜率定义（其中 $ \phi $ 为逆时针）：</p><p>$$<br>m={\Delta x \over \Delta y}={ y_2-y_1 \over x_2-x_1}=\tan\phi<br>$$</p><p>两条非竖直直线垂直则有(斜率分别为 $ m_1$  和 $ m_2 $)：</p><p>$$<br> m_1m_2=-1<br>$$</p><h2 id="函数与图像"><a href="#函数与图像" class="headerlink" title="函数与图像"></a>函数与图像</h2><p>函数 $ f(x)$ 是一种从集合 $ D$ 到 $ Y$ 的映射，对于 $ \forall x \in D $ 都有 <code>唯一的</code> $ f(x) \in Y $</p><h2 id="常见函数与数学模型"><a href="#常见函数与数学模型" class="headerlink" title="常见函数与数学模型"></a>常见函数与数学模型</h2><ol><li>线性函数： $ y=mx+b $</li><li>幂函数：$ y=x^a $</li><li>多项式函数：$ p(x)=a_nx^n+a_{n-1}x^{n-1}+ \cdots +a_1x+a_0$</li><li>有理数函数：$f(x)={p(x) \over q(x)}$</li><li>代数函数：由多项式通过代数运算（加、减、乘、除、开方）组合形成的函数</li><li>三角函数： $ f(x)=sinx$</li><li>指数函数：$f(x)=a^x$</li><li>对数函数：$ f(x)=lnx$</li></ol><p>函数的单调性<br>奇函数和偶函数，奇函数满足 $f(-x)=-f(x)$ ，偶函数满足 $f(-x)=f(x)$</p><h3 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a>数学模型</h3><p>数学模型是对现实世界的抽象和简化。<br><img src="mathematicalModel.png" alt="数学模型"></p><h2 id="函数的组合、平移和缩放"><a href="#函数的组合、平移和缩放" class="headerlink" title="函数的组合、平移和缩放"></a>函数的组合、平移和缩放</h2><p>函数的组合运算：</p><ol><li>$ (f+g)(x)=f(x)+g(x)$</li><li>$ (f-g)(x)=f(x)-g(x) $</li><li>$ (fg)(x)=f(x)g(x)$</li><li>$ ({f \over g })(x)={ f(x) \over g(x)}$</li><li>$ (cf)(x)=cf(x)$</li></ol><p>函数的复合：$ (f \circ  g)(x)=f(g(x))$</p><p>函数的平移和缩放： $y=cf(mx+b)+d$</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 微积分 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
